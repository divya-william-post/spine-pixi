{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { settings, TransformMode, MathUtils } from '@pixi-spine/base';\nclass IkConstraint {\n  constructor(data, skeleton) {\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    this.bendDirection = 0;\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    this.compress = false;\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    this.stretch = false;\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    this.mix = 1;\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    this.softness = 0;\n    this.active = false;\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.mix = data.mix;\n    this.softness = data.softness;\n    this.bendDirection = data.bendDirection;\n    this.compress = data.compress;\n    this.stretch = data.stretch;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findBone(data.target.name);\n    if (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\n    this.target = target;\n  }\n  isActive() {\n    return this.active;\n  }\n  update() {\n    if (this.mix == 0) return;\n    const target = this.target;\n    const bones = this.bones;\n    switch (bones.length) {\n      case 1:\n        this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n        break;\n      case 2:\n        this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n        break;\n    }\n  }\n  /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n  apply1(bone, targetX, targetY, compress, stretch, uniform, alpha) {\n    const p = bone.parent.matrix;\n    if (!p) throw new Error(\"IK bone must have parent.\");\n    const pa = p.a;\n    let pb = p.c;\n    const pc = p.b;\n    let pd = p.d;\n    let rotationIK = -bone.ashearX - bone.arotation;\n    let tx = 0;\n    let ty = 0;\n    const skelX = bone.skeleton.scaleX;\n    const skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;\n    switch (bone.data.transformMode) {\n      case TransformMode.OnlyTranslation:\n        tx = targetX - bone.worldX;\n        ty = targetY - bone.worldY;\n        if (settings.yDown) {\n          ty = -ty;\n        }\n        break;\n      case TransformMode.NoRotationOrReflection:\n        const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n        const sa = pa / skelX;\n        const sc = pc / skelY;\n        pb = -sc * s * skelX;\n        pd = sa * s * skelY;\n        rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n      default:\n        const x = targetX - p.tx;\n        const y = targetY - p.ty;\n        const d = pa * pd - pb * pc;\n        tx = (x * pd - y * pb) / d - bone.ax;\n        ty = (y * pa - x * pc) / d - bone.ay;\n    }\n    rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n    if (bone.ascaleX < 0) rotationIK += 180;\n    if (rotationIK > 180) rotationIK -= 360;else if (rotationIK < -180) rotationIK += 360;\n    let sx = bone.ascaleX;\n    let sy = bone.ascaleY;\n    if (compress || stretch) {\n      switch (bone.data.transformMode) {\n        case TransformMode.NoScale:\n        case TransformMode.NoScaleOrReflection:\n          tx = targetX - bone.worldX;\n          ty = targetY - bone.worldY;\n      }\n      const b = bone.data.length * sx;\n      const dd = Math.sqrt(tx * tx + ty * ty);\n      if (compress && dd < b || stretch && dd > b && b > 1e-4) {\n        const s = (dd / b - 1) * alpha + 1;\n        sx *= s;\n        if (uniform) sy *= s;\n      }\n    }\n    bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n  }\n  /** Applies 2 bone IK. The target is specified in the world coordinate system.\n   * @param child A direct descendant of the parent bone. */\n  apply2(parent, child, targetX, targetY, bendDir, stretch, uniform, softness, alpha) {\n    const px = parent.ax;\n    const py = parent.ay;\n    let psx = parent.ascaleX;\n    let psy = parent.ascaleY;\n    let sx = psx;\n    let sy = psy;\n    let csx = child.ascaleX;\n    const pmat = parent.matrix;\n    let os1 = 0;\n    let os2 = 0;\n    let s2 = 0;\n    if (psx < 0) {\n      psx = -psx;\n      os1 = 180;\n      s2 = -1;\n    } else {\n      os1 = 0;\n      s2 = 1;\n    }\n    if (psy < 0) {\n      psy = -psy;\n      s2 = -s2;\n    }\n    if (csx < 0) {\n      csx = -csx;\n      os2 = 180;\n    } else os2 = 0;\n    const cx = child.ax;\n    let cy = 0;\n    let cwx = 0;\n    let cwy = 0;\n    let a = pmat.a;\n    let b = pmat.c;\n    let c = pmat.b;\n    let d = pmat.d;\n    const u = Math.abs(psx - psy) <= 1e-4;\n    if (!u || stretch) {\n      cy = 0;\n      cwx = a * cx + pmat.tx;\n      cwy = c * cx + pmat.ty;\n    } else {\n      cy = child.ay;\n      cwx = a * cx + b * cy + pmat.tx;\n      cwy = c * cx + d * cy + pmat.ty;\n    }\n    const pp = parent.parent.matrix;\n    if (!pp) throw new Error(\"IK parent must itself have a parent.\");\n    a = pp.a;\n    b = pp.c;\n    c = pp.b;\n    d = pp.d;\n    const id = 1 / (a * d - b * c);\n    let x = cwx - pp.tx;\n    let y = cwy - pp.ty;\n    const dx = (x * d - y * b) * id - px;\n    const dy = (y * a - x * c) * id - py;\n    const l1 = Math.sqrt(dx * dx + dy * dy);\n    let l2 = child.data.length * csx;\n    let a1;\n    let a2;\n    if (l1 < 1e-4) {\n      this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n      child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n      return;\n    }\n    x = targetX - pp.tx;\n    y = targetY - pp.ty;\n    let tx = (x * d - y * b) * id - px;\n    let ty = (y * a - x * c) * id - py;\n    let dd = tx * tx + ty * ty;\n    if (softness != 0) {\n      softness *= psx * (csx + 1) * 0.5;\n      const td = Math.sqrt(dd);\n      const sd = td - l1 - l2 * psx + softness;\n      if (sd > 0) {\n        let p = Math.min(1, sd / (softness * 2)) - 1;\n        p = (sd - softness * (1 - p * p)) / td;\n        tx -= p * tx;\n        ty -= p * ty;\n        dd = tx * tx + ty * ty;\n      }\n    }\n    outer: if (u) {\n      l2 *= psx;\n      let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n      if (cos < -1) {\n        cos = -1;\n        a2 = Math.PI * bendDir;\n      } else if (cos > 1) {\n        cos = 1;\n        a2 = 0;\n        if (stretch) {\n          a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n          sx *= a;\n          if (uniform) sy *= a;\n        }\n      } else a2 = Math.acos(cos) * bendDir;\n      a = l1 + l2 * cos;\n      b = l2 * Math.sin(a2);\n      a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n    } else {\n      a = psx * l2;\n      b = psy * l2;\n      const aa = a * a;\n      const bb = b * b;\n      const ta = Math.atan2(ty, tx);\n      c = bb * l1 * l1 + aa * dd - aa * bb;\n      const c1 = -2 * bb * l1;\n      const c2 = bb - aa;\n      d = c1 * c1 - 4 * c2 * c;\n      if (d >= 0) {\n        let q = Math.sqrt(d);\n        if (c1 < 0) q = -q;\n        q = -(c1 + q) * 0.5;\n        const r0 = q / c2;\n        const r1 = c / q;\n        const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n        if (r * r <= dd) {\n          y = Math.sqrt(dd - r * r) * bendDir;\n          a1 = ta - Math.atan2(y, r);\n          a2 = Math.atan2(y / psy, (r - l1) / psx);\n          break outer;\n        }\n      }\n      let minAngle = MathUtils.PI;\n      let minX = l1 - a;\n      let minDist = minX * minX;\n      let minY = 0;\n      let maxAngle = 0;\n      let maxX = l1 + a;\n      let maxDist = maxX * maxX;\n      let maxY = 0;\n      c = -a * l1 / (aa - bb);\n      if (c >= -1 && c <= 1) {\n        c = Math.acos(c);\n        x = a * Math.cos(c) + l1;\n        y = b * Math.sin(c);\n        d = x * x + y * y;\n        if (d < minDist) {\n          minAngle = c;\n          minDist = d;\n          minX = x;\n          minY = y;\n        }\n        if (d > maxDist) {\n          maxAngle = c;\n          maxDist = d;\n          maxX = x;\n          maxY = y;\n        }\n      }\n      if (dd <= (minDist + maxDist) * 0.5) {\n        a1 = ta - Math.atan2(minY * bendDir, minX);\n        a2 = minAngle * bendDir;\n      } else {\n        a1 = ta - Math.atan2(maxY * bendDir, maxX);\n        a2 = maxAngle * bendDir;\n      }\n    }\n    const os = Math.atan2(cy, cx) * s2;\n    let rotation = parent.arotation;\n    a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n    if (a1 > 180) a1 -= 360;else if (a1 < -180) a1 += 360;\n    parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n    rotation = child.arotation;\n    a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n    if (a2 > 180) a2 -= 360;else if (a2 < -180) a2 += 360;\n    child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n  }\n}\nexport { IkConstraint };","map":{"version":3,"names":["IkConstraint","constructor","data","skeleton","bendDirection","compress","stretch","mix","softness","active","Error","bones","Array","i","length","bone","findBone","name","push","target","isActive","update","apply1","worldX","worldY","uniform","apply2","targetX","targetY","alpha","p","parent","matrix","pa","a","pb","c","pc","b","pd","d","rotationIK","ashearX","arotation","tx","ty","skelX","scaleX","skelY","settings","yDown","scaleY","transformMode","TransformMode","OnlyTranslation","NoRotationOrReflection","s","Math","abs","sa","sc","atan2","MathUtils","radDeg","x","y","ax","ay","ascaleX","sx","sy","ascaleY","NoScale","NoScaleOrReflection","dd","sqrt","updateWorldTransformWith","ashearY","child","bendDir","px","py","psx","psy","csx","pmat","os1","os2","s2","cx","cy","cwx","cwy","u","pp","id","dx","dy","l1","l2","a1","a2","td","sd","min","outer","cos","PI","acos","sin","aa","bb","ta","c1","c2","q","r0","r1","r","minAngle","minX","minDist","minY","maxAngle","maxX","maxDist","maxY","os","rotation"],"sources":["../../src/core/IkConstraint.ts"],"sourcesContent":["import type { Updatable } from './Updatable';\nimport type { IkConstraintData } from './IkConstraintData';\nimport type { Bone } from './Bone';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, settings, TransformMode } from '@pixi-spine/base';\n\n/** Stores the current pose for an IK constraint. An IK constraint adjusts the rotation of 1 or 2 constrained bones so the tip of\n * the last bone is as close to the target bone as possible.\n *\n * See [IK constraints](http://esotericsoftware.com/spine-ik-constraints) in the Spine User Guide.\n * @public\n * */\nexport class IkConstraint implements Updatable {\n    /** The IK constraint's setup pose data. */\n    data: IkConstraintData;\n\n    /** The bones that will be modified by this IK constraint. */\n    bones: Array<Bone>;\n\n    /** The bone that is the IK target. */\n    target: Bone;\n\n    /** Controls the bend direction of the IK bones, either 1 or -1. */\n    bendDirection = 0;\n\n    /** When true and only a single bone is being constrained, if the target is too close, the bone is scaled to reach it. */\n    compress = false;\n\n    /** When true, if the target is out of range, the parent bone is scaled to reach it. If more than one bone is being constrained\n     * and the parent bone has local nonuniform scale, stretch is not applied. */\n    stretch = false;\n\n    /** A percentage (0-1) that controls the mix between the constrained and unconstrained rotations. */\n    mix = 1;\n\n    /** For two bone IK, the distance from the maximum reach of the bones that rotation will slow. */\n    softness = 0;\n    active = false;\n\n    constructor(data: IkConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.mix = data.mix;\n        this.softness = data.softness;\n        this.bendDirection = data.bendDirection;\n        this.compress = data.compress;\n        this.stretch = data.stretch;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const bone = skeleton.findBone(data.bones[i].name);\n\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}`);\n            this.bones.push(bone);\n        }\n        const target = skeleton.findBone(data.target.name);\n\n        if (!target) throw new Error(`Couldn't find bone ${data.target.name}`);\n        this.target = target;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        if (this.mix == 0) return;\n        const target = this.target;\n        const bones = this.bones;\n\n        switch (bones.length) {\n            case 1:\n                this.apply1(bones[0], target.worldX, target.worldY, this.compress, this.stretch, this.data.uniform, this.mix);\n                break;\n            case 2:\n                this.apply2(bones[0], bones[1], target.worldX, target.worldY, this.bendDirection, this.stretch, this.data.uniform, this.softness, this.mix);\n                break;\n        }\n    }\n\n    /** Applies 1 bone IK. The target is specified in the world coordinate system. */\n    apply1(bone: Bone, targetX: number, targetY: number, compress: boolean, stretch: boolean, uniform: boolean, alpha: number) {\n        const p = bone.parent.matrix;\n\n        if (!p) throw new Error('IK bone must have parent.');\n        const pa = p.a;\n        let pb = p.c;\n        const pc = p.b;\n        let pd = p.d;\n        let rotationIK = -bone.ashearX - bone.arotation;\n        let tx = 0;\n        let ty = 0;\n\n        const skelX = bone.skeleton.scaleX;\n        const skelY = settings.yDown ? -bone.skeleton.scaleY : bone.skeleton.scaleY;\n\n        switch (bone.data.transformMode) {\n            case TransformMode.OnlyTranslation:\n                tx = targetX - bone.worldX;\n                ty = targetY - bone.worldY;\n                // TODO: possible bug in spine-ts runtime!\n                if (settings.yDown) {\n                    ty = -ty;\n                }\n                break;\n            case TransformMode.NoRotationOrReflection:\n                const s = Math.abs(pa * pd - pb * pc) / (pa * pa + pc * pc);\n                const sa = pa / skelX;\n                const sc = pc / skelY;\n\n                pb = -sc * s * skelX;\n                pd = sa * s * skelY;\n                rotationIK += Math.atan2(sc, sa) * MathUtils.radDeg;\n            // Fall through\n            default:\n                const x = targetX - p.tx;\n                const y = targetY - p.ty;\n                const d = pa * pd - pb * pc;\n\n                tx = (x * pd - y * pb) / d - bone.ax;\n                ty = (y * pa - x * pc) / d - bone.ay;\n        }\n        rotationIK += Math.atan2(ty, tx) * MathUtils.radDeg;\n        if (bone.ascaleX < 0) rotationIK += 180;\n        if (rotationIK > 180) rotationIK -= 360;\n        else if (rotationIK < -180) rotationIK += 360;\n        let sx = bone.ascaleX;\n        let sy = bone.ascaleY;\n\n        if (compress || stretch) {\n            switch (bone.data.transformMode) {\n                case TransformMode.NoScale:\n                case TransformMode.NoScaleOrReflection:\n                    tx = targetX - bone.worldX;\n                    ty = targetY - bone.worldY;\n            }\n            const b = bone.data.length * sx;\n            const dd = Math.sqrt(tx * tx + ty * ty);\n\n            if ((compress && dd < b) || (stretch && dd > b && b > 0.0001)) {\n                const s = (dd / b - 1) * alpha + 1;\n\n                sx *= s;\n                if (uniform) sy *= s;\n            }\n        }\n        bone.updateWorldTransformWith(bone.ax, bone.ay, bone.arotation + rotationIK * alpha, sx, sy, bone.ashearX, bone.ashearY);\n    }\n\n    /** Applies 2 bone IK. The target is specified in the world coordinate system.\n     * @param child A direct descendant of the parent bone. */\n    apply2(parent: Bone, child: Bone, targetX: number, targetY: number, bendDir: number, stretch: boolean, uniform: boolean, softness: number, alpha: number) {\n        const px = parent.ax;\n        const py = parent.ay;\n        let psx = parent.ascaleX;\n        let psy = parent.ascaleY;\n        let sx = psx;\n        let sy = psy;\n        let csx = child.ascaleX;\n        const pmat = parent.matrix;\n        let os1 = 0;\n        let os2 = 0;\n        let s2 = 0;\n\n        if (psx < 0) {\n            psx = -psx;\n            os1 = 180;\n            s2 = -1;\n        } else {\n            os1 = 0;\n            s2 = 1;\n        }\n        if (psy < 0) {\n            psy = -psy;\n            s2 = -s2;\n        }\n        if (csx < 0) {\n            csx = -csx;\n            os2 = 180;\n        } else os2 = 0;\n        const cx = child.ax;\n        let cy = 0;\n        let cwx = 0;\n        let cwy = 0;\n        let a = pmat.a;\n        let b = pmat.c;\n        let c = pmat.b;\n        let d = pmat.d;\n        const u = Math.abs(psx - psy) <= 0.0001;\n\n        if (!u || stretch) {\n            cy = 0;\n            cwx = a * cx + pmat.tx;\n            cwy = c * cx + pmat.ty;\n        } else {\n            cy = child.ay;\n            cwx = a * cx + b * cy + pmat.tx;\n            cwy = c * cx + d * cy + pmat.ty;\n        }\n        const pp = parent.parent.matrix;\n\n        if (!pp) throw new Error('IK parent must itself have a parent.');\n        a = pp.a;\n        b = pp.c;\n        c = pp.b;\n        d = pp.d;\n        const id = 1 / (a * d - b * c);\n        let x = cwx - pp.tx;\n        let y = cwy - pp.ty;\n        const dx = (x * d - y * b) * id - px;\n        const dy = (y * a - x * c) * id - py;\n        const l1 = Math.sqrt(dx * dx + dy * dy);\n        let l2 = child.data.length * csx;\n        let a1;\n        let a2;\n\n        if (l1 < 0.0001) {\n            this.apply1(parent, targetX, targetY, false, stretch, false, alpha);\n            child.updateWorldTransformWith(cx, cy, 0, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n\n            return;\n        }\n        x = targetX - pp.tx;\n        y = targetY - pp.ty;\n        let tx = (x * d - y * b) * id - px;\n        let ty = (y * a - x * c) * id - py;\n        let dd = tx * tx + ty * ty;\n\n        if (softness != 0) {\n            softness *= psx * (csx + 1) * 0.5;\n            const td = Math.sqrt(dd);\n            const sd = td - l1 - l2 * psx + softness;\n\n            if (sd > 0) {\n                let p = Math.min(1, sd / (softness * 2)) - 1;\n\n                p = (sd - softness * (1 - p * p)) / td;\n                tx -= p * tx;\n                ty -= p * ty;\n                dd = tx * tx + ty * ty;\n            }\n        }\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: if (u) {\n            l2 *= psx;\n            let cos = (dd - l1 * l1 - l2 * l2) / (2 * l1 * l2);\n\n            if (cos < -1) {\n                cos = -1;\n                a2 = Math.PI * bendDir;\n            } else if (cos > 1) {\n                cos = 1;\n                a2 = 0;\n                if (stretch) {\n                    a = (Math.sqrt(dd) / (l1 + l2) - 1) * alpha + 1;\n                    sx *= a;\n                    if (uniform) sy *= a;\n                }\n            } else a2 = Math.acos(cos) * bendDir;\n            a = l1 + l2 * cos;\n            b = l2 * Math.sin(a2);\n            a1 = Math.atan2(ty * a - tx * b, tx * a + ty * b);\n        } else {\n            a = psx * l2;\n            b = psy * l2;\n            const aa = a * a;\n            const bb = b * b;\n            const ta = Math.atan2(ty, tx);\n\n            c = bb * l1 * l1 + aa * dd - aa * bb;\n            const c1 = -2 * bb * l1;\n            const c2 = bb - aa;\n\n            d = c1 * c1 - 4 * c2 * c;\n            if (d >= 0) {\n                let q = Math.sqrt(d);\n\n                if (c1 < 0) q = -q;\n                q = -(c1 + q) * 0.5;\n                const r0 = q / c2;\n                const r1 = c / q;\n                const r = Math.abs(r0) < Math.abs(r1) ? r0 : r1;\n\n                if (r * r <= dd) {\n                    y = Math.sqrt(dd - r * r) * bendDir;\n                    a1 = ta - Math.atan2(y, r);\n                    a2 = Math.atan2(y / psy, (r - l1) / psx);\n                    // eslint-disable-next-line no-labels\n                    break outer;\n                }\n            }\n            let minAngle = MathUtils.PI;\n            let minX = l1 - a;\n            let minDist = minX * minX;\n            let minY = 0;\n            let maxAngle = 0;\n            let maxX = l1 + a;\n            let maxDist = maxX * maxX;\n            let maxY = 0;\n\n            c = (-a * l1) / (aa - bb);\n            if (c >= -1 && c <= 1) {\n                c = Math.acos(c);\n                x = a * Math.cos(c) + l1;\n                y = b * Math.sin(c);\n                d = x * x + y * y;\n                if (d < minDist) {\n                    minAngle = c;\n                    minDist = d;\n                    minX = x;\n                    minY = y;\n                }\n                if (d > maxDist) {\n                    maxAngle = c;\n                    maxDist = d;\n                    maxX = x;\n                    maxY = y;\n                }\n            }\n            if (dd <= (minDist + maxDist) * 0.5) {\n                a1 = ta - Math.atan2(minY * bendDir, minX);\n                a2 = minAngle * bendDir;\n            } else {\n                a1 = ta - Math.atan2(maxY * bendDir, maxX);\n                a2 = maxAngle * bendDir;\n            }\n        }\n        const os = Math.atan2(cy, cx) * s2;\n        let rotation = parent.arotation;\n\n        a1 = (a1 - os) * MathUtils.radDeg + os1 - rotation;\n        if (a1 > 180) a1 -= 360;\n        else if (a1 < -180)\n            //\n            a1 += 360;\n        parent.updateWorldTransformWith(px, py, rotation + a1 * alpha, sx, sy, 0, 0);\n        rotation = child.arotation;\n        a2 = ((a2 + os) * MathUtils.radDeg - child.ashearX) * s2 + os2 - rotation;\n        if (a2 > 180) a2 -= 360;\n        else if (a2 < -180)\n            //\n            a2 += 360;\n        child.updateWorldTransformWith(cx, cy, rotation + a2 * alpha, child.ascaleX, child.ascaleY, child.ashearX, child.ashearY);\n    }\n}\n"],"mappings":";;AAYO,MAAMA,YAAkC;EA2B3CC,YAAYC,IAAA,EAAwBC,QAAoB;IAhBxD;IAAgB,KAAAC,aAAA;IAGhB;IAAW,KAAAC,QAAA;IAIX;AAAA;IAAU,KAAAC,OAAA;IAGV;IAAM,KAAAC,GAAA;IAGN;IAAW,KAAAC,QAAA;IACF,KAAAC,MAAA;IAGL,IAAI,CAACP,IAAA,EAAY,UAAIQ,KAAA,CAAM,sBAAsB;IACjD,IAAI,CAACP,QAAA,EAAgB,UAAIO,KAAA,CAAM,0BAA0B;IACzD,KAAKR,IAAO,GAAAA,IAAA;IACZ,KAAKK,GAAA,GAAML,IAAK,CAAAK,GAAA;IAChB,KAAKC,QAAA,GAAWN,IAAK,CAAAM,QAAA;IACrB,KAAKJ,aAAA,GAAgBF,IAAK,CAAAE,aAAA;IAC1B,KAAKC,QAAA,GAAWH,IAAK,CAAAG,QAAA;IACrB,KAAKC,OAAA,GAAUJ,IAAK,CAAAI,OAAA;IAEf,KAAAK,KAAA,GAAQ,IAAIC,KAAY;IAC7B,SAASC,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIX,IAAK,CAAAS,KAAA,CAAMG,MAAA,EAAQD,CAAK;MACxC,MAAME,IAAA,GAAOZ,QAAS,CAAAa,QAAA,CAASd,IAAA,CAAKS,KAAM,CAAAE,CAAC,EAAEI,IAAI;MAEjD,IAAI,CAACF,IAAA,EAAM,MAAM,IAAIL,KAAM,uBAAsBR,IAAA,CAAKS,KAAM,CAAAE,CAAC,EAAEI,IAAM;MAChE,KAAAN,KAAA,CAAMO,IAAA,CAAKH,IAAI;IAAA;IAExB,MAAMI,MAAS,GAAAhB,QAAA,CAASa,QAAS,CAAAd,IAAA,CAAKiB,MAAA,CAAOF,IAAI;IAEjD,IAAI,CAACE,MAAA,EAAQ,MAAM,IAAIT,KAAA,CAAM,sBAAsBR,IAAA,CAAKiB,MAAA,CAAOF,IAAM;IACrE,KAAKE,MAAS,GAAAA,MAAA;EAAA;EAGlBC,QAAWA,CAAA;IACP,OAAO,IAAK,CAAAX,MAAA;EAAA;EAGhBY,MAASA,CAAA;IACL,IAAI,KAAKd,GAAO,OAAG;IACnB,MAAMY,MAAA,GAAS,IAAK,CAAAA,MAAA;IACpB,MAAMR,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,QAAQA,KAAA,CAAMG,MAAQ;MAClB,KAAK;QACD,KAAKQ,MAAA,CAAOX,KAAM,EAAC,CAAG,EAAAQ,MAAA,CAAOI,MAAA,EAAQJ,MAAO,CAAAK,MAAA,EAAQ,IAAK,CAAAnB,QAAA,EAAU,KAAKC,OAAS,OAAKJ,IAAK,CAAAuB,OAAA,EAAS,KAAKlB,GAAG;QAC5G;MACJ,KAAK;QACI,KAAAmB,MAAA,CAAOf,KAAA,CAAM,CAAC,GAAGA,KAAA,CAAM,CAAC,GAAGQ,MAAA,CAAOI,MAAQ,EAAAJ,MAAA,CAAOK,MAAA,EAAQ,IAAK,CAAApB,aAAA,EAAe,KAAKE,OAAS,OAAKJ,IAAA,CAAKuB,OAAS,OAAKjB,QAAU,OAAKD,GAAG;QAC1I;IAAA;EACR;EACJ;EAGAe,OAAOP,IAAY,EAAAY,OAAA,EAAiBC,OAAA,EAAiBvB,QAAmB,EAAAC,OAAA,EAAkBmB,OAAA,EAAkBI,KAAe;IACjH,MAAAC,CAAA,GAAIf,IAAA,CAAKgB,MAAO,CAAAC,MAAA;IAEtB,IAAI,CAACF,CAAA,EAAS,UAAIpB,KAAA,CAAM,2BAA2B;IACnD,MAAMuB,EAAA,GAAKH,CAAE,CAAAI,CAAA;IACb,IAAIC,EAAA,GAAKL,CAAE,CAAAM,CAAA;IACX,MAAMC,EAAA,GAAKP,CAAE,CAAAQ,CAAA;IACb,IAAIC,EAAA,GAAKT,CAAE,CAAAU,CAAA;IACX,IAAIC,UAAa,IAAC1B,IAAK,CAAA2B,OAAA,GAAU3B,IAAK,CAAA4B,SAAA;IACtC,IAAIC,EAAK;IACT,IAAIC,EAAK;IAEH,MAAAC,KAAA,GAAQ/B,IAAA,CAAKZ,QAAS,CAAA4C,MAAA;IACtB,MAAAC,KAAA,GAAQC,QAAA,CAASC,KAAQ,IAACnC,IAAA,CAAKZ,QAAS,CAAAgD,MAAA,GAASpC,IAAA,CAAKZ,QAAS,CAAAgD,MAAA;IAE7D,QAAApC,IAAA,CAAKb,IAAA,CAAKkD,aAAe;MAC7B,KAAKC,aAAc,CAAAC,eAAA;QACfV,EAAA,GAAKjB,OAAA,GAAUZ,IAAK,CAAAQ,MAAA;QACpBsB,EAAA,GAAKjB,OAAA,GAAUb,IAAK,CAAAS,MAAA;QAEpB,IAAIyB,QAAA,CAASC,KAAO;UAChBL,EAAA,GAAK,CAACA,EAAA;QAAA;QAEV;MACJ,KAAKQ,aAAc,CAAAE,sBAAA;QACT,MAAAC,CAAA,GAAIC,IAAK,CAAAC,GAAA,CAAIzB,EAAK,GAAAM,EAAA,GAAKJ,EAAA,GAAKE,EAAE,KAAKJ,EAAK,GAAAA,EAAA,GAAKI,EAAK,GAAAA,EAAA;QACxD,MAAMsB,EAAA,GAAK1B,EAAK,GAAAa,KAAA;QAChB,MAAMc,EAAA,GAAKvB,EAAK,GAAAW,KAAA;QAEXb,EAAA,IAACyB,EAAA,GAAKJ,CAAI,GAAAV,KAAA;QACfP,EAAA,GAAKoB,EAAA,GAAKH,CAAI,GAAAR,KAAA;QACdP,UAAA,IAAcgB,IAAK,CAAAI,KAAA,CAAMD,EAAI,EAAAD,EAAE,IAAIG,SAAU,CAAAC,MAAA;MAEjD;QACU,MAAAC,CAAA,GAAIrC,OAAA,GAAUG,CAAE,CAAAc,EAAA;QAChB,MAAAqB,CAAA,GAAIrC,OAAA,GAAUE,CAAE,CAAAe,EAAA;QAChB,MAAAL,CAAA,GAAIP,EAAK,GAAAM,EAAA,GAAKJ,EAAK,GAAAE,EAAA;QAEzBO,EAAA,IAAMoB,CAAI,GAAAzB,EAAA,GAAK0B,CAAI,GAAA9B,EAAA,IAAMK,CAAA,GAAIzB,IAAK,CAAAmD,EAAA;QAClCrB,EAAA,IAAMoB,CAAI,GAAAhC,EAAA,GAAK+B,CAAI,GAAA3B,EAAA,IAAMG,CAAA,GAAIzB,IAAK,CAAAoD,EAAA;IAAA;IAE1C1B,UAAA,IAAcgB,IAAK,CAAAI,KAAA,CAAMhB,EAAI,EAAAD,EAAE,IAAIkB,SAAU,CAAAC,MAAA;IAC7C,IAAIhD,IAAA,CAAKqD,OAAU,MAAiB3B,UAAA;IACpC,IAAIA,UAAa,QAAmBA,UAAA,iBAC3BA,UAAa,SAAoBA,UAAA;IAC1C,IAAI4B,EAAA,GAAKtD,IAAK,CAAAqD,OAAA;IACd,IAAIE,EAAA,GAAKvD,IAAK,CAAAwD,OAAA;IAEd,IAAIlE,QAAA,IAAYC,OAAS;MACb,QAAAS,IAAA,CAAKb,IAAA,CAAKkD,aAAe;QAC7B,KAAKC,aAAc,CAAAmB,OAAA;QACnB,KAAKnB,aAAc,CAAAoB,mBAAA;UACf7B,EAAA,GAAKjB,OAAA,GAAUZ,IAAK,CAAAQ,MAAA;UACpBsB,EAAA,GAAKjB,OAAA,GAAUb,IAAK,CAAAS,MAAA;MAAA;MAEtB,MAAAc,CAAA,GAAIvB,IAAK,CAAAb,IAAA,CAAKY,MAAS,GAAAuD,EAAA;MAC7B,MAAMK,EAAA,GAAKjB,IAAK,CAAAkB,IAAA,CAAK/B,EAAK,GAAAA,EAAA,GAAKC,EAAA,GAAKA,EAAE;MAEtC,IAAKxC,QAAA,IAAYqE,EAAK,GAAApC,CAAA,IAAOhC,OAAA,IAAWoE,EAAK,GAAApC,CAAA,IAAKA,CAAA,GAAI,IAAS;QAC3D,MAAMkB,CAAK,IAAAkB,EAAA,GAAKpC,CAAI,QAAKT,KAAQ;QAE3BwC,EAAA,IAAAb,CAAA;QACF,IAAA/B,OAAA,EAAe6C,EAAA,IAAAd,CAAA;MAAA;IACvB;IAEJzC,IAAA,CAAK6D,wBAAyB,CAAA7D,IAAA,CAAKmD,EAAI,EAAAnD,IAAA,CAAKoD,EAAA,EAAIpD,IAAK,CAAA4B,SAAA,GAAYF,UAAa,GAAAZ,KAAA,EAAOwC,EAAI,EAAAC,EAAA,EAAIvD,IAAK,CAAA2B,OAAA,EAAS3B,IAAA,CAAK8D,OAAO;EAAA;EAC3H;AAAA;EAIAnD,OAAOK,MAAA,EAAc+C,KAAa,EAAAnD,OAAA,EAAiBC,OAAA,EAAiBmD,OAAiB,EAAAzE,OAAA,EAAkBmB,OAAkB,EAAAjB,QAAA,EAAkBqB,KAAe;IACtJ,MAAMmD,EAAA,GAAKjD,MAAO,CAAAmC,EAAA;IAClB,MAAMe,EAAA,GAAKlD,MAAO,CAAAoC,EAAA;IAClB,IAAIe,GAAA,GAAMnD,MAAO,CAAAqC,OAAA;IACjB,IAAIe,GAAA,GAAMpD,MAAO,CAAAwC,OAAA;IACjB,IAAIF,EAAK,GAAAa,GAAA;IACT,IAAIZ,EAAK,GAAAa,GAAA;IACT,IAAIC,GAAA,GAAMN,KAAM,CAAAV,OAAA;IAChB,MAAMiB,IAAA,GAAOtD,MAAO,CAAAC,MAAA;IACpB,IAAIsD,GAAM;IACV,IAAIC,GAAM;IACV,IAAIC,EAAK;IAET,IAAIN,GAAA,GAAM,CAAG;MACTA,GAAA,GAAM,CAACA,GAAA;MACDI,GAAA;MACDE,EAAA;IAAA,CACF;MACGF,GAAA;MACDE,EAAA;IAAA;IAET,IAAIL,GAAA,GAAM,CAAG;MACTA,GAAA,GAAM,CAACA,GAAA;MACPK,EAAA,GAAK,CAACA,EAAA;IAAA;IAEV,IAAIJ,GAAA,GAAM,CAAG;MACTA,GAAA,GAAM,CAACA,GAAA;MACDG,GAAA;IAAA,CACV,MAAaA,GAAA;IACb,MAAME,EAAA,GAAKX,KAAM,CAAAZ,EAAA;IACjB,IAAIwB,EAAK;IACT,IAAIC,GAAM;IACV,IAAIC,GAAM;IACV,IAAI1D,CAAA,GAAImD,IAAK,CAAAnD,CAAA;IACb,IAAII,CAAA,GAAI+C,IAAK,CAAAjD,CAAA;IACb,IAAIA,CAAA,GAAIiD,IAAK,CAAA/C,CAAA;IACb,IAAIE,CAAA,GAAI6C,IAAK,CAAA7C,CAAA;IACb,MAAMqD,CAAI,GAAApC,IAAA,CAAKC,GAAI,CAAAwB,GAAA,GAAMC,GAAG,CAAK;IAE7B,KAACU,CAAA,IAAKvF,OAAS;MACVoF,EAAA;MACCC,GAAA,GAAAzD,CAAA,GAAIuD,EAAA,GAAKJ,IAAK,CAAAzC,EAAA;MACdgD,GAAA,GAAAxD,CAAA,GAAIqD,EAAA,GAAKJ,IAAK,CAAAxC,EAAA;IAAA,CACjB;MACH6C,EAAA,GAAKZ,KAAM,CAAAX,EAAA;MACXwB,GAAA,GAAMzD,CAAI,GAAAuD,EAAA,GAAKnD,CAAI,GAAAoD,EAAA,GAAKL,IAAK,CAAAzC,EAAA;MAC7BgD,GAAA,GAAMxD,CAAI,GAAAqD,EAAA,GAAKjD,CAAI,GAAAkD,EAAA,GAAKL,IAAK,CAAAxC,EAAA;IAAA;IAE3B,MAAAiD,EAAA,GAAK/D,MAAA,CAAOA,MAAO,CAAAC,MAAA;IAEzB,IAAI,CAAC8D,EAAA,EAAU,UAAIpF,KAAA,CAAM,sCAAsC;IAC/DwB,CAAA,GAAI4D,EAAG,CAAA5D,CAAA;IACPI,CAAA,GAAIwD,EAAG,CAAA1D,CAAA;IACPA,CAAA,GAAI0D,EAAG,CAAAxD,CAAA;IACPE,CAAA,GAAIsD,EAAG,CAAAtD,CAAA;IACP,MAAMuD,EAAK,QAAK7D,CAAI,GAAAM,CAAA,GAAIF,CAAI,GAAAF,CAAA;IACxB,IAAA4B,CAAA,GAAI2B,GAAA,GAAMG,EAAG,CAAAlD,EAAA;IACb,IAAAqB,CAAA,GAAI2B,GAAA,GAAME,EAAG,CAAAjD,EAAA;IACjB,MAAMmD,EAAM,IAAAhC,CAAA,GAAIxB,CAAI,GAAAyB,CAAA,GAAI3B,CAAA,IAAKyD,EAAK,GAAAf,EAAA;IAClC,MAAMiB,EAAM,IAAAhC,CAAA,GAAI/B,CAAI,GAAA8B,CAAA,GAAI5B,CAAA,IAAK2D,EAAK,GAAAd,EAAA;IAClC,MAAMiB,EAAA,GAAKzC,IAAK,CAAAkB,IAAA,CAAKqB,EAAK,GAAAA,EAAA,GAAKC,EAAA,GAAKA,EAAE;IAClC,IAAAE,EAAA,GAAKrB,KAAM,CAAA5E,IAAA,CAAKY,MAAS,GAAAsE,GAAA;IACzB,IAAAgB,EAAA;IACA,IAAAC,EAAA;IAEJ,IAAIH,EAAA,GAAK,IAAQ;MACb,KAAK5E,MAAA,CAAOS,MAAQ,EAAAJ,OAAA,EAASC,OAAA,EAAS,KAAO,EAAAtB,OAAA,EAAS,OAAOuB,KAAK;MAC5DiD,KAAA,CAAAF,wBAAA,CAAyBa,EAAI,EAAAC,EAAA,EAAI,CAAG,EAAAZ,KAAA,CAAMV,OAAS,EAAAU,KAAA,CAAMP,OAAS,EAAAO,KAAA,CAAMpC,OAAS,EAAAoC,KAAA,CAAMD,OAAO;MAEpG;IAAA;IAEJb,CAAA,GAAIrC,OAAA,GAAUmE,EAAG,CAAAlD,EAAA;IACjBqB,CAAA,GAAIrC,OAAA,GAAUkE,EAAG,CAAAjD,EAAA;IACjB,IAAID,EAAM,IAAAoB,CAAA,GAAIxB,CAAI,GAAAyB,CAAA,GAAI3B,CAAA,IAAKyD,EAAK,GAAAf,EAAA;IAChC,IAAInC,EAAM,IAAAoB,CAAA,GAAI/B,CAAI,GAAA8B,CAAA,GAAI5B,CAAA,IAAK2D,EAAK,GAAAd,EAAA;IAC5B,IAAAP,EAAA,GAAK9B,EAAK,GAAAA,EAAA,GAAKC,EAAK,GAAAA,EAAA;IAExB,IAAIrC,QAAA,IAAY,CAAG;MACHA,QAAA,IAAA0E,GAAA,IAAOE,GAAA,GAAM,CAAK;MACxB,MAAAkB,EAAA,GAAK7C,IAAK,CAAAkB,IAAA,CAAKD,EAAE;MACvB,MAAM6B,EAAK,GAAAD,EAAA,GAAKJ,EAAK,GAAAC,EAAA,GAAKjB,GAAM,GAAA1E,QAAA;MAEhC,IAAI+F,EAAA,GAAK,CAAG;QACR,IAAIzE,CAAA,GAAI2B,IAAK,CAAA+C,GAAA,CAAI,GAAGD,EAAM,IAAA/F,QAAA,GAAW,EAAE,CAAI;QAE3CsB,CAAA,IAAKyE,EAAK,GAAA/F,QAAA,IAAY,CAAI,GAAAsB,CAAA,GAAIA,CAAM,KAAAwE,EAAA;QACpC1D,EAAA,IAAMd,CAAI,GAAAc,EAAA;QACVC,EAAA,IAAMf,CAAI,GAAAe,EAAA;QACL6B,EAAA,GAAA9B,EAAA,GAAKA,EAAA,GAAKC,EAAK,GAAAA,EAAA;MAAA;IACxB;IAGJ4D,KAAA,EAAO,IAAIZ,CAAG;MACJM,EAAA,IAAAjB,GAAA;MACN,IAAIwB,GAAA,IAAOhC,EAAK,GAAAwB,EAAA,GAAKA,EAAA,GAAKC,EAAK,GAAAA,EAAA,KAAO,IAAID,EAAK,GAAAC,EAAA;MAE/C,IAAIO,GAAA,GAAM,CAAI;QACJA,GAAA;QACNL,EAAA,GAAK5C,IAAA,CAAKkD,EAAK,GAAA5B,OAAA;MAAA,CACnB,UAAW2B,GAAA,GAAM,CAAG;QACVA,GAAA;QACDL,EAAA;QACL,IAAI/F,OAAS;UACT4B,CAAA,IAAKuB,IAAA,CAAKkB,IAAK,CAAAD,EAAE,KAAKwB,EAAK,GAAAC,EAAA,IAAM,KAAKtE,KAAQ;UACxCwC,EAAA,IAAAnC,CAAA;UACF,IAAAT,OAAA,EAAe6C,EAAA,IAAApC,CAAA;QAAA;MACvB,CACJ,MAAYmE,EAAA,GAAA5C,IAAA,CAAKmD,IAAK,CAAAF,GAAG,CAAI,GAAA3B,OAAA;MAC7B7C,CAAA,GAAIgE,EAAA,GAAKC,EAAK,GAAAO,GAAA;MACVpE,CAAA,GAAA6D,EAAA,GAAK1C,IAAK,CAAAoD,GAAA,CAAIR,EAAE;MACfD,EAAA,GAAA3C,IAAA,CAAKI,KAAA,CAAMhB,EAAK,GAAAX,CAAA,GAAIU,EAAA,GAAKN,CAAG,EAAAM,EAAA,GAAKV,CAAI,GAAAW,EAAA,GAAKP,CAAC;IAAA,CAC7C;MACHJ,CAAA,GAAIgD,GAAM,GAAAiB,EAAA;MACV7D,CAAA,GAAI6C,GAAM,GAAAgB,EAAA;MACV,MAAMW,EAAA,GAAK5E,CAAI,GAAAA,CAAA;MACf,MAAM6E,EAAA,GAAKzE,CAAI,GAAAA,CAAA;MACf,MAAM0E,EAAK,GAAAvD,IAAA,CAAKI,KAAM,CAAAhB,EAAA,EAAID,EAAE;MAE5BR,CAAA,GAAI2E,EAAK,GAAAb,EAAA,GAAKA,EAAK,GAAAY,EAAA,GAAKpC,EAAA,GAAKoC,EAAK,GAAAC,EAAA;MAC5B,MAAAE,EAAA,GAAK,KAAKF,EAAK,GAAAb,EAAA;MACrB,MAAMgB,EAAA,GAAKH,EAAK,GAAAD,EAAA;MAEZtE,CAAA,GAAAyE,EAAA,GAAKA,EAAK,OAAIC,EAAK,GAAA9E,CAAA;MACvB,IAAII,CAAA,IAAK,CAAG;QACJ,IAAA2E,CAAA,GAAI1D,IAAK,CAAAkB,IAAA,CAAKnC,CAAC;QAEnB,IAAIyE,EAAK,MAAGE,CAAA,GAAI,CAACA,CAAA;QACbA,CAAA,KAAEF,EAAA,GAAKE,CAAK;QAChB,MAAMC,EAAA,GAAKD,CAAI,GAAAD,EAAA;QACf,MAAMG,EAAA,GAAKjF,CAAI,GAAA+E,CAAA;QACT,MAAAG,CAAA,GAAI7D,IAAA,CAAKC,GAAI,CAAA0D,EAAE,IAAI3D,IAAK,CAAAC,GAAA,CAAI2D,EAAE,IAAID,EAAK,GAAAC,EAAA;QAEzC,IAAAC,CAAA,GAAIA,CAAA,IAAK5C,EAAI;UACbT,CAAA,GAAIR,IAAK,CAAAkB,IAAA,CAAKD,EAAK,GAAA4C,CAAA,GAAIA,CAAC,CAAI,GAAAvC,OAAA;UAC5BqB,EAAA,GAAKY,EAAK,GAAAvD,IAAA,CAAKI,KAAM,CAAAI,CAAA,EAAGqD,CAAC;UACzBjB,EAAA,GAAK5C,IAAA,CAAKI,KAAM,CAAAI,CAAA,GAAIkB,GAAM,GAAAmC,CAAA,GAAIpB,EAAA,IAAMhB,GAAG;UAEjC,MAAAuB,KAAA;QAAA;MACV;MAEJ,IAAIc,QAAA,GAAWzD,SAAU,CAAA6C,EAAA;MACzB,IAAIa,IAAA,GAAOtB,EAAK,GAAAhE,CAAA;MAChB,IAAIuF,OAAA,GAAUD,IAAO,GAAAA,IAAA;MACrB,IAAIE,IAAO;MACX,IAAIC,QAAW;MACf,IAAIC,IAAA,GAAO1B,EAAK,GAAAhE,CAAA;MAChB,IAAI2F,OAAA,GAAUD,IAAO,GAAAA,IAAA;MACrB,IAAIE,IAAO;MAEN1F,CAAA,IAACF,CAAI,GAAAgE,EAAA,IAAOY,EAAK,GAAAC,EAAA;MAClB,IAAA3E,CAAA,IAAK,CAAM,KAAAA,CAAA,IAAK,CAAG;QACfA,CAAA,GAAAqB,IAAA,CAAKmD,IAAA,CAAKxE,CAAC;QACf4B,CAAA,GAAI9B,CAAI,GAAAuB,IAAA,CAAKiD,GAAI,CAAAtE,CAAC,CAAI,GAAA8D,EAAA;QAClBjC,CAAA,GAAA3B,CAAA,GAAImB,IAAK,CAAAoD,GAAA,CAAIzE,CAAC;QACdI,CAAA,GAAAwB,CAAA,GAAIA,CAAA,GAAIC,CAAI,GAAAA,CAAA;QAChB,IAAIzB,CAAA,GAAIiF,OAAS;UACFF,QAAA,GAAAnF,CAAA;UACDqF,OAAA,GAAAjF,CAAA;UACHgF,IAAA,GAAAxD,CAAA;UACA0D,IAAA,GAAAzD,CAAA;QAAA;QAEX,IAAIzB,CAAA,GAAIqF,OAAS;UACFF,QAAA,GAAAvF,CAAA;UACDyF,OAAA,GAAArF,CAAA;UACHoF,IAAA,GAAA5D,CAAA;UACA8D,IAAA,GAAA7D,CAAA;QAAA;MACX;MAEA,IAAAS,EAAA,KAAO+C,OAAU,GAAAI,OAAA,IAAW,GAAK;QACjCzB,EAAA,GAAKY,EAAK,GAAAvD,IAAA,CAAKI,KAAM,CAAA6D,IAAA,GAAO3C,OAAA,EAASyC,IAAI;QACzCnB,EAAA,GAAKkB,QAAW,GAAAxC,OAAA;MAAA,CACb;QACHqB,EAAA,GAAKY,EAAK,GAAAvD,IAAA,CAAKI,KAAM,CAAAiE,IAAA,GAAO/C,OAAA,EAAS6C,IAAI;QACzCvB,EAAA,GAAKsB,QAAW,GAAA5C,OAAA;MAAA;IACpB;IAEJ,MAAMgD,EAAK,GAAAtE,IAAA,CAAKI,KAAM,CAAA6B,EAAA,EAAID,EAAE,CAAI,GAAAD,EAAA;IAChC,IAAIwC,QAAA,GAAWjG,MAAO,CAAAY,SAAA;IAEtByD,EAAA,IAAMA,EAAK,GAAA2B,EAAA,IAAMjE,SAAU,CAAAC,MAAA,GAASuB,GAAM,GAAA0C,QAAA;IAC1C,IAAI5B,EAAK,QAAWA,EAAA,iBACXA,EAAK,SAEJA,EAAA;IACHrE,MAAA,CAAA6C,wBAAA,CAAyBI,EAAA,EAAIC,EAAI,EAAA+C,QAAA,GAAW5B,EAAA,GAAKvE,KAAO,EAAAwC,EAAA,EAAIC,EAAI,KAAG,CAAC;IAC3E0D,QAAA,GAAWlD,KAAM,CAAAnC,SAAA;IACjB0D,EAAA,KAAOA,EAAA,GAAK0B,EAAM,IAAAjE,SAAA,CAAUC,MAAA,GAASe,KAAM,CAAApC,OAAA,IAAW8C,EAAA,GAAKD,GAAM,GAAAyC,QAAA;IACjE,IAAI3B,EAAK,QAAWA,EAAA,iBACXA,EAAK,SAEJA,EAAA;IACVvB,KAAA,CAAMF,wBAAyB,CAAAa,EAAA,EAAIC,EAAI,EAAAsC,QAAA,GAAW3B,EAAK,GAAAxE,KAAA,EAAOiD,KAAM,CAAAV,OAAA,EAASU,KAAM,CAAAP,OAAA,EAASO,KAAM,CAAApC,OAAA,EAASoC,KAAA,CAAMD,OAAO;EAAA;AAEhI","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}