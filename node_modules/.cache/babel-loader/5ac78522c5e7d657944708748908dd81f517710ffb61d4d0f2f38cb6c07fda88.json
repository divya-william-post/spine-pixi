{"ast":null,"code":"import { Spine } from '@pixi/spine-pixi';\nimport { Container } from 'pixi.js';\n\n// Define the Spine animation map for the character.\n// name: animation track key.\n// loop: do the animation once or infinitely.\nconst animationMap = {\n  idle: {\n    name: 'idle',\n    loop: true\n  },\n  walk: {\n    name: 'walk',\n    loop: true\n  },\n  run: {\n    name: 'run',\n    loop: true\n  },\n  jump: {\n    name: 'jump',\n    timeScale: 1.5\n  },\n  hover: {\n    name: 'hoverboard',\n    loop: true\n  },\n  spawn: {\n    name: 'portal'\n  },\n  shoot: {\n    name: 'shoot',\n    loop: true\n  }\n};\n\n// Class for handling the character Spine and its animations.\nexport class SpineBoy {\n  constructor() {\n    // The character's state.\n    this.state = {\n      walk: false,\n      run: false,\n      hover: false,\n      jump: false\n    };\n    this.lastFrame = 0;\n    // Create the main view and a nested view for directional scaling.\n    this.view = new Container();\n    this.directionalView = new Container();\n\n    // Create the Spine instance using the preloaded Spine asset aliases.\n    this.spine = Spine.from({\n      skeleton: 'spineSkeleton',\n      atlas: 'spineAtlas'\n    });\n\n    // Add the Spine instance to the directional view.\n    this.directionalView.addChild(this.spine);\n\n    // Add the directional view to the main view.\n    this.view.addChild(this.directionalView);\n\n    // Set the default mix duration for all animations.\n    // This is the duration to blend from the previous animation to the next.\n    this.spine.state.data.defaultMix = 0.2;\n    this.skeleton = this.spine.skeleton;\n    this.shootAnimation = this.skeleton.data.findAnimation(\"shoot\");\n\n    // var getAngle = function (v) {\n    //     var a = Math.atan2(v.y, v.x) * 180 / Math.PI;\n    //     while (a < 0) {\n    //         a += 360;\n    //     }\n    //     while (a > 360) {\n    //         a -= 360;\n    //     }\n    //     return a;\n    // };\n\n    document.addEventListener('mousemove', event => {\n      this.playAnimation(animationMap.idle);\n      var now = Date.now() / 1000;\n      var delta = now - this.lastFrame;\n      this.lastFrame = now;\n      this.spine.state.update(delta);\n      this.spine.state.apply(this.skeleton);\n      this.skeleton.updateWorldTransform();\n      var arm = this.skeleton.findBone('crosshair');\n      console.log('x ' + event.x + 'y ' + event.y);\n      console.log(arm.x + ' ' + arm.y);\n      var position = {\n        x: event.x,\n        y: event.y\n      }; // The world position where you want the lightning bone.\n      arm.parent.worldToLocal(position); // Changes it to the parent's local position.\n      arm.x = position.x;\n      arm.y = position.y;\n      arm.parent.rotation = arm.parent.worldToLocalRotation(180 * Math.random());\n      this.skeleton.updateWorldTransform();\n    });\n  }\n\n  // Play the portal-in spawn animation.\n  spawn() {\n    this.spine.state.setAnimation(0, animationMap.spawn.name);\n  }\n\n  // Play the spine animation.\n  playAnimation() {\n    // // Skip if the animation is already playing.\n    // if (this.currentAnimationName === name) return;\n\n    // // Play the animation on main track instantly.\n    this.spine.state.setAnimation(0, 'aim', true);\n\n    // // Apply the animation's time scale (speed).\n    // trackEntry.timeScale = timeScale;\n  }\n  update() {\n    this.playAnimation(animationMap.idle);\n    // // Play the jump animation if not already playing.\n    // if (this.state.jump) this.playAnimation(animationMap.jump);\n\n    // // Skip the rest of the animation updates during the jump animation.\n    // if (this.isAnimationPlaying(animationMap.jump)) return;\n\n    // // Handle the character animation based on the latest state and in the priority order.\n    // if (this.state.hover) this.playAnimation(animationMap.hover);\n    // else if (this.state.run) this.playAnimation(animationMap.run);\n    // else if (this.state.walk) this.playAnimation(animationMap.walk);\n    // else this.playAnimation(animationMap.idle);\n  }\n  isSpawning() {\n    return this.isAnimationPlaying(animationMap.spawn);\n  }\n  isAnimationPlaying({\n    name\n  }) {\n    // Check if the current animation on main track equals to the queried.\n    // Also check if the animation is still ongoing.\n    return this.currentAnimationName === name && !this.spine.state.getCurrent(0).isComplete();\n  }\n\n  // Return the name of the current animation on main track.\n  get currentAnimationName() {\n    return this.spine.state.getCurrent(0)?.animation.name;\n  }\n\n  // Return character's facing direction.\n  get direction() {\n    return this.directionalView.scale.x > 0 ? 1 : -1;\n  }\n\n  // Set character's facing direction.\n  set direction(value) {\n    this.directionalView.scale.x = value;\n  }\n}","map":{"version":3,"names":["Spine","Container","animationMap","idle","name","loop","walk","run","jump","timeScale","hover","spawn","shoot","SpineBoy","constructor","state","lastFrame","view","directionalView","spine","from","skeleton","atlas","addChild","data","defaultMix","shootAnimation","findAnimation","document","addEventListener","event","playAnimation","now","Date","delta","update","apply","updateWorldTransform","arm","findBone","console","log","x","y","position","parent","worldToLocal","rotation","worldToLocalRotation","Math","random","setAnimation","isSpawning","isAnimationPlaying","currentAnimationName","getCurrent","isComplete","animation","direction","scale","value"],"sources":["/Users/divya/Documents/vue-2024-spine/vue-20240spine/src/components/SpineBoy.js"],"sourcesContent":["import { Spine } from '@pixi/spine-pixi';\nimport { Container } from 'pixi.js';\n\n// Define the Spine animation map for the character.\n// name: animation track key.\n// loop: do the animation once or infinitely.\nconst animationMap = {\n    idle: {\n        name: 'idle',\n        loop: true,\n    },\n    walk: {\n        name: 'walk',\n        loop: true,\n    },\n    run: {\n        name: 'run',\n        loop: true,\n    },\n    jump: {\n        name: 'jump',\n        timeScale: 1.5,\n    },\n    hover: {\n        name: 'hoverboard',\n        loop: true,\n    },\n    spawn: {\n        name: 'portal',\n    },\n    shoot: {\n        name: 'shoot',\n        loop: true,\n    }\n};\n\n// Class for handling the character Spine and its animations.\nexport class SpineBoy\n{\n    constructor()\n    {\n        // The character's state.\n        this.state = {\n            walk: false,\n            run: false,\n            hover: false,\n            jump: false,\n        };\n        this.lastFrame = 0;\n        // Create the main view and a nested view for directional scaling.\n        this.view = new Container();\n        this.directionalView = new Container();\n\n        // Create the Spine instance using the preloaded Spine asset aliases.\n        this.spine = Spine.from({\n            skeleton: 'spineSkeleton',\n            atlas: 'spineAtlas',\n        });\n\n        // Add the Spine instance to the directional view.\n        this.directionalView.addChild(this.spine);\n\n        // Add the directional view to the main view.\n        this.view.addChild(this.directionalView);\n\n        // Set the default mix duration for all animations.\n        // This is the duration to blend from the previous animation to the next.\n        this.spine.state.data.defaultMix = 0.2;\n\n        this.skeleton = this.spine.skeleton;\n                \n        this.shootAnimation = this.skeleton.data.findAnimation(\"shoot\");\n        \n        // var getAngle = function (v) {\n        //     var a = Math.atan2(v.y, v.x) * 180 / Math.PI;\n        //     while (a < 0) {\n        //         a += 360;\n        //     }\n        //     while (a > 360) {\n        //         a -= 360;\n        //     }\n        //     return a;\n        // };\n\n        document.addEventListener('mousemove', (event)=>{\n            this.playAnimation(animationMap.idle);\n            var now = Date.now() / 1000;\n            var delta = now - this.lastFrame;\n            this.lastFrame = now;\n    \n            this.spine.state.update(delta);\n            this.spine.state.apply(this.skeleton);\n            this.skeleton.updateWorldTransform();\n            var arm = this.skeleton.findBone('crosshair');\n            console.log('x '+event.x +'y ' +event.y)\n            console.log(arm.x +' ' +arm.y)\n            var position = {x: event.x, y: event.y} // The world position where you want the lightning bone.\n            arm.parent.worldToLocal(position) // Changes it to the parent's local position.\n            arm.x = position.x\n            arm.y = position.y\n            arm.parent.rotation = arm.parent.worldToLocalRotation(180 * Math.random());\n            this.skeleton.updateWorldTransform();\n        })\n\n    }\n\n    // Play the portal-in spawn animation.\n    spawn()\n    {\n        this.spine.state.setAnimation(0, animationMap.spawn.name);\n    }\n\n    // Play the spine animation.\n    playAnimation()\n    {\n        // // Skip if the animation is already playing.\n        // if (this.currentAnimationName === name) return;\n\n        // // Play the animation on main track instantly.\n        this.spine.state.setAnimation(0, 'aim', true);\n\n        // // Apply the animation's time scale (speed).\n        // trackEntry.timeScale = timeScale;\n    }\n\n    update()\n    {\n        this.playAnimation(animationMap.idle)\n        // // Play the jump animation if not already playing.\n        // if (this.state.jump) this.playAnimation(animationMap.jump);\n\n        // // Skip the rest of the animation updates during the jump animation.\n        // if (this.isAnimationPlaying(animationMap.jump)) return;\n\n        // // Handle the character animation based on the latest state and in the priority order.\n        // if (this.state.hover) this.playAnimation(animationMap.hover);\n        // else if (this.state.run) this.playAnimation(animationMap.run);\n        // else if (this.state.walk) this.playAnimation(animationMap.walk);\n        // else this.playAnimation(animationMap.idle);\n    }\n\n    isSpawning()\n    {\n        return this.isAnimationPlaying(animationMap.spawn);\n    }\n\n    isAnimationPlaying({ name })\n    {\n        // Check if the current animation on main track equals to the queried.\n        // Also check if the animation is still ongoing.\n        return this.currentAnimationName === name && !this.spine.state.getCurrent(0).isComplete();\n    }\n\n    // Return the name of the current animation on main track.\n    get currentAnimationName()\n    {\n        return this.spine.state.getCurrent(0)?.animation.name;\n    }\n\n    // Return character's facing direction.\n    get direction()\n    {\n        return this.directionalView.scale.x > 0 ? 1 : -1;\n    }\n\n    // Set character's facing direction.\n    set direction(value)\n    {\n        this.directionalView.scale.x = value;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}