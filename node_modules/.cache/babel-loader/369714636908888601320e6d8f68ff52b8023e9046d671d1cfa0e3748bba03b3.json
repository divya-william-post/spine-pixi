{"ast":null,"code":"import _defineProperty from \"/Users/divya/Documents/vue-2024-spine/vue-20240spine/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.push.js\";\n/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nimport { MeshAttachment } from \"./attachments/MeshAttachment.js\";\nimport { PathAttachment } from \"./attachments/PathAttachment.js\";\nimport { RegionAttachment } from \"./attachments/RegionAttachment.js\";\nimport { Bone } from \"./Bone.js\";\nimport { IkConstraint } from \"./IkConstraint.js\";\nimport { PathConstraint } from \"./PathConstraint.js\";\nimport { Slot } from \"./Slot.js\";\nimport { TransformConstraint } from \"./TransformConstraint.js\";\nimport { Color, Utils, MathUtils, Vector2 } from \"./Utils.js\";\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide. */\nexport class Skeleton {\n  get scaleY() {\n    return Skeleton.yDown ? -this._scaleY : this._scaleY;\n  }\n  set scaleY(scaleY) {\n    this._scaleY = scaleY;\n  }\n  /** Sets the skeleton X position, which is added to the root bone worldX position. */\n\n  constructor(data) {\n    /** The skeleton's setup pose data. */\n    _defineProperty(this, \"data\", void 0);\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    _defineProperty(this, \"bones\", void 0);\n    /** The skeleton's slots. */\n    _defineProperty(this, \"slots\", void 0);\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n    _defineProperty(this, \"drawOrder\", void 0);\n    /** The skeleton's IK constraints. */\n    _defineProperty(this, \"ikConstraints\", void 0);\n    /** The skeleton's transform constraints. */\n    _defineProperty(this, \"transformConstraints\", void 0);\n    /** The skeleton's path constraints. */\n    _defineProperty(this, \"pathConstraints\", void 0);\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    _defineProperty(this, \"_updateCache\", new Array());\n    /** The skeleton's current skin. May be null. */\n    _defineProperty(this, \"skin\", null);\n    /** The color to tint all the skeleton's attachments. */\n    _defineProperty(this, \"color\", void 0);\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n      * inheritance. */\n    _defineProperty(this, \"scaleX\", 1);\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n      * inheritance. */\n    _defineProperty(this, \"_scaleY\", 1);\n    _defineProperty(this, \"x\", 0);\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    _defineProperty(this, \"y\", 0);\n    if (!data) throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      let boneData = data.bones[i];\n      let bone;\n      if (!boneData.parent) bone = new Bone(boneData, this, null);else {\n        let parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n    this.slots = new Array();\n    this.drawOrder = new Array();\n    for (let i = 0; i < data.slots.length; i++) {\n      let slotData = data.slots[i];\n      let bone = this.bones[slotData.boneData.index];\n      let slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n    this.ikConstraints = new Array();\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      let ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n    this.transformConstraints = new Array();\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      let transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n    this.pathConstraints = new Array();\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      let pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n   * constraints, or weighted path attachments are added or removed. */\n  updateCache() {\n    let updateCache = this._updateCache;\n    updateCache.length = 0;\n    let bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      bone.sorted = bone.data.skinRequired;\n      bone.active = !bone.sorted;\n    }\n    if (this.skin) {\n      let skinBones = this.skin.bones;\n      for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n        let bone = this.bones[skinBones[i].index];\n        do {\n          bone.sorted = false;\n          bone.active = true;\n          bone = bone.parent;\n        } while (bone);\n      }\n    }\n    // IK first, lowest hierarchy depth first.\n    let ikConstraints = this.ikConstraints;\n    let transformConstraints = this.transformConstraints;\n    let pathConstraints = this.pathConstraints;\n    let ikCount = ikConstraints.length,\n      transformCount = transformConstraints.length,\n      pathCount = pathConstraints.length;\n    let constraintCount = ikCount + transformCount + pathCount;\n    outer: for (let i = 0; i < constraintCount; i++) {\n      for (let ii = 0; ii < ikCount; ii++) {\n        let constraint = ikConstraints[ii];\n        if (constraint.data.order == i) {\n          this.sortIkConstraint(constraint);\n          continue outer;\n        }\n      }\n      for (let ii = 0; ii < transformCount; ii++) {\n        let constraint = transformConstraints[ii];\n        if (constraint.data.order == i) {\n          this.sortTransformConstraint(constraint);\n          continue outer;\n        }\n      }\n      for (let ii = 0; ii < pathCount; ii++) {\n        let constraint = pathConstraints[ii];\n        if (constraint.data.order == i) {\n          this.sortPathConstraint(constraint);\n          continue outer;\n        }\n      }\n    }\n    for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n  }\n  sortIkConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    let target = constraint.target;\n    this.sortBone(target);\n    let constrained = constraint.bones;\n    let parent = constrained[0];\n    this.sortBone(parent);\n    if (constrained.length == 1) {\n      this._updateCache.push(constraint);\n      this.sortReset(parent.children);\n    } else {\n      let child = constrained[constrained.length - 1];\n      this.sortBone(child);\n      this._updateCache.push(constraint);\n      this.sortReset(parent.children);\n      child.sorted = true;\n    }\n  }\n  sortPathConstraint(constraint) {\n    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    let slot = constraint.target;\n    let slotIndex = slot.data.index;\n    let slotBone = slot.bone;\n    if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n    for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n    let attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    let constrained = constraint.bones;\n    let boneCount = constrained.length;\n    for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n  }\n  sortTransformConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    this.sortBone(constraint.target);\n    let constrained = constraint.bones;\n    let boneCount = constrained.length;\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        let child = constrained[i];\n        this.sortBone(child.parent);\n        this.sortBone(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n  }\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    let attachments = skin.attachments[slotIndex];\n    if (!attachments) return;\n    for (let key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment)) return;\n    let pathBones = attachment.bones;\n    if (!pathBones) this.sortBone(slotBone);else {\n      let bones = this.bones;\n      for (let i = 0, n = pathBones.length; i < n;) {\n        let nn = pathBones[i++];\n        nn += i;\n        while (i < nn) this.sortBone(bones[pathBones[i++]]);\n      }\n    }\n  }\n  sortBone(bone) {\n    if (!bone) return;\n    if (bone.sorted) return;\n    let parent = bone.parent;\n    if (parent) this.sortBone(parent);\n    bone.sorted = true;\n    this._updateCache.push(bone);\n  }\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      if (!bone.active) continue;\n      if (bone.sorted) this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies all constraints.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n  updateWorldTransform() {\n    let bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n    }\n    let updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n  }\n  updateWorldTransformWith(parent) {\n    // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n    let rootBone = this.getRootBone();\n    if (!rootBone) throw new Error(\"Root bone must not be null.\");\n    let pa = parent.a,\n      pb = parent.b,\n      pc = parent.c,\n      pd = parent.d;\n    rootBone.worldX = pa * this.x + pb * this.y + parent.worldX;\n    rootBone.worldY = pc * this.x + pd * this.y + parent.worldY;\n    let rotationY = rootBone.rotation + 90 + rootBone.shearY;\n    let la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    let lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n    let lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    let ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n    rootBone.a = (pa * la + pb * lc) * this.scaleX;\n    rootBone.b = (pa * lb + pb * ld) * this.scaleX;\n    rootBone.c = (pc * la + pd * lc) * this.scaleY;\n    rootBone.d = (pc * lb + pd * ld) * this.scaleY;\n    // Update everything except root bone.\n    let updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++) {\n      let updatable = updateCache[i];\n      if (updatable != rootBone) updatable.update();\n    }\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n  setBonesToSetupPose() {\n    let bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n    let ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      let constraint = ikConstraints[i];\n      constraint.mix = constraint.data.mix;\n      constraint.softness = constraint.data.softness;\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.compress = constraint.data.compress;\n      constraint.stretch = constraint.data.stretch;\n    }\n    let transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      let constraint = transformConstraints[i];\n      let data = constraint.data;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n      constraint.mixScaleX = data.mixScaleX;\n      constraint.mixScaleY = data.mixScaleY;\n      constraint.mixShearY = data.mixShearY;\n    }\n    let pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      let constraint = pathConstraints[i];\n      let data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n    }\n  }\n  /** Sets the slots and draw order to their setup pose values. */\n  setSlotsToSetupPose() {\n    let slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n    for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n  }\n  /** @returns May return null. */\n  getRootBone() {\n    if (this.bones.length == 0) return null;\n    return this.bones[0];\n  }\n  /** @returns May be null. */\n  findBone(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    let bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      let bone = bones[i];\n      if (bone.data.name == boneName) return bone;\n    }\n    return null;\n  }\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n   * repeatedly.\n   * @returns May be null. */\n  findSlot(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      let slot = slots[i];\n      if (slot.data.name == slotName) return slot;\n    }\n    return null;\n  }\n  /** Sets a skin by name.\n   *\n   * See {@link #setSkin()}. */\n  setSkinByName(skinName) {\n    let skin = this.data.findSkin(skinName);\n    if (!skin) throw new Error(\"Skin not found: \" + skinName);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n   * skin is changed, {@link #updateCache()} is called.\n   *\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   *\n   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n   * @param newSkin May be null. */\n  setSkin(newSkin) {\n    if (newSkin == this.skin) return;\n    if (newSkin) {\n      if (this.skin) newSkin.attachAll(this, this.skin);else {\n        let slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n          let slot = slots[i];\n          let name = slot.data.attachmentName;\n          if (name) {\n            let attachment = newSkin.getAttachment(i, name);\n            if (attachment) slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n    this.skin = newSkin;\n    this.updateCache();\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n   * name.\n   *\n   * See {@link #getAttachment()}.\n   * @returns May be null. */\n  getAttachmentByName(slotName, attachmentName) {\n    let slot = this.data.findSlot(slotName);\n    if (!slot) throw new Error(`Can't find slot with name ${slotName}`);\n    return this.getAttachment(slot.index, attachmentName);\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n   *\n   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n   * @returns May be null. */\n  getAttachment(slotIndex, attachmentName) {\n    if (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\n    if (this.skin) {\n      let attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment) return attachment;\n    }\n    if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n   * @param attachmentName May be null to clear the slot's attachment. */\n  setAttachment(slotName, attachmentName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    let slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      let slot = slots[i];\n      if (slot.data.name == slotName) {\n        let attachment = null;\n        if (attachmentName) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (!attachment) throw new Error(\"Attachment not found: \" + attachmentName + \", for slot: \" + slotName);\n        }\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n    throw new Error(\"Slot not found: \" + slotName);\n  }\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n  findIkConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      let ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName) return ikConstraint;\n    }\n    return null;\n  }\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n   * this method than to call it repeatedly.\n   * @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      let constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName) return constraint;\n    }\n    return null;\n  }\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n  findPathConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    let pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      let constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName) return constraint;\n    }\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n  getBoundsRect() {\n    let offset = new Vector2();\n    let size = new Vector2();\n    this.getBounds(offset, size);\n    return {\n      x: offset.x,\n      y: offset.y,\n      width: size.x,\n      height: size.y\n    };\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size An output value, the width and height of the AABB.\n   * @param temp Working memory to temporarily store attachments' computed world vertices. */\n  getBounds(offset, size, temp = new Array(2)) {\n    if (!offset) throw new Error(\"offset cannot be null.\");\n    if (!size) throw new Error(\"size cannot be null.\");\n    let drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY,\n      minY = Number.POSITIVE_INFINITY,\n      maxX = Number.NEGATIVE_INFINITY,\n      maxY = Number.NEGATIVE_INFINITY;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      let slot = drawOrder[i];\n      if (!slot.bone.active) continue;\n      let verticesLength = 0;\n      let vertices = null;\n      let attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        let mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n      if (vertices) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          let x = vertices[ii],\n            y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n}\n_defineProperty(Skeleton, \"yDown\", false);","map":{"version":3,"names":["MeshAttachment","PathAttachment","RegionAttachment","Bone","IkConstraint","PathConstraint","Slot","TransformConstraint","Color","Utils","MathUtils","Vector2","Skeleton","scaleY","yDown","_scaleY","constructor","data","_defineProperty","Array","Error","bones","i","length","boneData","bone","parent","index","children","push","slots","drawOrder","slotData","slot","ikConstraints","ikConstraintData","transformConstraints","transformConstraintData","pathConstraints","pathConstraintData","color","updateCache","_updateCache","n","sorted","skinRequired","active","skin","skinBones","ikCount","transformCount","pathCount","constraintCount","outer","ii","constraint","order","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","target","isActive","contains","constraints","constrained","sortReset","child","slotIndex","slotBone","sortPathConstraintAttachment","defaultSkin","skins","attachment","getAttachment","sortPathConstraintAttachmentWith","boneCount","local","attachments","key","pathBones","nn","updateWorldTransform","ax","x","ay","y","arotation","rotation","ascaleX","scaleX","ascaleY","ashearX","shearX","ashearY","shearY","update","updateWorldTransformWith","rootBone","getRootBone","pa","a","pb","b","pc","c","pd","d","worldX","worldY","rotationY","la","cosDeg","lb","lc","sinDeg","ld","updatable","setToSetupPose","setBonesToSetupPose","setSlotsToSetupPose","mix","softness","bendDirection","compress","stretch","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","position","spacing","arrayCopy","findBone","boneName","name","findSlot","slotName","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","attachmentName","setAttachment","getAttachmentByName","findIkConstraint","constraintName","ikConstraint","findTransformConstraint","findPathConstraint","getBoundsRect","offset","size","getBounds","width","height","temp","minX","Number","POSITIVE_INFINITY","minY","maxX","NEGATIVE_INFINITY","maxY","verticesLength","vertices","setArraySize","computeWorldVertices","mesh","worldVerticesLength","Math","min","max","set"],"sources":["../src/Skeleton.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}