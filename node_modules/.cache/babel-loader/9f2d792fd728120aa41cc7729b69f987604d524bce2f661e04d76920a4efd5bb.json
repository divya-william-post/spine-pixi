{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { VertexAttachment } from './Attachment.mjs';\nimport { AttachmentType, Color, Utils } from '@pixi-spine/base';\nclass MeshAttachment extends VertexAttachment {\n  constructor(name, path) {\n    super(name);\n    this.type = AttachmentType.Mesh;\n    this.region = null;\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\n    this.triangles = [];\n    /** The color to tint the mesh. */\n    this.color = new Color(1, 1, 1, 1);\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\n    this.width = 0;\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\n    this.height = 0;\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n    this.hullLength = 0;\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n     * nonessential data was exported. Triangulation is not performed at runtime. */\n    this.edges = [];\n    this.parentMesh = null;\n    this.sequence = null;\n    this.tempColor = new Color(0, 0, 0, 0);\n    this.path = path;\n  }\n  /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n   * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n   * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n  getParentMesh() {\n    return this.parentMesh;\n  }\n  /** @param parentMesh May be null. */\n  setParentMesh(parentMesh) {\n    this.parentMesh = parentMesh;\n    if (parentMesh) {\n      this.bones = parentMesh.bones;\n      this.vertices = parentMesh.vertices;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n      this.regionUVs = parentMesh.regionUVs;\n      this.triangles = parentMesh.triangles;\n      this.hullLength = parentMesh.hullLength;\n      this.worldVerticesLength = parentMesh.worldVerticesLength;\n    }\n  }\n  copy() {\n    if (this.parentMesh) return this.newLinkedMesh();\n    const copy = new MeshAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.color.setFromColor(this.color);\n    this.copyTo(copy);\n    copy.regionUVs = new Float32Array(this.regionUVs.length);\n    Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n    copy.triangles = new Array(this.triangles.length);\n    Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n    copy.hullLength = this.hullLength;\n    copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n    if (this.edges) {\n      copy.edges = new Array(this.edges.length);\n      Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n    }\n    copy.width = this.width;\n    copy.height = this.height;\n    return copy;\n  }\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    if (this.sequence != null) this.sequence.apply(slot, this);\n    super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n  }\n  /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n  newLinkedMesh() {\n    const copy = new MeshAttachment(this.name, this.path);\n    copy.region = this.region;\n    copy.color.setFromColor(this.color);\n    copy.timelineAttachment = this.timelineAttachment;\n    copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n    return copy;\n  }\n}\nexport { MeshAttachment };","map":{"version":3,"names":["MeshAttachment","VertexAttachment","constructor","name","path","type","AttachmentType","Mesh","region","triangles","color","Color","width","height","hullLength","edges","parentMesh","sequence","tempColor","getParentMesh","setParentMesh","bones","vertices","worldVerticesLength","regionUVs","copy","newLinkedMesh","setFromColor","copyTo","Float32Array","length","Utils","arrayCopy","Array","computeWorldVertices","slot","start","count","worldVertices","offset","stride","apply","timelineAttachment"],"sources":["../../../src/core/attachments/MeshAttachment.ts"],"sourcesContent":["import { Attachment, VertexAttachment } from './Attachment';\nimport { AttachmentType, Color, IMeshAttachment, IHasTextureRegion, NumberArrayLike, TextureRegion, Utils } from '@pixi-spine/base';\nimport type { Sequence } from './Sequence';\nimport type { Slot } from '../Slot';\n\n/**\n * @public\n */\nexport class MeshAttachment extends VertexAttachment implements IMeshAttachment, IHasTextureRegion {\n    type = AttachmentType.Mesh;\n\n    region: TextureRegion | null = null;\n\n    /** The name of the texture region for this attachment. */\n    path: string;\n\n    /** The UV pair for each vertex, normalized within the texture region. */\n    regionUVs: Float32Array;\n\n    /** Triplets of vertex indices which describe the mesh's triangulation. */\n    triangles: Array<number> = [];\n\n    /** The color to tint the mesh. */\n    color = new Color(1, 1, 1, 1);\n\n    /** The width of the mesh's image. Available only when nonessential data was exported. */\n    width = 0;\n\n    /** The height of the mesh's image. Available only when nonessential data was exported. */\n    height = 0;\n\n    /** The number of entries at the beginning of {@link #vertices} that make up the mesh hull. */\n    hullLength = 0;\n\n    /** Vertex index pairs describing edges for controling triangulation. Mesh triangles will never cross edges. Only available if\n     * nonessential data was exported. Triangulation is not performed at runtime. */\n    edges: Array<number> = [];\n\n    private parentMesh: MeshAttachment | null = null;\n\n    sequence: Sequence | null = null;\n\n    tempColor = new Color(0, 0, 0, 0);\n\n    constructor(name: string, path: string) {\n        super(name);\n        this.path = path;\n    }\n\n    /** The parent mesh if this is a linked mesh, else null. A linked mesh shares the {@link #bones}, {@link #vertices},\n     * {@link #regionUVs}, {@link #triangles}, {@link #hullLength}, {@link #edges}, {@link #width}, and {@link #height} with the\n     * parent mesh, but may have a different {@link #name} or {@link #path} (and therefore a different texture). */\n    getParentMesh() {\n        return this.parentMesh;\n    }\n\n    /** @param parentMesh May be null. */\n    setParentMesh(parentMesh: MeshAttachment) {\n        this.parentMesh = parentMesh;\n        if (parentMesh) {\n            this.bones = parentMesh.bones;\n            this.vertices = parentMesh.vertices;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n            this.regionUVs = parentMesh.regionUVs;\n            this.triangles = parentMesh.triangles;\n            this.hullLength = parentMesh.hullLength;\n            this.worldVerticesLength = parentMesh.worldVerticesLength;\n        }\n    }\n\n    copy(): Attachment {\n        if (this.parentMesh) return this.newLinkedMesh();\n\n        const copy = new MeshAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.color.setFromColor(this.color);\n\n        this.copyTo(copy);\n        copy.regionUVs = new Float32Array(this.regionUVs.length);\n        Utils.arrayCopy(this.regionUVs, 0, copy.regionUVs, 0, this.regionUVs.length);\n        copy.triangles = new Array<number>(this.triangles.length);\n        Utils.arrayCopy(this.triangles, 0, copy.triangles, 0, this.triangles.length);\n        copy.hullLength = this.hullLength;\n\n        copy.sequence = this.sequence != null ? this.sequence.copy() : null;\n\n        // Nonessential.\n        if (this.edges) {\n            copy.edges = new Array<number>(this.edges.length);\n            Utils.arrayCopy(this.edges, 0, copy.edges, 0, this.edges.length);\n        }\n        copy.width = this.width;\n        copy.height = this.height;\n\n        return copy;\n    }\n\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        if (this.sequence != null) this.sequence.apply(slot, this);\n        super.computeWorldVertices(slot, start, count, worldVertices, offset, stride);\n    }\n\n    /** Returns a new mesh with the {@link #parentMesh} set to this mesh's parent mesh, if any, else to this mesh. **/\n    newLinkedMesh(): MeshAttachment {\n        const copy = new MeshAttachment(this.name, this.path);\n\n        copy.region = this.region;\n        copy.color.setFromColor(this.color);\n        copy.timelineAttachment = this.timelineAttachment;\n        copy.setParentMesh(this.parentMesh ? this.parentMesh : this);\n        // if (copy.region != null) copy.updateRegion();\n\n        return copy;\n    }\n}\n"],"mappings":";;;;;;;;AAQO,MAAMA,cAAA,SAAuBC,gBAA+D;EAoC/FC,YAAYC,IAAA,EAAcC,IAAc;IACpC,MAAMD,IAAI;IApCd,KAAAE,IAAA,GAAOC,cAAe,CAAAC,IAAA;IAES,KAAAC,MAAA;IAS/B;IAAA,KAAAC,SAAA,GAA2B,EAAC;IAG5B;IAAA,KAAAC,KAAA,GAAQ,IAAIC,KAAA,CAAM,CAAG,KAAG,GAAG,CAAC;IAG5B;IAAQ,KAAAC,KAAA;IAGR;IAAS,KAAAC,MAAA;IAGT;IAAa,KAAAC,UAAA;IAIb;AAAA;IAAA,KAAAC,KAAA,GAAuB,EAAC;IAExB,KAAQC,UAAoC;IAEhB,KAAAC,QAAA;IAE5B,KAAAC,SAAA,GAAY,IAAIP,KAAA,CAAM,CAAG,KAAG,GAAG,CAAC;IAI5B,KAAKP,IAAO,GAAAA,IAAA;EAAA;EAChB;AAAA;AAAA;EAKAe,aAAgBA,CAAA;IACZ,OAAO,IAAK,CAAAH,UAAA;EAAA;EAChB;EAGAI,cAAcJ,UAA4B;IACtC,KAAKA,UAAa,GAAAA,UAAA;IAClB,IAAIA,UAAY;MACZ,KAAKK,KAAA,GAAQL,UAAW,CAAAK,KAAA;MACxB,KAAKC,QAAA,GAAWN,UAAW,CAAAM,QAAA;MAC3B,KAAKC,mBAAA,GAAsBP,UAAW,CAAAO,mBAAA;MACtC,KAAKC,SAAA,GAAYR,UAAW,CAAAQ,SAAA;MAC5B,KAAKf,SAAA,GAAYO,UAAW,CAAAP,SAAA;MAC5B,KAAKK,UAAA,GAAaE,UAAW,CAAAF,UAAA;MAC7B,KAAKS,mBAAA,GAAsBP,UAAW,CAAAO,mBAAA;IAAA;EAC1C;EAGJE,IAAmBA,CAAA;IACf,IAAI,IAAK,CAAAT,UAAA,EAAY,OAAO,KAAKU,aAAc;IAE/C,MAAMD,IAAA,GAAO,IAAIzB,cAAA,CAAe,IAAK,CAAAG,IAAA,EAAM,KAAKC,IAAI;IAEpDqB,IAAA,CAAKjB,MAAA,GAAS,IAAK,CAAAA,MAAA;IACdiB,IAAA,CAAAf,KAAA,CAAMiB,YAAa,MAAKjB,KAAK;IAElC,KAAKkB,MAAA,CAAOH,IAAI;IAChBA,IAAA,CAAKD,SAAY,OAAIK,YAAa,MAAKL,SAAA,CAAUM,MAAM;IACjDC,KAAA,CAAAC,SAAA,CAAU,KAAKR,SAAW,KAAGC,IAAA,CAAKD,SAAW,KAAG,IAAK,CAAAA,SAAA,CAAUM,MAAM;IAC3EL,IAAA,CAAKhB,SAAY,OAAIwB,KAAc,MAAKxB,SAAA,CAAUqB,MAAM;IAClDC,KAAA,CAAAC,SAAA,CAAU,KAAKvB,SAAW,KAAGgB,IAAA,CAAKhB,SAAW,KAAG,IAAK,CAAAA,SAAA,CAAUqB,MAAM;IAC3EL,IAAA,CAAKX,UAAA,GAAa,IAAK,CAAAA,UAAA;IAEvBW,IAAA,CAAKR,QAAA,GAAW,IAAK,CAAAA,QAAA,IAAY,OAAO,IAAK,CAAAA,QAAA,CAASQ,IAAA,EAAS;IAG/D,IAAI,KAAKV,KAAO;MACZU,IAAA,CAAKV,KAAQ,OAAIkB,KAAc,MAAKlB,KAAA,CAAMe,MAAM;MAC1CC,KAAA,CAAAC,SAAA,CAAU,KAAKjB,KAAO,KAAGU,IAAA,CAAKV,KAAO,KAAG,IAAK,CAAAA,KAAA,CAAMe,MAAM;IAAA;IAEnEL,IAAA,CAAKb,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAClBa,IAAA,CAAKZ,MAAA,GAAS,IAAK,CAAAA,MAAA;IAEZ,OAAAY,IAAA;EAAA;EAGXS,qBAAqBC,IAAY,EAAAC,KAAA,EAAeC,KAAe,EAAAC,aAAA,EAAgCC,MAAA,EAAgBC,MAAgB;IAC3H,IAAI,KAAKvB,QAAY,UAAW,KAAAA,QAAA,CAASwB,KAAM,CAAAN,IAAA,EAAM,IAAI;IACzD,MAAMD,oBAAA,CAAqBC,IAAM,EAAAC,KAAA,EAAOC,KAAO,EAAAC,aAAA,EAAeC,MAAA,EAAQC,MAAM;EAAA;EAChF;EAGAd,aAAgCA,CAAA;IAC5B,MAAMD,IAAA,GAAO,IAAIzB,cAAA,CAAe,IAAK,CAAAG,IAAA,EAAM,KAAKC,IAAI;IAEpDqB,IAAA,CAAKjB,MAAA,GAAS,IAAK,CAAAA,MAAA;IACdiB,IAAA,CAAAf,KAAA,CAAMiB,YAAa,MAAKjB,KAAK;IAClCe,IAAA,CAAKiB,kBAAA,GAAqB,IAAK,CAAAA,kBAAA;IAC/BjB,IAAA,CAAKL,aAAc,MAAKJ,UAAa,QAAKA,UAAA,GAAa,IAAI;IAGpD,OAAAS,IAAA;EAAA;AAEf","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}