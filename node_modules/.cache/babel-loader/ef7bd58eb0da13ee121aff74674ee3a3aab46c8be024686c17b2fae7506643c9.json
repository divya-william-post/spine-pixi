{"ast":null,"code":"import './attachments/Attachment.mjs';\nimport { BoundingBoxAttachment } from './attachments/BoundingBoxAttachment.mjs';\nimport { ClippingAttachment } from './attachments/ClippingAttachment.mjs';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { PointAttachment } from './attachments/PointAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\nclass AtlasAttachmentLoader {\n  constructor(atlas) {\n    this.atlas = atlas;\n  }\n  loadSequence(name, basePath, sequence) {\n    const regions = sequence.regions;\n    for (let i = 0, n = regions.length; i < n; i++) {\n      const path = sequence.getPath(basePath, i);\n      const region = this.atlas.findRegion(path);\n      if (region == null) throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);\n      regions[i] = region;\n      regions[i].renderObject = regions[i];\n    }\n  }\n  newRegionAttachment(skin, name, path, sequence) {\n    const attachment = new RegionAttachment(name, path);\n    if (sequence != null) {\n      this.loadSequence(name, path, sequence);\n    } else {\n      const region = this.atlas.findRegion(path);\n      if (!region) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n      region.renderObject = region;\n      attachment.region = region;\n    }\n    return attachment;\n  }\n  newMeshAttachment(skin, name, path, sequence) {\n    const attachment = new MeshAttachment(name, path);\n    if (sequence != null) {\n      this.loadSequence(name, path, sequence);\n    } else {\n      const region = this.atlas.findRegion(path);\n      if (!region) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n      region.renderObject = region;\n      attachment.region = region;\n    }\n    return attachment;\n  }\n  newBoundingBoxAttachment(skin, name) {\n    return new BoundingBoxAttachment(name);\n  }\n  newPathAttachment(skin, name) {\n    return new PathAttachment(name);\n  }\n  newPointAttachment(skin, name) {\n    return new PointAttachment(name);\n  }\n  newClippingAttachment(skin, name) {\n    return new ClippingAttachment(name);\n  }\n}\nexport { AtlasAttachmentLoader };","map":{"version":3,"names":["AtlasAttachmentLoader","constructor","atlas","loadSequence","name","basePath","sequence","regions","i","n","length","path","getPath","region","findRegion","Error","renderObject","newRegionAttachment","skin","attachment","RegionAttachment","newMeshAttachment","MeshAttachment","newBoundingBoxAttachment","BoundingBoxAttachment","newPathAttachment","PathAttachment","newPointAttachment","PointAttachment","newClippingAttachment","ClippingAttachment"],"sources":["../../src/core/AtlasAttachmentLoader.ts"],"sourcesContent":["import { AttachmentLoader, RegionAttachment, MeshAttachment, BoundingBoxAttachment, PathAttachment, PointAttachment, ClippingAttachment, Sequence } from './attachments';\nimport type { TextureAtlas } from '@pixi-spine/base';\nimport type { Skin } from './Skin';\n\n/**\n * @public\n */\nexport class AtlasAttachmentLoader implements AttachmentLoader {\n    atlas: TextureAtlas;\n\n    constructor(atlas: TextureAtlas) {\n        this.atlas = atlas;\n    }\n\n    loadSequence(name: string, basePath: string, sequence: Sequence) {\n        const regions = sequence.regions;\n\n        for (let i = 0, n = regions.length; i < n; i++) {\n            const path = sequence.getPath(basePath, i);\n            const region = this.atlas.findRegion(path);\n\n            if (region == null) throw new Error(`Region not found in atlas: ${path} (sequence: ${name})`);\n            regions[i] = region;\n            regions[i].renderObject = regions[i];\n        }\n    }\n\n    newRegionAttachment(skin: Skin, name: string, path: string, sequence: Sequence): RegionAttachment {\n        const attachment = new RegionAttachment(name, path);\n\n        if (sequence != null) {\n            this.loadSequence(name, path, sequence);\n        } else {\n            const region = this.atlas.findRegion(path);\n\n            if (!region) throw new Error(`Region not found in atlas: ${path} (region attachment: ${name})`);\n            region.renderObject = region;\n            attachment.region = region;\n        }\n\n        return attachment;\n    }\n\n    newMeshAttachment(skin: Skin, name: string, path: string, sequence: Sequence): MeshAttachment {\n        const attachment = new MeshAttachment(name, path);\n\n        if (sequence != null) {\n            this.loadSequence(name, path, sequence);\n        } else {\n            const region = this.atlas.findRegion(path);\n\n            if (!region) throw new Error(`Region not found in atlas: ${path} (mesh attachment: ${name})`);\n            region.renderObject = region;\n            attachment.region = region;\n        }\n\n        return attachment;\n    }\n\n    newBoundingBoxAttachment(skin: Skin, name: string): BoundingBoxAttachment {\n        return new BoundingBoxAttachment(name);\n    }\n\n    newPathAttachment(skin: Skin, name: string): PathAttachment {\n        return new PathAttachment(name);\n    }\n\n    newPointAttachment(skin: Skin, name: string): PointAttachment {\n        return new PointAttachment(name);\n    }\n\n    newClippingAttachment(skin: Skin, name: string): ClippingAttachment {\n        return new ClippingAttachment(name);\n    }\n}\n"],"mappings":";;;;;;;;AAOO,MAAMA,qBAAkD;EAG3DC,YAAYC,KAAqB;IAC7B,KAAKA,KAAQ,GAAAA,KAAA;EAAA;EAGjBC,aAAaC,IAAc,EAAAC,QAAA,EAAkBC,QAAoB;IAC7D,MAAMC,OAAA,GAAUD,QAAS,CAAAC,OAAA;IAEzB,SAASC,CAAA,GAAI,CAAG,EAAAC,CAAA,GAAIF,OAAA,CAAQG,MAAQ,EAAAF,CAAA,GAAIC,CAAA,EAAGD,CAAK;MAC5C,MAAMG,IAAO,GAAAL,QAAA,CAASM,OAAQ,CAAAP,QAAA,EAAUG,CAAC;MACzC,MAAMK,MAAS,QAAKX,KAAM,CAAAY,UAAA,CAAWH,IAAI;MAEzC,IAAIE,MAAU,UAAM,MAAM,IAAIE,KAAA,CAAM,8BAA8BJ,IAAA,eAAmBP,IAAO;MAC5FG,OAAA,CAAQC,CAAC,CAAI,GAAAK,MAAA;MACbN,OAAA,CAAQC,CAAC,EAAEQ,YAAe,GAAAT,OAAA,CAAQC,CAAC;IAAA;EACvC;EAGJS,mBAAoBA,CAAAC,IAAA,EAAYd,IAAc,EAAAO,IAAA,EAAcL,QAAsC;IAC9F,MAAMa,UAAa,OAAIC,gBAAiB,CAAAhB,IAAA,EAAMO,IAAI;IAElD,IAAIL,QAAA,IAAY,IAAM;MACb,KAAAH,YAAA,CAAaC,IAAM,EAAAO,IAAA,EAAML,QAAQ;IAAA,CACnC;MACH,MAAMO,MAAS,QAAKX,KAAM,CAAAY,UAAA,CAAWH,IAAI;MAEzC,IAAI,CAACE,MAAA,EAAQ,MAAM,IAAIE,KAAA,CAAM,8BAA8BJ,IAAA,wBAA4BP,IAAO;MAC9FS,MAAA,CAAOG,YAAe,GAAAH,MAAA;MACtBM,UAAA,CAAWN,MAAS,GAAAA,MAAA;IAAA;IAGjB,OAAAM,UAAA;EAAA;EAGXE,iBAAkBA,CAAAH,IAAA,EAAYd,IAAc,EAAAO,IAAA,EAAcL,QAAoC;IAC1F,MAAMa,UAAa,OAAIG,cAAe,CAAAlB,IAAA,EAAMO,IAAI;IAEhD,IAAIL,QAAA,IAAY,IAAM;MACb,KAAAH,YAAA,CAAaC,IAAM,EAAAO,IAAA,EAAML,QAAQ;IAAA,CACnC;MACH,MAAMO,MAAS,QAAKX,KAAM,CAAAY,UAAA,CAAWH,IAAI;MAEzC,IAAI,CAACE,MAAA,EAAQ,MAAM,IAAIE,KAAA,CAAM,8BAA8BJ,IAAA,sBAA0BP,IAAO;MAC5FS,MAAA,CAAOG,YAAe,GAAAH,MAAA;MACtBM,UAAA,CAAWN,MAAS,GAAAA,MAAA;IAAA;IAGjB,OAAAM,UAAA;EAAA;EAGXI,yBAAyBL,IAAA,EAAYd,IAAqC;IAC/D,WAAIoB,qBAAA,CAAsBpB,IAAI;EAAA;EAGzCqB,kBAAkBP,IAAA,EAAYd,IAA8B;IACjD,WAAIsB,cAAA,CAAetB,IAAI;EAAA;EAGlCuB,mBAAmBT,IAAA,EAAYd,IAA+B;IACnD,WAAIwB,eAAA,CAAgBxB,IAAI;EAAA;EAGnCyB,sBAAsBX,IAAA,EAAYd,IAAkC;IACzD,WAAI0B,kBAAA,CAAmB1B,IAAI;EAAA;AAE1C","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}