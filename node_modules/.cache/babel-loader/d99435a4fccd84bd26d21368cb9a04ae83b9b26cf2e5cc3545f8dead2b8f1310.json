{"ast":null,"code":"import { ExtensionType, extensions, Texture, collectAllRenderables } from 'pixi.js';\nimport { BatchableSpineSlot } from './BatchableSpineSlot.mjs';\nimport { SkeletonClipping, RegionAttachment, MeshAttachment } from '@esotericsoftware/spine-core';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst clipper = new SkeletonClipping();\nconst spineBlendModeMap = {\n  0: \"normal\",\n  1: \"add\",\n  2: \"multiply\",\n  3: \"screen\"\n};\nclass SpinePipe {\n  constructor(renderer) {\n    __publicField(this, \"renderer\");\n    __publicField(this, \"gpuSpineData\", {});\n    this.renderer = renderer;\n  }\n  validateRenderable(spine) {\n    spine._applyState();\n    return spine.spineAttachmentsDirty;\n  }\n  addRenderable(spine, instructionSet) {\n    var _a, _b, _c, _d;\n    const gpuSpine = (_a = this.gpuSpineData)[_b = spine.uid] || (_a[_b] = {\n      slotBatches: {}\n    });\n    const batcher = this.renderer.renderPipes.batch;\n    const drawOrder = spine.skeleton.drawOrder;\n    const roundPixels = this.renderer._roundPixels | spine._roundPixels;\n    spine._applyState();\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      const attachment = slot.getAttachment();\n      const blendMode = spineBlendModeMap[slot.data.blendMode];\n      if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment) {\n        const cacheData = spine._getCachedData(slot, attachment);\n        const batchableSpineSlot = (_c = gpuSpine.slotBatches)[_d = cacheData.id] || (_c[_d] = new BatchableSpineSlot());\n        if (!cacheData.clipped || cacheData.clipped && cacheData.clippedData.vertices.length > 0) {\n          batchableSpineSlot.setData(spine, cacheData, attachment.region?.texture.texture || Texture.EMPTY, blendMode, roundPixels);\n          batcher.addToBatch(batchableSpineSlot);\n        }\n      }\n      const containerAttachment = spine._slotsObject[slot.data.name];\n      if (containerAttachment) {\n        const container = containerAttachment.container;\n        container.includeInBuild = true;\n        collectAllRenderables(container, instructionSet, this.renderer.renderPipes);\n        container.includeInBuild = false;\n      }\n    }\n    clipper.clipEnd();\n  }\n  updateRenderable(spine) {\n    const gpuSpine = this.gpuSpineData[spine.uid];\n    spine._applyState();\n    const drawOrder = spine.skeleton.drawOrder;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      const attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment) {\n        const batchableSpineSlot = gpuSpine.slotBatches[spine._getCachedData(slot, attachment).id];\n        batchableSpineSlot.batcher.updateElement(batchableSpineSlot);\n      }\n    }\n  }\n  destroyRenderable(spine) {\n    this.gpuSpineData[spine.uid] = null;\n  }\n  destroy() {\n    this.gpuSpineData = null;\n    this.renderer = null;\n  }\n}\n/** @ignore */\n__publicField(SpinePipe, \"extension\", {\n  type: [ExtensionType.WebGLPipes, ExtensionType.WebGPUPipes, ExtensionType.CanvasPipes],\n  name: \"spine\"\n});\nextensions.add(SpinePipe);\nexport { SpinePipe };","map":{"version":3,"names":["clipper","SkeletonClipping","spineBlendModeMap","SpinePipe","constructor","renderer","__publicField","validateRenderable","spine","_applyState","spineAttachmentsDirty","addRenderable","instructionSet","_a","_b","_c","_d","gpuSpine","gpuSpineData","uid","slotBatches","batcher","renderPipes","batch","drawOrder","skeleton","roundPixels","_roundPixels","i","n","length","slot","attachment","getAttachment","blendMode","data","RegionAttachment","MeshAttachment","cacheData","_getCachedData","batchableSpineSlot","id","BatchableSpineSlot","clipped","clippedData","vertices","setData","region","texture","Texture","EMPTY","addToBatch","containerAttachment","_slotsObject","name","container","includeInBuild","collectAllRenderables","clipEnd","updateRenderable","updateElement","destroyRenderable","destroy","type","ExtensionType","WebGLPipes","WebGPUPipes","CanvasPipes","extensions","add"],"sources":["../src/SpinePipe.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    collectAllRenderables,\n    extensions, ExtensionType,\n    InstructionSet,\n    type Renderer,\n    type RenderPipe,\n    Texture\n} from 'pixi.js';\nimport { BatchableSpineSlot } from './BatchableSpineSlot';\nimport { Spine } from './Spine';\nimport { MeshAttachment, RegionAttachment, SkeletonClipping } from '@esotericsoftware/spine-core';\n\nconst clipper = new SkeletonClipping();\n\nconst spineBlendModeMap = {\n    0: 'normal',\n    1: 'add',\n    2: 'multiply',\n    3: 'screen'\n};\n\n// eslint-disable-next-line max-len\nexport class SpinePipe implements RenderPipe<Spine>\n{\n    /** @ignore */\n    static extension = {\n        type: [\n            ExtensionType.WebGLPipes,\n            ExtensionType.WebGPUPipes,\n            ExtensionType.CanvasPipes,\n        ],\n        name: 'spine',\n    } as const;\n\n    renderer: Renderer;\n\n    private gpuSpineData:Record<string, any> = {};\n\n    constructor(renderer: Renderer)\n    {\n        this.renderer = renderer;\n    }\n\n    validateRenderable(spine: Spine): boolean\n    {\n        spine._applyState();\n        // loop through and see if the mesh lengths have changed..\n\n        return spine.spineAttachmentsDirty;\n    }\n\n    addRenderable(spine: Spine, instructionSet:InstructionSet)\n    {\n        const gpuSpine = this.gpuSpineData[spine.uid] ||= { slotBatches: {} };\n\n        const batcher = this.renderer.renderPipes.batch;\n\n        const drawOrder = spine.skeleton.drawOrder;\n\n        const roundPixels = (this.renderer._roundPixels | spine._roundPixels) as 0 | 1;\n\n        spine._applyState();\n\n        for (let i = 0, n = drawOrder.length; i < n; i++)\n        {\n            const slot = drawOrder[i];\n            const attachment = slot.getAttachment();\n            const blendMode = spineBlendModeMap[slot.data.blendMode];\n\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\n            {\n                const cacheData = spine._getCachedData(slot, attachment);\n                const batchableSpineSlot = gpuSpine.slotBatches[cacheData.id] ||= new BatchableSpineSlot();\n\n                if (!cacheData.clipped || (cacheData.clipped && cacheData.clippedData.vertices.length > 0))\n                {\n                    batchableSpineSlot.setData(\n                        spine,\n                        cacheData,\n                        (attachment.region?.texture.texture) || Texture.EMPTY,\n                        blendMode,\n                        roundPixels\n                    );\n\n                    batcher.addToBatch(batchableSpineSlot);\n                }\n            }\n\n            const containerAttachment = spine._slotsObject[slot.data.name];\n\n            if (containerAttachment)\n            {\n                const container = containerAttachment.container;\n\n                container.includeInBuild = true;\n                collectAllRenderables(container, instructionSet, this.renderer.renderPipes);\n                container.includeInBuild = false;\n            }\n        }\n\n        clipper.clipEnd();\n    }\n\n    updateRenderable(spine: Spine)\n    {\n        // we assume that spine will always change its verts size..\n        const gpuSpine = this.gpuSpineData[spine.uid];\n\n        spine._applyState();\n\n        const drawOrder = spine.skeleton.drawOrder;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++)\n        {\n            const slot = drawOrder[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)\n            {\n                const batchableSpineSlot = gpuSpine.slotBatches[spine._getCachedData(slot, attachment).id];\n\n                batchableSpineSlot.batcher.updateElement(batchableSpineSlot);\n            }\n        }\n    }\n\n    destroyRenderable(spine: Spine)\n    {\n        // TODO remove the renderable from the batcher\n        this.gpuSpineData[spine.uid] = null as any;\n    }\n\n    destroy()\n    {\n        this.gpuSpineData = null as any;\n        this.renderer = null as any;\n    }\n}\n\nextensions.add(SpinePipe);\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}