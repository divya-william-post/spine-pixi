{"ast":null,"code":"import { Color } from '@pixi-spine/base';\nimport { VertexAttachment } from './attachments/Attachment.mjs';\nclass Slot {\n  constructor(data, bone) {\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    this.darkColor = null;\n    this.attachment = null;\n    this.attachmentState = 0;\n    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\n     * {@link Sequence#getSetupIndex()}. */\n    this.sequenceIndex = -1;\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n     *\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n    this.deform = new Array();\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!bone) throw new Error(\"bone cannot be null.\");\n    this.data = data;\n    this.bone = bone;\n    this.color = new Color();\n    this.darkColor = !data.darkColor ? null : new Color();\n    this.setToSetupPose();\n    this.blendMode = this.data.blendMode;\n  }\n  /** The skeleton this slot belongs to. */\n  getSkeleton() {\n    return this.bone.skeleton;\n  }\n  /** The current attachment for the slot, or null if the slot has no attachment. */\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\n   * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\n   * specified attachment. */\n  setAttachment(attachment) {\n    if (this.attachment == attachment) return;\n    if (!(attachment instanceof VertexAttachment) || !(this.attachment instanceof VertexAttachment) || attachment.timelineAttachment != this.attachment.timelineAttachment) {\n      this.deform.length = 0;\n    }\n    this.attachment = attachment;\n    this.sequenceIndex = -1;\n  }\n  /** Sets this slot to the setup pose. */\n  setToSetupPose() {\n    this.color.setFromColor(this.data.color);\n    if (this.darkColor) this.darkColor.setFromColor(this.data.darkColor);\n    if (!this.data.attachmentName) this.attachment = null;else {\n      this.attachment = null;\n      this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n    }\n  }\n}\nexport { Slot };","map":{"version":3,"names":["Slot","constructor","data","bone","darkColor","attachment","attachmentState","sequenceIndex","deform","Array","Error","color","Color","setToSetupPose","blendMode","getSkeleton","skeleton","getAttachment","setAttachment","VertexAttachment","timelineAttachment","length","setFromColor","attachmentName","index"],"sources":["../../src/core/Slot.ts"],"sourcesContent":["import { Color, ISlot } from '@pixi-spine/base';\n\nimport { Attachment, VertexAttachment } from './attachments/Attachment';\nimport type { Bone } from './Bone';\nimport type { SlotData } from './SlotData';\nimport type { Skeleton } from './Skeleton';\n\n/** Stores a slot's current pose. Slots organize attachments for {@link Skeleton#drawOrder} purposes and provide a place to store\n * state for an attachment. State cannot be stored in an attachment itself because attachments are stateless and may be shared\n * across multiple skeletons.\n * @public\n * */\nexport class Slot implements ISlot {\n    // this is canon\n    blendMode: number;\n    /** The slot's setup pose data. */\n    data: SlotData;\n\n    /** The bone this slot belongs to. */\n    bone: Bone;\n\n    /** The color used to tint the slot's attachment. If {@link #getDarkColor()} is set, this is used as the light color for two\n     * color tinting. */\n    color: Color;\n\n    /** The dark color used to tint the slot's attachment for two color tinting, or null if two color tinting is not used. The dark\n     * color's alpha is not used. */\n    darkColor: Color | null = null;\n\n    attachment: Attachment | null = null;\n\n    attachmentState = 0;\n\n    /** The index of the texture region to display when the slot's attachment has a {@link Sequence}. -1 represents the\n     * {@link Sequence#getSetupIndex()}. */\n    sequenceIndex = -1;\n\n    /** Values to deform the slot's attachment. For an unweighted mesh, the entries are local positions for each vertex. For a\n     * weighted mesh, the entries are an offset for each vertex which will be added to the mesh's local vertex positions.\n     *\n     * See {@link VertexAttachment#computeWorldVertices()} and {@link DeformTimeline}. */\n    deform = new Array<number>();\n\n    constructor(data: SlotData, bone: Bone) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!bone) throw new Error('bone cannot be null.');\n        this.data = data;\n        this.bone = bone;\n        this.color = new Color();\n        this.darkColor = !data.darkColor ? null : new Color();\n        this.setToSetupPose();\n\n        this.blendMode = this.data.blendMode;\n    }\n\n    /** The skeleton this slot belongs to. */\n    getSkeleton(): Skeleton {\n        return this.bone.skeleton;\n    }\n\n    /** The current attachment for the slot, or null if the slot has no attachment. */\n    getAttachment(): Attachment | null {\n        return this.attachment;\n    }\n\n    /** Sets the slot's attachment and, if the attachment changed, resets {@link #sequenceIndex} and clears the {@link #deform}.\n     * The deform is not cleared if the old attachment has the same {@link VertexAttachment#getTimelineAttachment()} as the\n     * specified attachment. */\n    setAttachment(attachment: Attachment | null) {\n        if (this.attachment == attachment) return;\n        if (\n            !(attachment instanceof VertexAttachment) ||\n            !(this.attachment instanceof VertexAttachment) ||\n            (<VertexAttachment>attachment).timelineAttachment != (<VertexAttachment>this.attachment).timelineAttachment\n        ) {\n            this.deform.length = 0;\n        }\n        this.attachment = attachment;\n        this.sequenceIndex = -1;\n    }\n\n    /** Sets this slot to the setup pose. */\n    setToSetupPose() {\n        this.color.setFromColor(this.data.color);\n        if (this.darkColor) this.darkColor.setFromColor(this.data.darkColor);\n        if (!this.data.attachmentName) this.attachment = null;\n        else {\n            this.attachment = null;\n            this.setAttachment(this.bone.skeleton.getAttachment(this.data.index, this.data.attachmentName));\n        }\n    }\n}\n"],"mappings":";;AAYO,MAAMA,IAAsB;EA+B/BC,YAAYC,IAAA,EAAgBC,IAAY;IAhBxC;AAAA;IAA0B,KAAAC,SAAA;IAEM,KAAAC,UAAA;IAEd,KAAAC,eAAA;IAIlB;AAAA;IAAgB,KAAAC,aAAA;IAMhB;AAAA;AAAA;AAAA;IAAA,KAAAC,MAAA,GAAS,IAAIC,KAAc;IAGvB,IAAI,CAACP,IAAA,EAAY,UAAIQ,KAAA,CAAM,sBAAsB;IACjD,IAAI,CAACP,IAAA,EAAY,UAAIO,KAAA,CAAM,sBAAsB;IACjD,KAAKR,IAAO,GAAAA,IAAA;IACZ,KAAKC,IAAO,GAAAA,IAAA;IACP,KAAAQ,KAAA,GAAQ,IAAIC,KAAM;IACvB,KAAKR,SAAA,GAAY,CAACF,IAAA,CAAKE,SAAY,UAAO,IAAIQ,KAAM;IACpD,KAAKC,cAAe;IAEf,KAAAC,SAAA,GAAY,KAAKZ,IAAK,CAAAY,SAAA;EAAA;EAC/B;EAGAC,WAAwBA,CAAA;IACpB,OAAO,KAAKZ,IAAK,CAAAa,QAAA;EAAA;EACrB;EAGAC,aAAmCA,CAAA;IAC/B,OAAO,IAAK,CAAAZ,UAAA;EAAA;EAChB;AAAA;AAAA;EAKAa,cAAcb,UAA+B;IACzC,IAAI,KAAKA,UAAc,IAAAA,UAAA,EAAY;IAE/B,MAAEA,UAAsB,YAAAc,gBAAA,KACxB,EAAE,KAAKd,UAAsB,YAAAc,gBAAA,KACVd,UAAY,CAAAe,kBAAA,IAAyC,IAAK,CAAAf,UAAA,CAAYe,kBAC3F;MACE,KAAKZ,MAAA,CAAOa,MAAS;IAAA;IAEzB,KAAKhB,UAAa,GAAAA,UAAA;IAClB,KAAKE,aAAgB;EAAA;EACzB;EAGAM,cAAiBA,CAAA;IACb,KAAKF,KAAM,CAAAW,YAAA,CAAa,IAAK,CAAApB,IAAA,CAAKS,KAAK;IACvC,IAAI,IAAK,CAAAP,SAAA,EAAW,KAAKA,SAAU,CAAAkB,YAAA,CAAa,IAAK,CAAApB,IAAA,CAAKE,SAAS;IAC/D,KAAC,KAAKF,IAAK,CAAAqB,cAAA,EAAgB,KAAKlB,UAAa,aAC5C;MACD,KAAKA,UAAa;MACb,KAAAa,aAAA,CAAc,IAAK,CAAAf,IAAA,CAAKa,QAAS,CAAAC,aAAA,CAAc,IAAK,CAAAf,IAAA,CAAKsB,KAAO,OAAKtB,IAAK,CAAAqB,cAAc,CAAC;IAAA;EAClG;AAER","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}