{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { ExtensionType, LoaderParserPriority, checkExtension, DOMAdapter, path, TextureSource, extensions } from 'pixi.js';\nimport { SpineTexture } from '../SpineTexture.mjs';\nimport { TextureAtlas } from '@esotericsoftware/spine-core';\nconst spineTextureAtlasLoader = {\n  extension: ExtensionType.Asset,\n  loader: {\n    extension: {\n      type: ExtensionType.LoadParser,\n      priority: LoaderParserPriority.Normal,\n      name: \"spineTextureAtlasLoader\"\n    },\n    test(url) {\n      return checkExtension(url, \".atlas\");\n    },\n    async load(url) {\n      const response = await DOMAdapter.get().fetch(url);\n      const txt = await response.text();\n      return txt;\n    },\n    testParse(asset, options) {\n      const isExtensionRight = checkExtension(options.src, \".atlas\");\n      const isString = typeof asset === \"string\";\n      return Promise.resolve(isExtensionRight && isString);\n    },\n    unload(atlas) {\n      atlas.dispose();\n    },\n    async parse(asset, options, loader) {\n      const metadata = options.data || {};\n      let basePath = path.dirname(options.src);\n      if (basePath && basePath.lastIndexOf(\"/\") !== basePath.length - 1) {\n        basePath += \"/\";\n      }\n      const retval = new TextureAtlas(asset);\n      if (metadata.images instanceof TextureSource || typeof metadata.images === \"string\") {\n        const pixiTexture = metadata.images;\n        metadata.images = {};\n        metadata.images[retval.pages[0].name] = pixiTexture;\n      }\n      const textureLoadingPromises = [];\n      for (const page of retval.pages) {\n        const pageName = page.name;\n        const providedPage = metadata?.images ? metadata.images[pageName] : void 0;\n        if (providedPage instanceof TextureSource) {\n          page.setTexture(SpineTexture.from(providedPage));\n        } else {\n          const url = providedPage ?? path.normalize([...basePath.split(path.sep), pageName].join(path.sep));\n          const pixiPromise = loader.load({\n            src: url,\n            data: metadata.imageMetadata\n          }).then(texture => {\n            page.setTexture(SpineTexture.from(texture.source));\n          });\n          textureLoadingPromises.push(pixiPromise);\n        }\n      }\n      await Promise.all(textureLoadingPromises);\n      return retval;\n    }\n  }\n};\nextensions.add(spineTextureAtlasLoader);","map":{"version":3,"names":["spineTextureAtlasLoader","extension","ExtensionType","Asset","loader","type","LoadParser","priority","LoaderParserPriority","Normal","name","test","url","checkExtension","load","response","DOMAdapter","get","fetch","txt","text","testParse","asset","options","isExtensionRight","src","isString","Promise","resolve","unload","atlas","dispose","parse","metadata","data","basePath","path","dirname","lastIndexOf","length","retval","TextureAtlas","images","TextureSource","pixiTexture","pages","textureLoadingPromises","page","pageName","providedPage","setTexture","SpineTexture","from","normalize","split","sep","join","pixiPromise","imageMetadata","then","texture","source","push","all","extensions","add"],"sources":["../../src/assets/atlasLoader.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    checkExtension,\n    DOMAdapter,\n    extensions,\n    ExtensionType,\n    LoaderParserPriority,\n    path,\n    TextureSource\n} from 'pixi.js';\nimport { SpineTexture } from '../SpineTexture';\nimport { TextureAtlas } from '@esotericsoftware/spine-core';\n\nimport type { AssetExtension, Loader, ResolvedAsset, Texture } from 'pixi.js';\n\ntype RawAtlas = string;\n\nconst spineTextureAtlasLoader: AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata> = {\n    extension: ExtensionType.Asset,\n\n    loader: {\n        extension: {\n            type: ExtensionType.LoadParser,\n            priority: LoaderParserPriority.Normal,\n            name: 'spineTextureAtlasLoader',\n        },\n\n        test(url: string): boolean\n        {\n            return checkExtension(url, '.atlas');\n        },\n\n        async load(url: string): Promise<RawAtlas>\n        {\n            const response = await DOMAdapter.get().fetch(url);\n\n            const txt = await response.text();\n\n            return txt;\n        },\n\n        testParse(asset: unknown, options: ResolvedAsset): Promise<boolean>\n        {\n            const isExtensionRight = checkExtension(options.src as string, '.atlas');\n            const isString = typeof asset === 'string';\n\n            return Promise.resolve(isExtensionRight && isString);\n        },\n\n        unload(atlas: TextureAtlas)\n        {\n            atlas.dispose();\n        },\n\n        async parse(asset: RawAtlas, options: ResolvedAsset, loader: Loader): Promise<TextureAtlas>\n        {\n            const metadata: ISpineAtlasMetadata = options.data || {};\n            let basePath = path.dirname(options.src as string);\n\n            if (basePath && basePath.lastIndexOf('/') !== basePath.length - 1)\n            {\n                basePath += '/';\n            }\n\n            // Retval is going to be a texture atlas. However we need to wait for it's callback to resolve this promise.\n            const retval = new TextureAtlas(asset);\n\n            // If the user gave me only one texture, that one is assumed to be the \"first\" texture in the atlas\n            if (metadata.images instanceof TextureSource || typeof metadata.images === 'string')\n            {\n                const pixiTexture = metadata.images;\n\n                metadata.images = {} as Record<string, TextureSource | string>;\n                metadata.images[retval.pages[0].name] = pixiTexture;\n            }\n\n            // we will wait for all promises for the textures at the same time at the end.\n            const textureLoadingPromises:Promise<any>[] = [];\n\n            // fill the pages\n            for (const page of retval.pages)\n            {\n                const pageName = page.name;\n                const providedPage = metadata?.images ? metadata.images[pageName] : undefined;\n\n                if (providedPage instanceof TextureSource)\n                {\n                    page.setTexture(SpineTexture.from(providedPage));\n                }\n                else\n                {\n                    // eslint-disable-next-line max-len\n                    const url: string = providedPage ?? path.normalize([...basePath.split(path.sep), pageName].join(path.sep));\n\n                    const pixiPromise = loader.load<Texture>({ src: url, data: metadata.imageMetadata }).then((texture) =>\n                    {\n                        page.setTexture(SpineTexture.from(texture.source));\n                    });\n\n                    textureLoadingPromises.push(pixiPromise);\n                }\n            }\n\n            await Promise.all(textureLoadingPromises);\n\n            return retval;\n        },\n    },\n} as AssetExtension<RawAtlas | TextureAtlas, ISpineAtlasMetadata>;\n\nextensions.add(spineTextureAtlasLoader);\n\nexport interface ISpineAtlasMetadata\n{\n    // If you are downloading an .atlas file, this metadata will go to the Texture loader\n    imageMetadata?: any;\n    // If you already have atlas pages loaded as pixi textures\n    // and want to use that to create the atlas, you can pass them here\n    images?: TextureSource | string | Record<string, TextureSource | string>;\n}\n"],"mappings":";;;;AA6CA,MAAMA,uBAAwF;EAC1FC,SAAA,EAAWC,aAAc,CAAAC,KAAA;EAEzBC,MAAQ;IACJH,SAAW;MACPI,IAAA,EAAMH,aAAc,CAAAI,UAAA;MACpBC,QAAA,EAAUC,oBAAqB,CAAAC,MAAA;MAC/BC,IAAM;IAAA,CACV;IAEAC,KAAKC,GACL;MACW,OAAAC,cAAA,CAAeD,GAAA,EAAK,QAAQ;IAAA,CACvC;IAEA,MAAME,KAAKF,GACX;MACI,MAAMG,QAAA,GAAW,MAAMC,UAAA,CAAWC,GAAI,GAAEC,KAAA,CAAMN,GAAG;MAE3C,MAAAO,GAAA,GAAM,MAAMJ,QAAA,CAASK,IAAK;MAEzB,OAAAD,GAAA;IAAA,CACX;IAEAE,UAAUC,KAAA,EAAgBC,OAC1B;MACI,MAAMC,gBAAmB,GAAAX,cAAA,CAAeU,OAAQ,CAAAE,GAAA,EAAe,QAAQ;MACjE,MAAAC,QAAA,GAAW,OAAOJ,KAAU;MAE3B,OAAAK,OAAA,CAAQC,OAAQ,CAAAJ,gBAAA,IAAoBE,QAAQ;IAAA,CACvD;IAEAG,OAAOC,KACP;MACIA,KAAA,CAAMC,OAAQ;IAAA,CAClB;IAEA,MAAMC,MAAMV,KAAiB,EAAAC,OAAA,EAAwBnB,MACrD;MACU,MAAA6B,QAAA,GAAgCV,OAAQ,CAAAW,IAAA,IAAQ,EAAC;MACvD,IAAIC,QAAW,GAAAC,IAAA,CAAKC,OAAQ,CAAAd,OAAA,CAAQE,GAAa;MAEjD,IAAIU,QAAA,IAAYA,QAAS,CAAAG,WAAA,CAAY,GAAG,CAAM,KAAAH,QAAA,CAASI,MAAA,GAAS,CAChE;QACgBJ,QAAA;MAAA;MAIV,MAAAK,MAAA,GAAS,IAAIC,YAAA,CAAanB,KAAK;MAGrC,IAAIW,QAAA,CAASS,MAAkB,YAAAC,aAAA,IAAiB,OAAOV,QAAA,CAASS,MAAA,KAAW,QAC3E;QACI,MAAME,WAAA,GAAcX,QAAS,CAAAS,MAAA;QAE7BT,QAAA,CAASS,MAAA,GAAS,EAAC;QACnBT,QAAA,CAASS,MAAA,CAAOF,MAAO,CAAAK,KAAA,CAAM,CAAC,EAAEnC,IAAI,CAAI,GAAAkC,WAAA;MAAA;MAI5C,MAAME,sBAAA,GAAwC,EAAC;MAGpC,WAAAC,IAAA,IAAQP,MAAA,CAAOK,KAC1B;QACI,MAAMG,QAAA,GAAWD,IAAK,CAAArC,IAAA;QACtB,MAAMuC,YAAA,GAAehB,QAAU,EAAAS,MAAA,GAAST,QAAS,CAAAS,MAAA,CAAOM,QAAQ,CAAI;QAEpE,IAAIC,YAAA,YAAwBN,aAC5B;UACII,IAAA,CAAKG,UAAW,CAAAC,YAAA,CAAaC,IAAK,CAAAH,YAAY,CAAC;QAAA,CAGnD;UAEI,MAAMrC,GAAA,GAAcqC,YAAgB,IAAAb,IAAA,CAAKiB,SAAU,EAAC,GAAGlB,QAAS,CAAAmB,KAAA,CAAMlB,IAAK,CAAAmB,GAAG,GAAGP,QAAQ,EAAEQ,IAAK,CAAApB,IAAA,CAAKmB,GAAG,CAAC;UAEzG,MAAME,WAAc,GAAArD,MAAA,CAAOU,IAAc;YAAEW,GAAK,EAAAb,GAAA;YAAKsB,IAAM,EAAAD,QAAA,CAASyB;UAAc,CAAC,CAAE,CAAAC,IAAA,CAAMC,OAC3F;YACIb,IAAA,CAAKG,UAAW,CAAAC,YAAA,CAAaC,IAAK,CAAAQ,OAAA,CAAQC,MAAM,CAAC;UAAA,CACpD;UAEDf,sBAAA,CAAuBgB,IAAA,CAAKL,WAAW;QAAA;MAC3C;MAGE,MAAA9B,OAAA,CAAQoC,GAAA,CAAIjB,sBAAsB;MAEjC,OAAAN,MAAA;IAAA;EACX;AAER;AAEAwB,UAAA,CAAWC,GAAA,CAAIjE,uBAAuB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}