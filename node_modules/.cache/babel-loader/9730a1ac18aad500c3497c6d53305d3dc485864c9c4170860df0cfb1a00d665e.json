{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { VertexAttachment } from './attachments/Attachment.mjs';\nimport { StringSet, Utils, MixBlend, MixDirection, MathUtils } from '@pixi-spine/base';\nimport './attachments/RegionAttachment.mjs';\nimport { SequenceModeValues, SequenceMode } from './attachments/Sequence.mjs';\nclass Animation {\n  constructor(name, timelines, duration) {\n    this.timelines = [];\n    this.timelineIds = new StringSet();\n    if (!name) throw new Error(\"name cannot be null.\");\n    this.name = name;\n    this.setTimelines(timelines);\n    this.duration = duration;\n  }\n  setTimelines(timelines) {\n    if (!timelines) throw new Error(\"timelines cannot be null.\");\n    this.timelines = timelines;\n    this.timelineIds.clear();\n    for (let i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\n  }\n  hasTimeline(ids) {\n    for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\n    return false;\n  }\n  /** Applies all the animation's timelines to the specified skeleton.\n   *\n   * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n   * @param loop If true, the animation repeats after {@link #getDuration()}.\n   * @param events May be null to ignore fired events. */\n  apply(skeleton, lastTime, time, loop, events, alpha, blend, direction) {\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    if (loop && this.duration != 0) {\n      time %= this.duration;\n      if (lastTime > 0) lastTime %= this.duration;\n    }\n    const timelines = this.timelines;\n    for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n  }\n}\nconst Property = {\n  rotate: 0,\n  x: 1,\n  y: 2,\n  scaleX: 3,\n  scaleY: 4,\n  shearX: 5,\n  shearY: 6,\n  rgb: 7,\n  alpha: 8,\n  rgb2: 9,\n  attachment: 10,\n  deform: 11,\n  event: 12,\n  drawOrder: 13,\n  ikConstraint: 14,\n  transformConstraint: 15,\n  pathConstraintPosition: 16,\n  pathConstraintSpacing: 17,\n  pathConstraintMix: 18,\n  sequence: 19\n};\nclass Timeline {\n  constructor(frameCount, propertyIds) {\n    this.propertyIds = propertyIds;\n    this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n  }\n  getPropertyIds() {\n    return this.propertyIds;\n  }\n  getFrameEntries() {\n    return 1;\n  }\n  getFrameCount() {\n    return this.frames.length / this.getFrameEntries();\n  }\n  getDuration() {\n    return this.frames[this.frames.length - this.getFrameEntries()];\n  }\n  static search1(frames, time) {\n    const n = frames.length;\n    for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\n    return n - 1;\n  }\n  static search(frames, time, step) {\n    const n = frames.length;\n    for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\n    return n - step;\n  }\n}\nclass CurveTimeline extends Timeline {\n  // type, x, y, ...\n  constructor(frameCount, bezierCount, propertyIds) {\n    super(frameCount, propertyIds);\n    this.curves = Utils.newFloatArray(frameCount + bezierCount * 18\n    /* BEZIER_SIZE*/);\n    this.curves[frameCount - 1] = 1;\n  }\n  /** Sets the specified key frame to linear interpolation. */\n  setLinear(frame) {\n    this.curves[frame] = 0;\n  }\n  /** Sets the specified key frame to stepped interpolation. */\n  setStepped(frame) {\n    this.curves[frame] = 1;\n  }\n  /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n   * than the actual number of Bezier curves. */\n  shrink(bezierCount) {\n    const size = this.getFrameCount() + bezierCount * 18;\n    if (this.curves.length > size) {\n      const newCurves = Utils.newFloatArray(size);\n      Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n      this.curves = newCurves;\n    }\n  }\n  /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n   * one curve per frame.\n   * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n   *           in the constructor), inclusive.\n   * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n   * @param value The index of the value for this frame that this curve is used for.\n   * @param time1 The time for the first key.\n   * @param value1 The value for the first key.\n   * @param cx1 The time for the first Bezier handle.\n   * @param cy1 The value for the first Bezier handle.\n   * @param cx2 The time of the second Bezier handle.\n   * @param cy2 The value for the second Bezier handle.\n   * @param time2 The time for the second key.\n   * @param value2 The value for the second key. */\n  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {\n    const curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18;\n    if (value == 0) curves[frame] = 2 + i;\n    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n    const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;\n    const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 6e-3;\n    let ddx = tmpx * 2 + dddx;\n    let ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n    let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx;\n    let y = value1 + dy;\n    for (let n = i + 18; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n  /** Returns the Bezier interpolated value for the specified time.\n   * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n   * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n   * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n  getBezierValue(time, frameIndex, valueOffset, i) {\n    const curves = this.curves;\n    if (curves[i] > time) {\n      const x2 = this.frames[frameIndex];\n      const y2 = this.frames[frameIndex + valueOffset];\n      return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);\n    }\n    const n = i + 18;\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        const x2 = curves[i - 2];\n        const y2 = curves[i - 1];\n        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);\n      }\n    }\n    frameIndex += this.getFrameEntries();\n    const x = curves[n - 2];\n    const y = curves[n - 1];\n    return y + (time - x) / (this.frames[frameIndex] - x) * (this.frames[frameIndex + valueOffset] - y);\n  }\n}\nclass CurveTimeline1 extends CurveTimeline {\n  constructor(frameCount, bezierCount, propertyId) {\n    super(frameCount, bezierCount, [propertyId]);\n  }\n  getFrameEntries() {\n    return 2;\n  }\n  /** Sets the time and value for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time The frame time in seconds. */\n  setFrame(frame, time, value) {\n    frame <<= 1;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* VALUE*/] = value;\n  }\n  /** Returns the interpolated value for the specified time. */\n  getCurveValue(time) {\n    const frames = this.frames;\n    let i = frames.length - 2;\n    for (let ii = 2; ii <= i; ii += 2) {\n      if (frames[ii] > time) {\n        i = ii - 2;\n        break;\n      }\n    }\n    const curveType = this.curves[i >> 1];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        const value = frames[i + 1\n        /* VALUE*/];\n        return value + (time - before) / (frames[i + 2\n        /* ENTRIES*/] - before) * (frames[i + 2 + 1\n        /* VALUE*/] - value);\n      case 1:\n        return frames[i + 1\n        /* VALUE*/];\n    }\n    return this.getBezierValue(time, i, 1, curveType - 2\n    /* BEZIER*/);\n  }\n}\nclass CurveTimeline2 extends CurveTimeline {\n  /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n   * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n  constructor(frameCount, bezierCount, propertyId1, propertyId2) {\n    super(frameCount, bezierCount, [propertyId1, propertyId2]);\n  }\n  getFrameEntries() {\n    return 3;\n  }\n  /** Sets the time and values for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time The frame time in seconds. */\n  setFrame(frame, time, value1, value2) {\n    frame *= 3;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* VALUE1*/] = value1;\n    this.frames[frame + 2\n    /* VALUE2*/] = value2;\n  }\n}\nclass RotateTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n          return;\n        case MixBlend.first:\n          bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n      }\n      return;\n    }\n    let r = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.rotation = bone.data.rotation + r * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        r += bone.data.rotation - bone.rotation;\n      case MixBlend.add:\n        bone.rotation += r * alpha;\n    }\n  }\n}\nclass TranslateTimeline extends CurveTimeline2 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    const i = Timeline.search(frames, time, 3\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 3\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        x = frames[i + 1\n        /* VALUE1*/];\n        y = frames[i + 2\n        /* VALUE2*/];\n        const t = (time - before) / (frames[i + 3\n        /* ENTRIES*/] - before);\n        x += (frames[i + 3 + 1\n        /* VALUE1*/] - x) * t;\n        y += (frames[i + 3 + 2\n        /* VALUE2*/] - y) * t;\n        break;\n      case 1:\n        x = frames[i + 1\n        /* VALUE1*/];\n        y = frames[i + 2\n        /* VALUE2*/];\n        break;\n      default:\n        x = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        y = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n        bone.y += y * alpha;\n    }\n  }\n}\nclass TranslateXTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.x = bone.data.x;\n          return;\n        case MixBlend.first:\n          bone.x += (bone.data.x - bone.x) * alpha;\n      }\n      return;\n    }\n    const x = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.x = bone.data.x + x * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.x += (bone.data.x + x - bone.x) * alpha;\n        break;\n      case MixBlend.add:\n        bone.x += x * alpha;\n    }\n  }\n}\nclass TranslateYTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.y = bone.data.y;\n          return;\n        case MixBlend.first:\n          bone.y += (bone.data.y - bone.y) * alpha;\n      }\n      return;\n    }\n    const y = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.y = bone.data.y + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.y += (bone.data.y + y - bone.y) * alpha;\n        break;\n      case MixBlend.add:\n        bone.y += y * alpha;\n    }\n  }\n}\nclass ScaleTimeline extends CurveTimeline2 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    let x;\n    let y;\n    const i = Timeline.search(frames, time, 3\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 3\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        x = frames[i + 1\n        /* VALUE1*/];\n        y = frames[i + 2\n        /* VALUE2*/];\n        const t = (time - before) / (frames[i + 3\n        /* ENTRIES*/] - before);\n        x += (frames[i + 3 + 1\n        /* VALUE1*/] - x) * t;\n        y += (frames[i + 3 + 2\n        /* VALUE2*/] - y) * t;\n        break;\n      case 1:\n        x = frames[i + 1\n        /* VALUE1*/];\n        y = frames[i + 2\n        /* VALUE2*/];\n        break;\n      default:\n        x = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        y = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n    }\n    x *= bone.data.scaleX;\n    y *= bone.data.scaleY;\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        bone.scaleX += x - bone.data.scaleX;\n        bone.scaleY += y - bone.data.scaleY;\n      } else {\n        bone.scaleX = x;\n        bone.scaleY = y;\n      }\n    } else {\n      let bx = 0;\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            by = bone.data.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            by = bone.scaleY;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleX = bx + (x - bx) * alpha;\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ScaleXTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleX = bone.data.scaleX;\n          return;\n        case MixBlend.first:\n          bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n      }\n      return;\n    }\n    const x = this.getCurveValue(time) * bone.data.scaleX;\n    if (alpha == 1) {\n      if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;else bone.scaleX = x;\n    } else {\n      let bx = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = bone.data.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = bone.scaleX;\n            bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n            bone.scaleX = bx + (x - bx) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleX += (x - bone.data.scaleX) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ScaleYTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.scaleY = bone.data.scaleY;\n          return;\n        case MixBlend.first:\n          bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n      }\n      return;\n    }\n    const y = this.getCurveValue(time) * bone.data.scaleY;\n    if (alpha == 1) {\n      if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;else bone.scaleY = y;\n    } else {\n      let by = 0;\n      if (direction == MixDirection.mixOut) {\n        switch (blend) {\n          case MixBlend.setup:\n            by = bone.data.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = bone.scaleY;\n            bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.first:\n          case MixBlend.replace:\n            by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n            bone.scaleY = by + (y - by) * alpha;\n            break;\n          case MixBlend.add:\n            bone.scaleY += (y - bone.data.scaleY) * alpha;\n        }\n      }\n    }\n  }\n}\nclass ShearTimeline extends CurveTimeline2 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    let x = 0;\n    let y = 0;\n    const i = Timeline.search(frames, time, 3\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 3\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        x = frames[i + 1\n        /* VALUE1*/];\n        y = frames[i + 2\n        /* VALUE2*/];\n        const t = (time - before) / (frames[i + 3\n        /* ENTRIES*/] - before);\n        x += (frames[i + 3 + 1\n        /* VALUE1*/] - x) * t;\n        y += (frames[i + 3 + 2\n        /* VALUE2*/] - y) * t;\n        break;\n      case 1:\n        x = frames[i + 1\n        /* VALUE1*/];\n        y = frames[i + 2\n        /* VALUE2*/];\n        break;\n      default:\n        x = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        y = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n    }\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n        bone.shearY += y * alpha;\n    }\n  }\n}\nclass ShearXTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearX = bone.data.shearX;\n          return;\n        case MixBlend.first:\n          bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n      }\n      return;\n    }\n    const x = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearX = bone.data.shearX + x * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearX += x * alpha;\n    }\n  }\n}\nclass ShearYTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, boneIndex) {\n    super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);\n    this.boneIndex = 0;\n    this.boneIndex = boneIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const bone = skeleton.bones[this.boneIndex];\n    if (!bone.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.shearY = bone.data.shearY;\n          return;\n        case MixBlend.first:\n          bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n      }\n      return;\n    }\n    const y = this.getCurveValue(time);\n    switch (blend) {\n      case MixBlend.setup:\n        bone.shearY = bone.data.shearY + y * alpha;\n        break;\n      case MixBlend.first:\n      case MixBlend.replace:\n        bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n        break;\n      case MixBlend.add:\n        bone.shearY += y * alpha;\n    }\n  }\n}\nclass RGBATimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 5;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frame, time, r, g, b, a) {\n    frame *= 5;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* R*/] = r;\n    this.frames[frame + 2\n    /* G*/] = g;\n    this.frames[frame + 3\n    /* B*/] = b;\n    this.frames[frame + 4\n    /* A*/] = a;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const frames = this.frames;\n    const color = slot.color;\n    if (time < frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.setFromColor(setup);\n          return;\n        case MixBlend.first:\n          color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    const i = Timeline.search(frames, time, 5\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 5\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        a = frames[i + 4\n        /* A*/];\n        const t = (time - before) / (frames[i + 5\n        /* ENTRIES*/] - before);\n        r += (frames[i + 5 + 1\n        /* R*/] - r) * t;\n        g += (frames[i + 5 + 2\n        /* G*/] - g) * t;\n        b += (frames[i + 5 + 3\n        /* B*/] - b) * t;\n        a += (frames[i + 5 + 4\n        /* A*/] - a) * t;\n        break;\n      case 1:\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        a = frames[i + 4\n        /* A*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        g = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n        b = this.getBezierValue(time, i, 3, curveType + 18 * 2 - 2\n        /* BEZIER*/);\n        a = this.getBezierValue(time, i, 4, curveType + 18 * 3 - 2\n        /* BEZIER*/);\n    }\n    if (alpha == 1) color.set(r, g, b, a);else {\n      if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n      color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n    }\n  }\n}\nclass RGBTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 4;\n  }\n  /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n  setFrame(frame, time, r, g, b) {\n    frame <<= 2;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* R*/] = r;\n    this.frames[frame + 2\n    /* G*/] = g;\n    this.frames[frame + 3\n    /* B*/] = b;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const frames = this.frames;\n    const color = slot.color;\n    if (time < frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.r = setup.r;\n          color.g = setup.g;\n          color.b = setup.b;\n          return;\n        case MixBlend.first:\n          color.r += (setup.r - color.r) * alpha;\n          color.g += (setup.g - color.g) * alpha;\n          color.b += (setup.b - color.b) * alpha;\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    const i = Timeline.search(frames, time, 4\n    /* ENTRIES*/);\n    const curveType = this.curves[i >> 2];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        const t = (time - before) / (frames[i + 4\n        /* ENTRIES*/] - before);\n        r += (frames[i + 4 + 1\n        /* R*/] - r) * t;\n        g += (frames[i + 4 + 2\n        /* G*/] - g) * t;\n        b += (frames[i + 4 + 3\n        /* B*/] - b) * t;\n        break;\n      case 1:\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        g = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n        b = this.getBezierValue(time, i, 3, curveType + 18 * 2 - 2\n        /* BEZIER*/);\n    }\n    if (alpha == 1) {\n      color.r = r;\n      color.g = g;\n      color.b = b;\n    } else {\n      if (blend == MixBlend.setup) {\n        const setup = slot.data.color;\n        color.r = setup.r;\n        color.g = setup.g;\n        color.b = setup.b;\n      }\n      color.r += (r - color.r) * alpha;\n      color.g += (g - color.g) * alpha;\n      color.b += (b - color.b) * alpha;\n    }\n  }\n}\nclass AlphaTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const color = slot.color;\n    if (time < this.frames[0]) {\n      const setup = slot.data.color;\n      switch (blend) {\n        case MixBlend.setup:\n          color.a = setup.a;\n          return;\n        case MixBlend.first:\n          color.a += (setup.a - color.a) * alpha;\n      }\n      return;\n    }\n    const a = this.getCurveValue(time);\n    if (alpha == 1) color.a = a;else {\n      if (blend == MixBlend.setup) color.a = slot.data.color.a;\n      color.a += (a - color.a) * alpha;\n    }\n  }\n}\nclass RGBA2Timeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 8;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frame, time, r, g, b, a, r2, g2, b2) {\n    frame <<= 3;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* R*/] = r;\n    this.frames[frame + 2\n    /* G*/] = g;\n    this.frames[frame + 3\n    /* B*/] = b;\n    this.frames[frame + 4\n    /* A*/] = a;\n    this.frames[frame + 5\n    /* R2*/] = r2;\n    this.frames[frame + 6\n    /* G2*/] = g2;\n    this.frames[frame + 7\n    /* B2*/] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const frames = this.frames;\n    const light = slot.color;\n    const dark = slot.darkColor;\n    if (time < frames[0]) {\n      const setupLight = slot.data.color;\n      const setupDark = slot.data.darkColor;\n      switch (blend) {\n        case MixBlend.setup:\n          light.setFromColor(setupLight);\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n        case MixBlend.first:\n          light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let a = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    const i = Timeline.search(frames, time, 8\n    /* ENTRIES*/);\n    const curveType = this.curves[i >> 3];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        a = frames[i + 4\n        /* A*/];\n        r2 = frames[i + 5\n        /* R2*/];\n        g2 = frames[i + 6\n        /* G2*/];\n        b2 = frames[i + 7\n        /* B2*/];\n        const t = (time - before) / (frames[i + 8\n        /* ENTRIES*/] - before);\n        r += (frames[i + 8 + 1\n        /* R*/] - r) * t;\n        g += (frames[i + 8 + 2\n        /* G*/] - g) * t;\n        b += (frames[i + 8 + 3\n        /* B*/] - b) * t;\n        a += (frames[i + 8 + 4\n        /* A*/] - a) * t;\n        r2 += (frames[i + 8 + 5\n        /* R2*/] - r2) * t;\n        g2 += (frames[i + 8 + 6\n        /* G2*/] - g2) * t;\n        b2 += (frames[i + 8 + 7\n        /* B2*/] - b2) * t;\n        break;\n      case 1:\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        a = frames[i + 4\n        /* A*/];\n        r2 = frames[i + 5\n        /* R2*/];\n        g2 = frames[i + 6\n        /* G2*/];\n        b2 = frames[i + 7\n        /* B2*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        g = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n        b = this.getBezierValue(time, i, 3, curveType + 18 * 2 - 2\n        /* BEZIER*/);\n        a = this.getBezierValue(time, i, 4, curveType + 18 * 3 - 2\n        /* BEZIER*/);\n        r2 = this.getBezierValue(time, i, 5, curveType + 18 * 4 - 2\n        /* BEZIER*/);\n        g2 = this.getBezierValue(time, i, 6, curveType + 18 * 5 - 2\n        /* BEZIER*/);\n        b2 = this.getBezierValue(time, i, 7, curveType + 18 * 6 - 2\n        /* BEZIER*/);\n    }\n    if (alpha == 1) {\n      light.set(r, g, b, a);\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        light.setFromColor(slot.data.color);\n        const setupDark = slot.data.darkColor;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n      light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n}\nclass RGB2Timeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex) {\n    super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n  }\n  getFrameEntries() {\n    return 7;\n  }\n  /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n  setFrame(frame, time, r, g, b, r2, g2, b2) {\n    frame *= 7;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* R*/] = r;\n    this.frames[frame + 2\n    /* G*/] = g;\n    this.frames[frame + 3\n    /* B*/] = b;\n    this.frames[frame + 4\n    /* R2*/] = r2;\n    this.frames[frame + 5\n    /* G2*/] = g2;\n    this.frames[frame + 6\n    /* B2*/] = b2;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const frames = this.frames;\n    const light = slot.color;\n    const dark = slot.darkColor;\n    if (time < frames[0]) {\n      const setupLight = slot.data.color;\n      const setupDark = slot.data.darkColor;\n      switch (blend) {\n        case MixBlend.setup:\n          light.r = setupLight.r;\n          light.g = setupLight.g;\n          light.b = setupLight.b;\n          dark.r = setupDark.r;\n          dark.g = setupDark.g;\n          dark.b = setupDark.b;\n          return;\n        case MixBlend.first:\n          light.r += (setupLight.r - light.r) * alpha;\n          light.g += (setupLight.g - light.g) * alpha;\n          light.b += (setupLight.b - light.b) * alpha;\n          dark.r += (setupDark.r - dark.r) * alpha;\n          dark.g += (setupDark.g - dark.g) * alpha;\n          dark.b += (setupDark.b - dark.b) * alpha;\n      }\n      return;\n    }\n    let r = 0;\n    let g = 0;\n    let b = 0;\n    let r2 = 0;\n    let g2 = 0;\n    let b2 = 0;\n    const i = Timeline.search(frames, time, 7\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 7\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        r2 = frames[i + 4\n        /* R2*/];\n        g2 = frames[i + 5\n        /* G2*/];\n        b2 = frames[i + 6\n        /* B2*/];\n        const t = (time - before) / (frames[i + 7\n        /* ENTRIES*/] - before);\n        r += (frames[i + 7 + 1\n        /* R*/] - r) * t;\n        g += (frames[i + 7 + 2\n        /* G*/] - g) * t;\n        b += (frames[i + 7 + 3\n        /* B*/] - b) * t;\n        r2 += (frames[i + 7 + 4\n        /* R2*/] - r2) * t;\n        g2 += (frames[i + 7 + 5\n        /* G2*/] - g2) * t;\n        b2 += (frames[i + 7 + 6\n        /* B2*/] - b2) * t;\n        break;\n      case 1:\n        r = frames[i + 1\n        /* R*/];\n        g = frames[i + 2\n        /* G*/];\n        b = frames[i + 3\n        /* B*/];\n        r2 = frames[i + 4\n        /* R2*/];\n        g2 = frames[i + 5\n        /* G2*/];\n        b2 = frames[i + 6\n        /* B2*/];\n        break;\n      default:\n        r = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        g = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n        b = this.getBezierValue(time, i, 3, curveType + 18 * 2 - 2\n        /* BEZIER*/);\n        r2 = this.getBezierValue(time, i, 4, curveType + 18 * 3 - 2\n        /* BEZIER*/);\n        g2 = this.getBezierValue(time, i, 5, curveType + 18 * 4 - 2\n        /* BEZIER*/);\n        b2 = this.getBezierValue(time, i, 6, curveType + 18 * 5 - 2\n        /* BEZIER*/);\n    }\n    if (alpha == 1) {\n      light.r = r;\n      light.g = g;\n      light.b = b;\n      dark.r = r2;\n      dark.g = g2;\n      dark.b = b2;\n    } else {\n      if (blend == MixBlend.setup) {\n        const setupLight = slot.data.color;\n        const setupDark = slot.data.darkColor;\n        light.r = setupLight.r;\n        light.g = setupLight.g;\n        light.b = setupLight.b;\n        dark.r = setupDark.r;\n        dark.g = setupDark.g;\n        dark.b = setupDark.b;\n      }\n      light.r += (r - light.r) * alpha;\n      light.g += (g - light.g) * alpha;\n      light.b += (b - light.b) * alpha;\n      dark.r += (r2 - dark.r) * alpha;\n      dark.g += (g2 - dark.g) * alpha;\n      dark.b += (b2 - dark.b) * alpha;\n    }\n  }\n}\nclass AttachmentTimeline extends Timeline {\n  constructor(frameCount, slotIndex) {\n    super(frameCount, [`${Property.attachment}|${slotIndex}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n    this.attachmentNames = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the attachment name for the specified key frame. */\n  setFrame(frame, time, attachmentName) {\n    this.frames[frame] = time;\n    this.attachmentNames[frame] = attachmentName;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n      return;\n    }\n    this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n  }\n  setAttachment(skeleton, slot, attachmentName) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n  }\n}\nclass DeformTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, slotIndex, attachment) {\n    super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);\n    this.slotIndex = 0;\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n    this.vertices = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the vertices for the specified key frame.\n   * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n  setFrame(frame, time, vertices) {\n    this.frames[frame] = time;\n    this.vertices[frame] = vertices;\n  }\n  /** @param value1 Ignored (0 is used for a deform timeline).\n   * @param value2 Ignored (1 is used for a deform timeline). */\n  setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2) {\n    const curves = this.curves;\n    let i = this.getFrameCount() + bezier * 18;\n    if (value == 0) curves[frame] = 2 + i;\n    const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n    const tmpy = cy2 * 0.03 - cy1 * 0.06;\n    const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 6e-3;\n    const dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n    let ddx = tmpx * 2 + dddx;\n    let ddy = tmpy * 2 + dddy;\n    let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n    let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n    let x = time1 + dx;\n    let y = dy;\n    for (let n = i + 18; i < n; i += 2) {\n      curves[i] = x;\n      curves[i + 1] = y;\n      dx += ddx;\n      dy += ddy;\n      ddx += dddx;\n      ddy += dddy;\n      x += dx;\n      y += dy;\n    }\n  }\n  getCurvePercent(time, frame) {\n    const curves = this.curves;\n    let i = curves[frame];\n    switch (i) {\n      case 0:\n        const x2 = this.frames[frame];\n        return (time - x2) / (this.frames[frame + this.getFrameEntries()] - x2);\n      case 1:\n        return 0;\n    }\n    i -= 2;\n    if (curves[i] > time) {\n      const x2 = this.frames[frame];\n      return curves[i + 1] * (time - x2) / (curves[i] - x2);\n    }\n    const n = i + 18;\n    for (i += 2; i < n; i += 2) {\n      if (curves[i] >= time) {\n        const x2 = curves[i - 2];\n        const y2 = curves[i - 1];\n        return y2 + (time - x2) / (curves[i] - x2) * (curves[i + 1] - y2);\n      }\n    }\n    const x = curves[n - 2];\n    const y = curves[n - 1];\n    return y + (1 - y) * (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const slotAttachment = slot.getAttachment();\n    if (!slotAttachment) return;\n    if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != this.attachment) return;\n    const deform = slot.deform;\n    if (deform.length == 0) blend = MixBlend.setup;\n    const vertices = this.vertices;\n    const vertexCount = vertices[0].length;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          deform.length = 0;\n          return;\n        case MixBlend.first:\n          if (alpha == 1) {\n            deform.length = 0;\n            return;\n          }\n          deform.length = vertexCount;\n          const vertexAttachment = slotAttachment;\n          if (!vertexAttachment.bones) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n          } else {\n            alpha = 1 - alpha;\n            for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\n          }\n      }\n      return;\n    }\n    deform.length = vertexCount;\n    if (time >= frames[frames.length - 1]) {\n      const lastVertices = vertices[frames.length - 1];\n      if (alpha == 1) {\n        if (blend == MixBlend.add) {\n          const vertexAttachment = slotAttachment;\n          if (!vertexAttachment.bones) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\n          } else {\n            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n          }\n        } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n      } else {\n        switch (blend) {\n          case MixBlend.setup:\n            {\n              const vertexAttachment2 = slotAttachment;\n              if (!vertexAttachment2.bones) {\n                const setupVertices = vertexAttachment2.vertices;\n                for (let i = 0; i < vertexCount; i++) {\n                  const setup = setupVertices[i];\n                  deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                }\n              } else {\n                for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n              }\n              break;\n            }\n          case MixBlend.first:\n          case MixBlend.replace:\n            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n            break;\n          case MixBlend.add:\n            const vertexAttachment = slotAttachment;\n            if (!vertexAttachment.bones) {\n              const setupVertices = vertexAttachment.vertices;\n              for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n            } else {\n              for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n            }\n        }\n      }\n      return;\n    }\n    const frame = Timeline.search1(frames, time);\n    const percent = this.getCurvePercent(time, frame);\n    const prevVertices = vertices[frame];\n    const nextVertices = vertices[frame + 1];\n    if (alpha == 1) {\n      if (blend == MixBlend.add) {\n        const vertexAttachment = slotAttachment;\n        if (!vertexAttachment.bones) {\n          const setupVertices = vertexAttachment.vertices;\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n          }\n        } else {\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += prev + (nextVertices[i] - prev) * percent;\n          }\n        }\n      } else {\n        for (let i = 0; i < vertexCount; i++) {\n          const prev = prevVertices[i];\n          deform[i] = prev + (nextVertices[i] - prev) * percent;\n        }\n      }\n    } else {\n      switch (blend) {\n        case MixBlend.setup:\n          {\n            const vertexAttachment2 = slotAttachment;\n            if (!vertexAttachment2.bones) {\n              const setupVertices = vertexAttachment2.vertices;\n              for (let i = 0; i < vertexCount; i++) {\n                const prev = prevVertices[i];\n                const setup = setupVertices[i];\n                deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n              }\n            } else {\n              for (let i = 0; i < vertexCount; i++) {\n                const prev = prevVertices[i];\n                deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n              }\n            }\n            break;\n          }\n        case MixBlend.first:\n        case MixBlend.replace:\n          for (let i = 0; i < vertexCount; i++) {\n            const prev = prevVertices[i];\n            deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n          }\n          break;\n        case MixBlend.add:\n          const vertexAttachment = slotAttachment;\n          if (!vertexAttachment.bones) {\n            const setupVertices = vertexAttachment.vertices;\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n            }\n          } else {\n            for (let i = 0; i < vertexCount; i++) {\n              const prev = prevVertices[i];\n              deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n            }\n          }\n      }\n    }\n  }\n}\nconst _EventTimeline = class extends Timeline {\n  constructor(frameCount) {\n    super(frameCount, _EventTimeline.propertyIds);\n    this.events = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the event for the specified key frame. */\n  setFrame(frame, event) {\n    this.frames[frame] = event.time;\n    this.events[frame] = event;\n  }\n  /** Fires events for frames > `lastTime` and <= `time`. */\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (!firedEvents) return;\n    const frames = this.frames;\n    const frameCount = this.frames.length;\n    if (lastTime > time) {\n      this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n      lastTime = -1;\n    } else if (lastTime >= frames[frameCount - 1]) return;\n    if (time < frames[0]) return;\n    let i = 0;\n    if (lastTime < frames[0]) i = 0;else {\n      i = Timeline.search1(frames, lastTime) + 1;\n      const frameTime = frames[i];\n      while (i > 0) {\n        if (frames[i - 1] != frameTime) break;\n        i--;\n      }\n    }\n    for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\n  }\n};\nlet EventTimeline = _EventTimeline;\nEventTimeline.propertyIds = [`${Property.event}`];\nconst _DrawOrderTimeline = class extends Timeline {\n  constructor(frameCount) {\n    super(frameCount, _DrawOrderTimeline.propertyIds);\n    this.drawOrders = new Array(frameCount);\n  }\n  getFrameCount() {\n    return this.frames.length;\n  }\n  /** Sets the time in seconds and the draw order for the specified key frame.\n   * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n   *           draw order. */\n  setFrame(frame, time, drawOrder) {\n    this.frames[frame] = time;\n    this.drawOrders[frame] = drawOrder;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    if (direction == MixDirection.mixOut) {\n      if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    if (time < this.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n      return;\n    }\n    const idx = Timeline.search1(this.frames, time);\n    const drawOrderToSetupIndex = this.drawOrders[idx];\n    if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);else {\n      const drawOrder = skeleton.drawOrder;\n      const slots = skeleton.slots;\n      for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n    }\n  }\n};\nlet DrawOrderTimeline = _DrawOrderTimeline;\nDrawOrderTimeline.propertyIds = [`${Property.drawOrder}`];\nclass IkConstraintTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, ikConstraintIndex) {\n    super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n    this.ikConstraintIndex = 0;\n    this.ikConstraintIndex = ikConstraintIndex;\n  }\n  getFrameEntries() {\n    return 6;\n  }\n  /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n  setFrame(frame, time, mix, softness, bendDirection, compress, stretch) {\n    frame *= 6;\n    this.frames[frame] = time;\n    this.frames[frame + 1\n    /* MIX*/] = mix;\n    this.frames[frame + 2\n    /* SOFTNESS*/] = softness;\n    this.frames[frame + 3\n    /* BEND_DIRECTION*/] = bendDirection;\n    this.frames[frame + 4\n    /* COMPRESS*/] = compress ? 1 : 0;\n    this.frames[frame + 5\n    /* STRETCH*/] = stretch ? 1 : 0;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.ikConstraints[this.ikConstraintIndex];\n    if (!constraint.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mix = constraint.data.mix;\n          constraint.softness = constraint.data.softness;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n          return;\n        case MixBlend.first:\n          constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n          constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n          constraint.bendDirection = constraint.data.bendDirection;\n          constraint.compress = constraint.data.compress;\n          constraint.stretch = constraint.data.stretch;\n      }\n      return;\n    }\n    let mix = 0;\n    let softness = 0;\n    const i = Timeline.search(frames, time, 6\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 6\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        mix = frames[i + 1\n        /* MIX*/];\n        softness = frames[i + 2\n        /* SOFTNESS*/];\n        const t = (time - before) / (frames[i + 6\n        /* ENTRIES*/] - before);\n        mix += (frames[i + 6 + 1\n        /* MIX*/] - mix) * t;\n        softness += (frames[i + 6 + 2\n        /* SOFTNESS*/] - softness) * t;\n        break;\n      case 1:\n        mix = frames[i + 1\n        /* MIX*/];\n        softness = frames[i + 2\n        /* SOFTNESS*/];\n        break;\n      default:\n        mix = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        softness = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n    }\n    if (blend == MixBlend.setup) {\n      constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n      constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n      if (direction == MixDirection.mixOut) {\n        constraint.bendDirection = constraint.data.bendDirection;\n        constraint.compress = constraint.data.compress;\n        constraint.stretch = constraint.data.stretch;\n      } else {\n        constraint.bendDirection = frames[i + 3\n        /* BEND_DIRECTION*/];\n        constraint.compress = frames[i + 4\n        /* COMPRESS*/] != 0;\n        constraint.stretch = frames[i + 5\n        /* STRETCH*/] != 0;\n      }\n    } else {\n      constraint.mix += (mix - constraint.mix) * alpha;\n      constraint.softness += (softness - constraint.softness) * alpha;\n      if (direction == MixDirection.mixIn) {\n        constraint.bendDirection = frames[i + 3\n        /* BEND_DIRECTION*/];\n        constraint.compress = frames[i + 4\n        /* COMPRESS*/] != 0;\n        constraint.stretch = frames[i + 5\n        /* STRETCH*/] != 0;\n      }\n    }\n  }\n}\nclass TransformConstraintTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, transformConstraintIndex) {\n    super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n    this.transformConstraintIndex = 0;\n    this.transformConstraintIndex = transformConstraintIndex;\n  }\n  getFrameEntries() {\n    return 7;\n  }\n  /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n  setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY) {\n    const frames = this.frames;\n    frame *= 7;\n    frames[frame] = time;\n    frames[frame + 1\n    /* ROTATE*/] = mixRotate;\n    frames[frame + 2\n    /* X*/] = mixX;\n    frames[frame + 3\n    /* Y*/] = mixY;\n    frames[frame + 4\n    /* SCALEX*/] = mixScaleX;\n    frames[frame + 5\n    /* SCALEY*/] = mixScaleY;\n    frames[frame + 6\n    /* SHEARY*/] = mixShearY;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.transformConstraints[this.transformConstraintIndex];\n    if (!constraint.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      const data = constraint.data;\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = data.mixRotate;\n          constraint.mixX = data.mixX;\n          constraint.mixY = data.mixY;\n          constraint.mixScaleX = data.mixScaleX;\n          constraint.mixScaleY = data.mixScaleY;\n          constraint.mixShearY = data.mixShearY;\n          return;\n        case MixBlend.first:\n          constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n          constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n          constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n          constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n      }\n      return;\n    }\n    let rotate;\n    let x;\n    let y;\n    let scaleX;\n    let scaleY;\n    let shearY;\n    const i = Timeline.search(frames, time, 7\n    /* ENTRIES*/);\n    const curveType = this.curves[i / 7\n    /* ENTRIES*/];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        rotate = frames[i + 1\n        /* ROTATE*/];\n        x = frames[i + 2\n        /* X*/];\n        y = frames[i + 3\n        /* Y*/];\n        scaleX = frames[i + 4\n        /* SCALEX*/];\n        scaleY = frames[i + 5\n        /* SCALEY*/];\n        shearY = frames[i + 6\n        /* SHEARY*/];\n        const t = (time - before) / (frames[i + 7\n        /* ENTRIES*/] - before);\n        rotate += (frames[i + 7 + 1\n        /* ROTATE*/] - rotate) * t;\n        x += (frames[i + 7 + 2\n        /* X*/] - x) * t;\n        y += (frames[i + 7 + 3\n        /* Y*/] - y) * t;\n        scaleX += (frames[i + 7 + 4\n        /* SCALEX*/] - scaleX) * t;\n        scaleY += (frames[i + 7 + 5\n        /* SCALEY*/] - scaleY) * t;\n        shearY += (frames[i + 7 + 6\n        /* SHEARY*/] - shearY) * t;\n        break;\n      case 1:\n        rotate = frames[i + 1\n        /* ROTATE*/];\n        x = frames[i + 2\n        /* X*/];\n        y = frames[i + 3\n        /* Y*/];\n        scaleX = frames[i + 4\n        /* SCALEX*/];\n        scaleY = frames[i + 5\n        /* SCALEY*/];\n        shearY = frames[i + 6\n        /* SHEARY*/];\n        break;\n      default:\n        rotate = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        x = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n        y = this.getBezierValue(time, i, 3, curveType + 18 * 2 - 2\n        /* BEZIER*/);\n        scaleX = this.getBezierValue(time, i, 4, curveType + 18 * 3 - 2\n        /* BEZIER*/);\n        scaleY = this.getBezierValue(time, i, 5, curveType + 18 * 4 - 2\n        /* BEZIER*/);\n        shearY = this.getBezierValue(time, i, 6, curveType + 18 * 5 - 2\n        /* BEZIER*/);\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n      constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n      constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n      constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n      constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n      constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n      constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n    }\n  }\n}\nclass PathConstraintPositionTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n    this.pathConstraintIndex = 0;\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.position = constraint.data.position;\n          return;\n        case MixBlend.first:\n          constraint.position += (constraint.data.position - constraint.position) * alpha;\n      }\n      return;\n    }\n    const position = this.getCurveValue(time);\n    if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;else constraint.position += (position - constraint.position) * alpha;\n  }\n}\nclass PathConstraintSpacingTimeline extends CurveTimeline1 {\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    this.pathConstraintIndex = 0;\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.spacing = constraint.data.spacing;\n          return;\n        case MixBlend.first:\n          constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n      }\n      return;\n    }\n    const spacing = this.getCurveValue(time);\n    if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;else constraint.spacing += (spacing - constraint.spacing) * alpha;\n  }\n}\nclass PathConstraintMixTimeline extends CurveTimeline {\n  constructor(frameCount, bezierCount, pathConstraintIndex) {\n    super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    this.pathConstraintIndex = 0;\n    this.pathConstraintIndex = pathConstraintIndex;\n  }\n  getFrameEntries() {\n    return 4;\n  }\n  setFrame(frame, time, mixRotate, mixX, mixY) {\n    const frames = this.frames;\n    frame <<= 2;\n    frames[frame] = time;\n    frames[frame + 1\n    /* ROTATE*/] = mixRotate;\n    frames[frame + 2\n    /* X*/] = mixX;\n    frames[frame + 3\n    /* Y*/] = mixY;\n  }\n  apply(skeleton, lastTime, time, firedEvents, alpha, blend, direction) {\n    const constraint = skeleton.pathConstraints[this.pathConstraintIndex];\n    if (!constraint.active) return;\n    const frames = this.frames;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          constraint.mixRotate = constraint.data.mixRotate;\n          constraint.mixX = constraint.data.mixX;\n          constraint.mixY = constraint.data.mixY;\n          return;\n        case MixBlend.first:\n          constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n          constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n          constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n      }\n      return;\n    }\n    let rotate;\n    let x;\n    let y;\n    const i = Timeline.search(frames, time, 4\n    /* ENTRIES*/);\n    const curveType = this.curves[i >> 2];\n    switch (curveType) {\n      case 0:\n        const before = frames[i];\n        rotate = frames[i + 1\n        /* ROTATE*/];\n        x = frames[i + 2\n        /* X*/];\n        y = frames[i + 3\n        /* Y*/];\n        const t = (time - before) / (frames[i + 4\n        /* ENTRIES*/] - before);\n        rotate += (frames[i + 4 + 1\n        /* ROTATE*/] - rotate) * t;\n        x += (frames[i + 4 + 2\n        /* X*/] - x) * t;\n        y += (frames[i + 4 + 3\n        /* Y*/] - y) * t;\n        break;\n      case 1:\n        rotate = frames[i + 1\n        /* ROTATE*/];\n        x = frames[i + 2\n        /* X*/];\n        y = frames[i + 3\n        /* Y*/];\n        break;\n      default:\n        rotate = this.getBezierValue(time, i, 1, curveType - 2\n        /* BEZIER*/);\n        x = this.getBezierValue(time, i, 2, curveType + 18 - 2\n        /* BEZIER*/);\n        y = this.getBezierValue(time, i, 3, curveType + 18 * 2 - 2\n        /* BEZIER*/);\n    }\n    if (blend == MixBlend.setup) {\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n      constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n      constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n    } else {\n      constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n      constraint.mixX += (x - constraint.mixX) * alpha;\n      constraint.mixY += (y - constraint.mixY) * alpha;\n    }\n  }\n}\nconst _SequenceTimeline = class extends Timeline {\n  constructor(frameCount, slotIndex, attachment) {\n    super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);\n    this.slotIndex = slotIndex;\n    this.attachment = attachment;\n  }\n  getFrameEntries() {\n    return _SequenceTimeline.ENTRIES;\n  }\n  getSlotIndex() {\n    return this.slotIndex;\n  }\n  getAttachment() {\n    return this.attachment;\n  }\n  /** Sets the time, mode, index, and frame time for the specified frame.\n   * @param frame Between 0 and <code>frameCount</code>, inclusive.\n   * @param time Seconds between frames. */\n  setFrame(frame, time, mode, index, delay) {\n    const frames = this.frames;\n    frame *= _SequenceTimeline.ENTRIES;\n    frames[frame] = time;\n    frames[frame + _SequenceTimeline.MODE] = mode | index << 4;\n    frames[frame + _SequenceTimeline.DELAY] = delay;\n  }\n  apply(skeleton, lastTime, time, events, alpha, blend, direction) {\n    const slot = skeleton.slots[this.slotIndex];\n    if (!slot.bone.active) return;\n    const slotAttachment = slot.attachment;\n    const attachment = this.attachment;\n    if (slotAttachment != attachment) {\n      if (!(slotAttachment instanceof VertexAttachment) || slotAttachment.timelineAttachment != attachment) return;\n    }\n    const frames = this.frames;\n    if (time < frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\n      return;\n    }\n    const i = Timeline.search(frames, time, _SequenceTimeline.ENTRIES);\n    const before = frames[i];\n    const modeAndIndex = frames[i + _SequenceTimeline.MODE];\n    const delay = frames[i + _SequenceTimeline.DELAY];\n    if (!this.attachment.sequence) return;\n    let index = modeAndIndex >> 4;\n    const count = this.attachment.sequence.regions.length;\n    const mode = SequenceModeValues[modeAndIndex & 15];\n    if (mode != SequenceMode.hold) {\n      index += (time - before) / delay + 1e-5 | 0;\n      switch (mode) {\n        case SequenceMode.once:\n          index = Math.min(count - 1, index);\n          break;\n        case SequenceMode.loop:\n          index %= count;\n          break;\n        case SequenceMode.pingpong:\n          {\n            const n = (count << 1) - 2;\n            index = n == 0 ? 0 : index % n;\n            if (index >= count) index = n - index;\n            break;\n          }\n        case SequenceMode.onceReverse:\n          index = Math.max(count - 1 - index, 0);\n          break;\n        case SequenceMode.loopReverse:\n          index = count - 1 - index % count;\n          break;\n        case SequenceMode.pingpongReverse:\n          {\n            const n = (count << 1) - 2;\n            index = n == 0 ? 0 : (index + count - 1) % n;\n            if (index >= count) index = n - index;\n          }\n      }\n    }\n    slot.sequenceIndex = index;\n  }\n};\nlet SequenceTimeline = _SequenceTimeline;\nSequenceTimeline.ENTRIES = 3;\nSequenceTimeline.MODE = 1;\nSequenceTimeline.DELAY = 2;\nexport { AlphaTimeline, Animation, AttachmentTimeline, CurveTimeline, CurveTimeline1, CurveTimeline2, DeformTimeline, DrawOrderTimeline, EventTimeline, IkConstraintTimeline, PathConstraintMixTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, RGB2Timeline, RGBA2Timeline, RGBATimeline, RGBTimeline, RotateTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, SequenceTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, Timeline, TransformConstraintTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline };","map":{"version":3,"names":["Animation","constructor","name","timelines","duration","timelineIds","StringSet","Error","setTimelines","clear","i","length","addAll","getPropertyIds","hasTimeline","ids","contains","apply","skeleton","lastTime","time","loop","events","alpha","blend","direction","n","Property","rotate","x","y","scaleX","scaleY","shearX","shearY","rgb","rgb2","attachment","deform","event","drawOrder","ikConstraint","transformConstraint","pathConstraintPosition","pathConstraintSpacing","pathConstraintMix","sequence","Timeline","frameCount","propertyIds","frames","Utils","newFloatArray","getFrameEntries","getFrameCount","getDuration","search1","search","step","CurveTimeline","bezierCount","curves","setLinear","frame","setStepped","shrink","size","newCurves","arrayCopy","setBezier","bezier","value","time1","value1","cx1","cy1","cx2","cy2","time2","value2","tmpx","tmpy","dddx","dddy","ddx","ddy","dx","dy","getBezierValue","frameIndex","valueOffset","x2","y2","CurveTimeline1","propertyId","setFrame","getCurveValue","ii","curveType","before","CurveTimeline2","propertyId1","propertyId2","RotateTimeline","boneIndex","bone","bones","active","MixBlend","setup","rotation","data","first","r","replace","add","TranslateTimeline","t","TranslateXTimeline","TranslateYTimeline","ScaleTimeline","bx","by","MixDirection","mixOut","Math","abs","MathUtils","signum","ScaleXTimeline","ScaleYTimeline","ShearTimeline","ShearXTimeline","ShearYTimeline","RGBATimeline","slotIndex","g","b","a","slot","slots","color","setFromColor","set","RGBTimeline","AlphaTimeline","RGBA2Timeline","r2","g2","b2","light","dark","darkColor","setupLight","setupDark","RGB2Timeline","AttachmentTimeline","attachmentNames","Array","attachmentName","setAttachment","getAttachment","DeformTimeline","id","vertices","getCurvePercent","firedEvents","slotAttachment","VertexAttachment","timelineAttachment","vertexCount","vertexAttachment","setupVertices","lastVertices","vertexAttachment2","percent","prevVertices","nextVertices","prev","_EventTimeline","Number","MAX_VALUE","frameTime","push","EventTimeline","_DrawOrderTimeline","drawOrders","idx","drawOrderToSetupIndex","DrawOrderTimeline","IkConstraintTimeline","ikConstraintIndex","mix","softness","bendDirection","compress","stretch","constraint","ikConstraints","mixIn","TransformConstraintTimeline","transformConstraintIndex","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","transformConstraints","PathConstraintPositionTimeline","pathConstraintIndex","pathConstraints","position","PathConstraintSpacingTimeline","spacing","PathConstraintMixTimeline","_SequenceTimeline","ENTRIES","getSlotIndex","mode","index","delay","MODE","DELAY","sequenceIndex","modeAndIndex","count","regions","SequenceModeValues","SequenceMode","hold","once","min","pingpong","onceReverse","max","loopReverse","pingpongReverse","SequenceTimeline"],"sources":["../../src/core/Animation.ts"],"sourcesContent":["import type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport { Attachment, VertexAttachment } from './attachments';\nimport { NumberArrayLike, IAnimation, ITimeline, MathUtils, MixBlend, StringSet, Utils, MixDirection, IHasTextureRegion } from '@pixi-spine/base';\nimport type { Slot } from './Slot';\nimport type { IkConstraint } from './IkConstraint';\nimport type { TransformConstraint } from './TransformConstraint';\nimport type { PathConstraint } from './PathConstraint';\nimport { SequenceMode, SequenceModeValues } from './attachments/Sequence';\n\n/**\n * A simple container for a list of timelines and a name.\n * @public\n * */\nexport class Animation implements IAnimation<Timeline> {\n    /** The animation's name, which is unique across all animations in the skeleton. */\n    name: string;\n    timelines: Array<Timeline> = [];\n    timelineIds: StringSet = new StringSet();\n\n    /** The duration of the animation in seconds, which is the highest time of all keys in the timeline. */\n    duration: number;\n\n    constructor(name: string, timelines: Array<Timeline>, duration: number) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n        this.setTimelines(timelines);\n        this.duration = duration;\n    }\n\n    setTimelines(timelines: Array<Timeline>) {\n        if (!timelines) throw new Error('timelines cannot be null.');\n        this.timelines = timelines;\n        this.timelineIds.clear();\n        for (let i = 0; i < timelines.length; i++) this.timelineIds.addAll(timelines[i].getPropertyIds());\n    }\n\n    hasTimeline(ids: string[]): boolean {\n        for (let i = 0; i < ids.length; i++) if (this.timelineIds.contains(ids[i])) return true;\n\n        return false;\n    }\n\n    /** Applies all the animation's timelines to the specified skeleton.\n     *\n     * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n     * @param loop If true, the animation repeats after {@link #getDuration()}.\n     * @param events May be null to ignore fired events. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, loop: boolean, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n\n        if (loop && this.duration != 0) {\n            time %= this.duration;\n            if (lastTime > 0) lastTime %= this.duration;\n        }\n\n        const timelines = this.timelines;\n\n        for (let i = 0, n = timelines.length; i < n; i++) timelines[i].apply(skeleton, lastTime, time, events, alpha, blend, direction);\n    }\n}\n\nconst Property = {\n    rotate: 0,\n    x: 1,\n    y: 2,\n    scaleX: 3,\n    scaleY: 4,\n    shearX: 5,\n    shearY: 6,\n\n    rgb: 7,\n    alpha: 8,\n    rgb2: 9,\n\n    attachment: 10,\n    deform: 11,\n\n    event: 12,\n    drawOrder: 13,\n\n    ikConstraint: 14,\n    transformConstraint: 15,\n\n    pathConstraintPosition: 16,\n    pathConstraintSpacing: 17,\n    pathConstraintMix: 18,\n\n    sequence: 19,\n};\n\n/** The interface for all timelines.\n * @public\n * */\nexport abstract class Timeline implements ITimeline {\n    propertyIds: string[];\n    frames: NumberArrayLike;\n\n    constructor(frameCount: number, propertyIds: string[]) {\n        this.propertyIds = propertyIds;\n        this.frames = Utils.newFloatArray(frameCount * this.getFrameEntries());\n    }\n\n    getPropertyIds() {\n        return this.propertyIds;\n    }\n\n    getFrameEntries(): number {\n        return 1;\n    }\n\n    getFrameCount() {\n        return this.frames.length / this.getFrameEntries();\n    }\n\n    getDuration(): number {\n        return this.frames[this.frames.length - this.getFrameEntries()];\n    }\n\n    abstract apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection): void;\n\n    static search1(frames: NumberArrayLike, time: number) {\n        const n = frames.length;\n\n        for (let i = 1; i < n; i++) if (frames[i] > time) return i - 1;\n\n        return n - 1;\n    }\n\n    static search(frames: NumberArrayLike, time: number, step: number) {\n        const n = frames.length;\n\n        for (let i = step; i < n; i += step) if (frames[i] > time) return i - step;\n\n        return n - step;\n    }\n}\n\n/**\n * @public\n */\nexport interface BoneTimeline {\n    /** The index of the bone in {@link Skeleton#bones} that will be changed. */\n    boneIndex: number;\n}\n\n/**\n * @public\n */\nexport interface SlotTimeline {\n    /** The index of the slot in {@link Skeleton#slots} that will be changed. */\n    slotIndex: number;\n}\n\n/** The base class for timelines that use interpolation between key frame values.\n * @public\n * */\nexport abstract class CurveTimeline extends Timeline {\n    protected curves: NumberArrayLike; // type, x, y, ...\n\n    constructor(frameCount: number, bezierCount: number, propertyIds: string[]) {\n        super(frameCount, propertyIds);\n        this.curves = Utils.newFloatArray(frameCount + bezierCount * 18 /* BEZIER_SIZE*/);\n        this.curves[frameCount - 1] = 1 /* STEPPED*/;\n    }\n\n    /** Sets the specified key frame to linear interpolation. */\n    setLinear(frame: number) {\n        this.curves[frame] = 0 /* LINEAR*/;\n    }\n\n    /** Sets the specified key frame to stepped interpolation. */\n    setStepped(frame: number) {\n        this.curves[frame] = 1 /* STEPPED*/;\n    }\n\n    /** Shrinks the storage for Bezier curves, for use when <code>bezierCount</code> (specified in the constructor) was larger\n     * than the actual number of Bezier curves. */\n    shrink(bezierCount: number) {\n        const size = this.getFrameCount() + bezierCount * 18; /* BEZIER_SIZE*/\n\n        if (this.curves.length > size) {\n            const newCurves = Utils.newFloatArray(size);\n\n            Utils.arrayCopy(this.curves, 0, newCurves, 0, size);\n            this.curves = newCurves;\n        }\n    }\n\n    /** Stores the segments for the specified Bezier curve. For timelines that modify multiple values, there may be more than\n     * one curve per frame.\n     * @param bezier The ordinal of this Bezier curve for this timeline, between 0 and <code>bezierCount - 1</code> (specified\n     *           in the constructor), inclusive.\n     * @param frame Between 0 and <code>frameCount - 1</code>, inclusive.\n     * @param value The index of the value for this frame that this curve is used for.\n     * @param time1 The time for the first key.\n     * @param value1 The value for the first key.\n     * @param cx1 The time for the first Bezier handle.\n     * @param cy1 The value for the first Bezier handle.\n     * @param cx2 The time of the second Bezier handle.\n     * @param cy2 The value for the second Bezier handle.\n     * @param time2 The time for the second key.\n     * @param value2 The value for the second key. */\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\n        const curves = this.curves;\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\n\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n        const tmpy = (value1 - cy1 * 2 + cy2) * 0.03;\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\n        const dddy = ((cy1 - cy2) * 3 - value1 + value2) * 0.006;\n        let ddx = tmpx * 2 + dddx;\n        let ddy = tmpy * 2 + dddy;\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n        let dy = (cy1 - value1) * 0.3 + tmpy + dddy * 0.16666667;\n        let x = time1 + dx;\n        let y = value1 + dy;\n\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dx += ddx;\n            dy += ddy;\n            ddx += dddx;\n            ddy += dddy;\n            x += dx;\n            y += dy;\n        }\n    }\n\n    /** Returns the Bezier interpolated value for the specified time.\n     * @param frameIndex The index into {@link #getFrames()} for the values of the frame before <code>time</code>.\n     * @param valueOffset The offset from <code>frameIndex</code> to the value this curve is used for.\n     * @param i The index of the Bezier segments. See {@link #getCurveType(int)}. */\n    getBezierValue(time: number, frameIndex: number, valueOffset: number, i: number) {\n        const curves = this.curves;\n\n        if (curves[i] > time) {\n            const x = this.frames[frameIndex];\n            const y = this.frames[frameIndex + valueOffset];\n\n            return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n        }\n        const n = i + 18; /* BEZIER_SIZE*/\n\n        for (i += 2; i < n; i += 2) {\n            if (curves[i] >= time) {\n                const x = curves[i - 2];\n                const y = curves[i - 1];\n\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n            }\n        }\n        frameIndex += this.getFrameEntries();\n        const x = curves[n - 2];\n        const y = curves[n - 1];\n\n        return y + ((time - x) / (this.frames[frameIndex] - x)) * (this.frames[frameIndex + valueOffset] - y);\n    }\n}\n/**\n * @public\n */\nexport abstract class CurveTimeline1 extends CurveTimeline {\n    constructor(frameCount: number, bezierCount: number, propertyId: string) {\n        super(frameCount, bezierCount, [propertyId]);\n    }\n\n    getFrameEntries() {\n        return 2 /* ENTRIES*/;\n    }\n\n    /** Sets the time and value for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time The frame time in seconds. */\n    setFrame(frame: number, time: number, value: number) {\n        frame <<= 1;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* VALUE*/] = value;\n    }\n\n    /** Returns the interpolated value for the specified time. */\n    getCurveValue(time: number) {\n        const frames = this.frames;\n        let i = frames.length - 2;\n\n        for (let ii = 2; ii <= i; ii += 2) {\n            if (frames[ii] > time) {\n                i = ii - 2;\n                break;\n            }\n        }\n\n        const curveType = this.curves[i >> 1];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n                const value = frames[i + 1 /* VALUE*/];\n\n                return value + ((time - before) / (frames[i + 2 /* ENTRIES*/] - before)) * (frames[i + 2 /* ENTRIES*/ + 1 /* VALUE*/] - value);\n            case 1 /* STEPPED*/:\n                return frames[i + 1 /* VALUE*/];\n        }\n\n        return this.getBezierValue(time, i, 1 /* VALUE*/, curveType - 2 /* BEZIER*/);\n    }\n}\n\n/** The base class for a {@link CurveTimeline} which sets two properties.\n * @public\n * */\nexport abstract class CurveTimeline2 extends CurveTimeline {\n    /** @param bezierCount The maximum number of Bezier curves. See {@link #shrink(int)}.\n     * @param propertyIds Unique identifiers for the properties the timeline modifies. */\n    constructor(frameCount: number, bezierCount: number, propertyId1: string, propertyId2: string) {\n        super(frameCount, bezierCount, [propertyId1, propertyId2]);\n    }\n\n    getFrameEntries() {\n        return 3 /* ENTRIES*/;\n    }\n\n    /** Sets the time and values for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time The frame time in seconds. */\n    setFrame(frame: number, time: number, value1: number, value2: number) {\n        frame *= 3 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* VALUE1*/] = value1;\n        this.frames[frame + 2 /* VALUE2*/] = value2;\n    }\n}\n\n/** Changes a bone's local {@link Bone#rotation}.\n * @public\n * */\nexport class RotateTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.rotate}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event> | null, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n\n                    return;\n                case MixBlend.first:\n                    bone.rotation += (bone.data.rotation - bone.rotation) * alpha;\n            }\n\n            return;\n        }\n\n        let r = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.rotation = bone.data.rotation + r * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                r += bone.data.rotation - bone.rotation;\n            case MixBlend.add:\n                bone.rotation += r * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x} and {@link Bone#y}.\n * @public\n * */\nexport class TranslateTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`, `${Property.y}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x}.\n * @public\n * */\nexport class TranslateXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.x}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.x = bone.data.x;\n\n                    return;\n                case MixBlend.first:\n                    bone.x += (bone.data.x - bone.x) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.x = bone.data.x + x * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.x += (bone.data.x + x - bone.x) * alpha;\n                break;\n            case MixBlend.add:\n                bone.x += x * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#x}.\n * @public\n * */\nexport class TranslateYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.y}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.y = bone.data.y;\n\n                    return;\n                case MixBlend.first:\n                    bone.y += (bone.data.y - bone.y) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.y = bone.data.y + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.y += (bone.data.y + y - bone.y) * alpha;\n                break;\n            case MixBlend.add:\n                bone.y += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`, `${Property.scaleY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        let x;\n        let y;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n        x *= bone.data.scaleX;\n        y *= bone.data.scaleY;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                bone.scaleX += x - bone.data.scaleX;\n                bone.scaleY += y - bone.data.scaleY;\n            } else {\n                bone.scaleX = x;\n                bone.scaleY = y;\n            }\n        } else {\n            let bx = 0;\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        by = bone.data.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        by = bone.scaleY;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleX}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleX = bone.data.scaleX;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleX += (bone.data.scaleX - bone.scaleX) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time) * bone.data.scaleX;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) bone.scaleX += x - bone.data.scaleX;\n            else bone.scaleX = x;\n        } else {\n            // Mixing out uses sign of setup or current pose, else use sign of key.\n            let bx = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = bone.data.scaleX;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = bone.scaleX;\n                        bone.scaleX = bx + (Math.abs(x) * MathUtils.signum(bx) - bx) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        bx = Math.abs(bone.data.scaleX) * MathUtils.signum(x);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        bx = Math.abs(bone.scaleX) * MathUtils.signum(x);\n                        bone.scaleX = bx + (x - bx) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleX += (x - bone.data.scaleX) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#scaleX)} and {@link Bone#scaleY}.\n * @public\n * */\nexport class ScaleYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.scaleY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.scaleY = bone.data.scaleY;\n\n                    return;\n                case MixBlend.first:\n                    bone.scaleY += (bone.data.scaleY - bone.scaleY) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time) * bone.data.scaleY;\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) bone.scaleY += y - bone.data.scaleY;\n            else bone.scaleY = y;\n        } else {\n            // Mixing out uses sign of setup or current pose, else use sign of key.\n            let by = 0;\n\n            if (direction == MixDirection.mixOut) {\n                switch (blend) {\n                    case MixBlend.setup:\n                        by = bone.data.scaleY;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        by = bone.scaleY;\n                        bone.scaleY = by + (Math.abs(y) * MathUtils.signum(by) - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            } else {\n                switch (blend) {\n                    case MixBlend.setup:\n                        by = Math.abs(bone.data.scaleY) * MathUtils.signum(y);\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        by = Math.abs(bone.scaleY) * MathUtils.signum(y);\n                        bone.scaleY = by + (y - by) * alpha;\n                        break;\n                    case MixBlend.add:\n                        bone.scaleY += (y - bone.data.scaleY) * alpha;\n                }\n            }\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearTimeline extends CurveTimeline2 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`, `${Property.shearY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        let x = 0;\n        let y = 0;\n        const i = Timeline.search(frames, time, 3 /* ENTRIES*/);\n        const curveType = this.curves[i / 3 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                const t = (time - before) / (frames[i + 3 /* ENTRIES*/] - before);\n\n                x += (frames[i + 3 /* ENTRIES*/ + 1 /* VALUE1*/] - x) * t;\n                y += (frames[i + 3 /* ENTRIES*/ + 2 /* VALUE2*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                x = frames[i + 1 /* VALUE1*/];\n                y = frames[i + 2 /* VALUE2*/];\n                break;\n            default:\n                x = this.getBezierValue(time, i, 1 /* VALUE1*/, curveType - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 2 /* VALUE2*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearXTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearX}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearX = bone.data.shearX;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearX += (bone.data.shearX - bone.shearX) * alpha;\n            }\n\n            return;\n        }\n\n        const x = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearX = bone.data.shearX + x * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearX += (bone.data.shearX + x - bone.shearX) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearX += x * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class ShearYTimeline extends CurveTimeline1 implements BoneTimeline {\n    boneIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, boneIndex: number) {\n        super(frameCount, bezierCount, `${Property.shearY}|${boneIndex}`);\n        this.boneIndex = boneIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const bone = skeleton.bones[this.boneIndex];\n\n        if (!bone.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.shearY = bone.data.shearY;\n\n                    return;\n                case MixBlend.first:\n                    bone.shearY += (bone.data.shearY - bone.shearY) * alpha;\n            }\n\n            return;\n        }\n\n        const y = this.getCurveValue(time);\n\n        switch (blend) {\n            case MixBlend.setup:\n                bone.shearY = bone.data.shearY + y * alpha;\n                break;\n            case MixBlend.first:\n            case MixBlend.replace:\n                bone.shearY += (bone.data.shearY + y - bone.shearY) * alpha;\n                break;\n            case MixBlend.add:\n                bone.shearY += y * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}.\n * @public\n * */\nexport class RGBATimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 5 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number) {\n        frame *= 5 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* A*/] = a;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const color = slot.color;\n\n        if (time < frames[0]) {\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.setFromColor(setup);\n\n                    return;\n                case MixBlend.first:\n                    color.add((setup.r - color.r) * alpha, (setup.g - color.g) * alpha, (setup.b - color.b) * alpha, (setup.a - color.a) * alpha);\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        const i = Timeline.search(frames, time, 5 /* ENTRIES*/);\n        const curveType = this.curves[i / 5 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                const t = (time - before) / (frames[i + 5 /* ENTRIES*/] - before);\n\n                r += (frames[i + 5 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 5 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 5 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                a += (frames[i + 5 /* ENTRIES*/ + 4 /* A*/] - a) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n        }\n        if (alpha == 1) color.set(r, g, b, a);\n        else {\n            if (blend == MixBlend.setup) color.setFromColor(slot.data.color);\n            color.add((r - color.r) * alpha, (g - color.g) * alpha, (b - color.b) * alpha, (a - color.a) * alpha);\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color}.\n * @public\n * */\nexport class RGBTimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 4 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, red, green, blue, and alpha for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number) {\n        frame <<= 2;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const color = slot.color;\n\n        if (time < frames[0]) {\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.r = setup.r;\n                    color.g = setup.g;\n                    color.b = setup.b;\n\n                    return;\n                case MixBlend.first:\n                    color.r += (setup.r - color.r) * alpha;\n                    color.g += (setup.g - color.g) * alpha;\n                    color.b += (setup.b - color.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\n        const curveType = this.curves[i >> 2];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\n\n                r += (frames[i + 4 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 4 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 4 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n        }\n        if (alpha == 1) {\n            color.r = r;\n            color.g = g;\n            color.b = b;\n        } else {\n            if (blend == MixBlend.setup) {\n                const setup = slot.data.color;\n\n                color.r = setup.r;\n                color.g = setup.g;\n                color.b = setup.b;\n            }\n            color.r += (r - color.r) * alpha;\n            color.g += (g - color.g) * alpha;\n            color.b += (b - color.b) * alpha;\n        }\n    }\n}\n\n/** Changes a bone's local {@link Bone#shearX} and {@link Bone#shearY}.\n * @public\n * */\nexport class AlphaTimeline extends CurveTimeline1 implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, `${Property.alpha}|${slotIndex}`);\n        this.slotIndex = slotIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const color = slot.color;\n\n        if (time < this.frames[0]) {\n            // Time is before first frame.\n            const setup = slot.data.color;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    color.a = setup.a;\n\n                    return;\n                case MixBlend.first:\n                    color.a += (setup.a - color.a) * alpha;\n            }\n\n            return;\n        }\n\n        const a = this.getCurveValue(time);\n\n        if (alpha == 1) color.a = a;\n        else {\n            if (blend == MixBlend.setup) color.a = slot.data.color.a;\n            color.a += (a - color.a) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\n * @public\n * */\nexport class RGBA2Timeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.alpha}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 8 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, a: number, r2: number, g2: number, b2: number) {\n        frame <<= 3;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* A*/] = a;\n        this.frames[frame + 5 /* R2*/] = r2;\n        this.frames[frame + 6 /* G2*/] = g2;\n        this.frames[frame + 7 /* B2*/] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const light = slot.color;\n        const dark = slot.darkColor;\n\n        if (time < frames[0]) {\n            const setupLight = slot.data.color;\n            const setupDark = slot.data.darkColor;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    light.setFromColor(setupLight);\n                    dark.r = setupDark.r;\n                    dark.g = setupDark.g;\n                    dark.b = setupDark.b;\n\n                    return;\n                case MixBlend.first:\n                    light.add((setupLight.r - light.r) * alpha, (setupLight.g - light.g) * alpha, (setupLight.b - light.b) * alpha, (setupLight.a - light.a) * alpha);\n                    dark.r += (setupDark.r - dark.r) * alpha;\n                    dark.g += (setupDark.g - dark.g) * alpha;\n                    dark.b += (setupDark.b - dark.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let a = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n        const i = Timeline.search(frames, time, 8 /* ENTRIES*/);\n        const curveType = this.curves[i >> 3];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                r2 = frames[i + 5 /* R2*/];\n                g2 = frames[i + 6 /* G2*/];\n                b2 = frames[i + 7 /* B2*/];\n                const t = (time - before) / (frames[i + 8 /* ENTRIES*/] - before);\n\n                r += (frames[i + 8 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 8 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 8 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                a += (frames[i + 8 /* ENTRIES*/ + 4 /* A*/] - a) * t;\n                r2 += (frames[i + 8 /* ENTRIES*/ + 5 /* R2*/] - r2) * t;\n                g2 += (frames[i + 8 /* ENTRIES*/ + 6 /* G2*/] - g2) * t;\n                b2 += (frames[i + 8 /* ENTRIES*/ + 7 /* B2*/] - b2) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                a = frames[i + 4 /* A*/];\n                r2 = frames[i + 5 /* R2*/];\n                g2 = frames[i + 6 /* G2*/];\n                b2 = frames[i + 7 /* B2*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                a = this.getBezierValue(time, i, 4 /* A*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                r2 = this.getBezierValue(time, i, 5 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                g2 = this.getBezierValue(time, i, 6 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n                b2 = this.getBezierValue(time, i, 7 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 6 - 2 /* BEZIER*/);\n        }\n\n        if (alpha == 1) {\n            light.set(r, g, b, a);\n            dark.r = r2;\n            dark.g = g2;\n            dark.b = b2;\n        } else {\n            if (blend == MixBlend.setup) {\n                light.setFromColor(slot.data.color);\n                const setupDark = slot.data.darkColor;\n\n                dark.r = setupDark.r;\n                dark.g = setupDark.g;\n                dark.b = setupDark.b;\n            }\n            light.add((r - light.r) * alpha, (g - light.g) * alpha, (b - light.b) * alpha, (a - light.a) * alpha);\n            dark.r += (r2 - dark.r) * alpha;\n            dark.g += (g2 - dark.g) * alpha;\n            dark.b += (b2 - dark.b) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#color} and {@link Slot#darkColor} for two color tinting.\n * @public\n * */\nexport class RGB2Timeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number) {\n        super(frameCount, bezierCount, [`${Property.rgb}|${slotIndex}`, `${Property.rgb2}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n    }\n\n    getFrameEntries() {\n        return 7 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, light, and dark colors for the specified key frame. */\n    setFrame(frame: number, time: number, r: number, g: number, b: number, r2: number, g2: number, b2: number) {\n        frame *= 7 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* R*/] = r;\n        this.frames[frame + 2 /* G*/] = g;\n        this.frames[frame + 3 /* B*/] = b;\n        this.frames[frame + 4 /* R2*/] = r2;\n        this.frames[frame + 5 /* G2*/] = g2;\n        this.frames[frame + 6 /* B2*/] = b2;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        const frames = this.frames;\n        const light = slot.color;\n        const dark = slot.darkColor;\n\n        if (time < frames[0]) {\n            const setupLight = slot.data.color;\n            const setupDark = slot.data.darkColor;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    light.r = setupLight.r;\n                    light.g = setupLight.g;\n                    light.b = setupLight.b;\n                    dark.r = setupDark.r;\n                    dark.g = setupDark.g;\n                    dark.b = setupDark.b;\n\n                    return;\n                case MixBlend.first:\n                    light.r += (setupLight.r - light.r) * alpha;\n                    light.g += (setupLight.g - light.g) * alpha;\n                    light.b += (setupLight.b - light.b) * alpha;\n                    dark.r += (setupDark.r - dark.r) * alpha;\n                    dark.g += (setupDark.g - dark.g) * alpha;\n                    dark.b += (setupDark.b - dark.b) * alpha;\n            }\n\n            return;\n        }\n\n        let r = 0;\n        let g = 0;\n        let b = 0;\n        let r2 = 0;\n        let g2 = 0;\n        let b2 = 0;\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                r2 = frames[i + 4 /* R2*/];\n                g2 = frames[i + 5 /* G2*/];\n                b2 = frames[i + 6 /* B2*/];\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\n\n                r += (frames[i + 7 /* ENTRIES*/ + 1 /* R*/] - r) * t;\n                g += (frames[i + 7 /* ENTRIES*/ + 2 /* G*/] - g) * t;\n                b += (frames[i + 7 /* ENTRIES*/ + 3 /* B*/] - b) * t;\n                r2 += (frames[i + 7 /* ENTRIES*/ + 4 /* R2*/] - r2) * t;\n                g2 += (frames[i + 7 /* ENTRIES*/ + 5 /* G2*/] - g2) * t;\n                b2 += (frames[i + 7 /* ENTRIES*/ + 6 /* B2*/] - b2) * t;\n                break;\n            case 1 /* STEPPED*/:\n                r = frames[i + 1 /* R*/];\n                g = frames[i + 2 /* G*/];\n                b = frames[i + 3 /* B*/];\n                r2 = frames[i + 4 /* R2*/];\n                g2 = frames[i + 5 /* G2*/];\n                b2 = frames[i + 6 /* B2*/];\n                break;\n            default:\n                r = this.getBezierValue(time, i, 1 /* R*/, curveType - 2 /* BEZIER*/);\n                g = this.getBezierValue(time, i, 2 /* G*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                b = this.getBezierValue(time, i, 3 /* B*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                r2 = this.getBezierValue(time, i, 4 /* R2*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                g2 = this.getBezierValue(time, i, 5 /* G2*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                b2 = this.getBezierValue(time, i, 6 /* B2*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n        }\n\n        if (alpha == 1) {\n            light.r = r;\n            light.g = g;\n            light.b = b;\n            dark.r = r2;\n            dark.g = g2;\n            dark.b = b2;\n        } else {\n            if (blend == MixBlend.setup) {\n                const setupLight = slot.data.color;\n                const setupDark = slot.data.darkColor;\n\n                light.r = setupLight.r;\n                light.g = setupLight.g;\n                light.b = setupLight.b;\n                dark.r = setupDark.r;\n                dark.g = setupDark.g;\n                dark.b = setupDark.b;\n            }\n            light.r += (r - light.r) * alpha;\n            light.g += (g - light.g) * alpha;\n            light.b += (b - light.b) * alpha;\n            dark.r += (r2 - dark.r) * alpha;\n            dark.g += (g2 - dark.g) * alpha;\n            dark.b += (b2 - dark.b) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#attachment}.\n * @public\n * */\nexport class AttachmentTimeline extends Timeline implements SlotTimeline {\n    slotIndex = 0;\n\n    /** The attachment name for each key frame. May contain null values to clear the attachment. */\n    attachmentNames: Array<string | null>;\n\n    constructor(frameCount: number, slotIndex: number) {\n        super(frameCount, [`${Property.attachment}|${slotIndex}`]);\n        this.slotIndex = slotIndex;\n        this.attachmentNames = new Array<string>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the attachment name for the specified key frame. */\n    setFrame(frame: number, time: number, attachmentName: string | null) {\n        this.frames[frame] = time;\n        this.attachmentNames[frame] = attachmentName;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        if (time < this.frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName);\n\n            return;\n        }\n\n        this.setAttachment(skeleton, slot, this.attachmentNames[Timeline.search1(this.frames, time)]);\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null) {\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(this.slotIndex, attachmentName));\n    }\n}\n\n/** Changes a slot's {@link Slot#deform} to deform a {@link VertexAttachment}.\n * @public\n * */\nexport class DeformTimeline extends CurveTimeline implements SlotTimeline {\n    slotIndex = 0;\n\n    /** The attachment that will be deformed. */\n    attachment: VertexAttachment;\n\n    /** The vertices for each key frame. */\n    vertices: Array<NumberArrayLike>;\n\n    constructor(frameCount: number, bezierCount: number, slotIndex: number, attachment: VertexAttachment) {\n        super(frameCount, bezierCount, [`${Property.deform}|${slotIndex}|${attachment.id}`]);\n        this.slotIndex = slotIndex;\n        this.attachment = attachment;\n        this.vertices = new Array<NumberArrayLike>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the vertices for the specified key frame.\n     * @param vertices Vertex positions for an unweighted VertexAttachment, or deform offsets if it has weights. */\n    setFrame(frame: number, time: number, vertices: NumberArrayLike) {\n        this.frames[frame] = time;\n        this.vertices[frame] = vertices;\n    }\n\n    /** @param value1 Ignored (0 is used for a deform timeline).\n     * @param value2 Ignored (1 is used for a deform timeline). */\n    setBezier(bezier: number, frame: number, value: number, time1: number, value1: number, cx1: number, cy1: number, cx2: number, cy2: number, time2: number, value2: number) {\n        const curves = this.curves;\n        let i = this.getFrameCount() + bezier * 18; /* BEZIER_SIZE*/\n\n        if (value == 0) curves[frame] = 2 /* BEZIER*/ + i;\n        const tmpx = (time1 - cx1 * 2 + cx2) * 0.03;\n        const tmpy = cy2 * 0.03 - cy1 * 0.06;\n        const dddx = ((cx1 - cx2) * 3 - time1 + time2) * 0.006;\n        const dddy = (cy1 - cy2 + 0.33333333) * 0.018;\n        let ddx = tmpx * 2 + dddx;\n        let ddy = tmpy * 2 + dddy;\n        let dx = (cx1 - time1) * 0.3 + tmpx + dddx * 0.16666667;\n        let dy = cy1 * 0.3 + tmpy + dddy * 0.16666667;\n        let x = time1 + dx;\n        let y = dy;\n\n        for (let n = i + 18 /* BEZIER_SIZE*/; i < n; i += 2) {\n            curves[i] = x;\n            curves[i + 1] = y;\n            dx += ddx;\n            dy += ddy;\n            ddx += dddx;\n            ddy += dddy;\n            x += dx;\n            y += dy;\n        }\n    }\n\n    getCurvePercent(time: number, frame: number) {\n        const curves = this.curves;\n        let i = curves[frame];\n\n        switch (i) {\n            case 0 /* LINEAR*/:\n                const x = this.frames[frame];\n\n                return (time - x) / (this.frames[frame + this.getFrameEntries()] - x);\n            case 1 /* STEPPED*/:\n                return 0;\n        }\n        i -= 2 /* BEZIER*/;\n        if (curves[i] > time) {\n            const x = this.frames[frame];\n\n            return (curves[i + 1] * (time - x)) / (curves[i] - x);\n        }\n        const n = i + 18; /* BEZIER_SIZE*/\n\n        for (i += 2; i < n; i += 2) {\n            if (curves[i] >= time) {\n                const x = curves[i - 2];\n                const y = curves[i - 1];\n\n                return y + ((time - x) / (curves[i] - x)) * (curves[i + 1] - y);\n            }\n        }\n        const x = curves[n - 2];\n        const y = curves[n - 1];\n\n        return y + ((1 - y) * (time - x)) / (this.frames[frame + this.getFrameEntries()] - x);\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot: Slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const slotAttachment: Attachment | null = slot.getAttachment();\n\n        if (!slotAttachment) return;\n        if (!(slotAttachment instanceof VertexAttachment) || (<VertexAttachment>slotAttachment).timelineAttachment != this.attachment) return;\n\n        const deform: Array<number> = slot.deform;\n\n        if (deform.length == 0) blend = MixBlend.setup;\n\n        const vertices = this.vertices;\n        const vertexCount = vertices[0].length;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    deform.length = 0;\n\n                    return;\n                case MixBlend.first:\n                    if (alpha == 1) {\n                        deform.length = 0;\n\n                        return;\n                    }\n                    deform.length = vertexCount;\n                    const vertexAttachment = <VertexAttachment>slotAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (setupVertices[i] - deform[i]) * alpha;\n                    } else {\n                        // Weighted deform offsets.\n                        alpha = 1 - alpha;\n                        for (let i = 0; i < vertexCount; i++) deform[i] *= alpha;\n                    }\n            }\n\n            return;\n        }\n\n        deform.length = vertexCount;\n        if (time >= frames[frames.length - 1]) {\n            // Time is after last frame.\n            const lastVertices = vertices[frames.length - 1];\n\n            if (alpha == 1) {\n                if (blend == MixBlend.add) {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] - setupVertices[i];\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i];\n                    }\n                } else Utils.arrayCopy(lastVertices, 0, deform, 0, vertexCount);\n            } else {\n                switch (blend) {\n                    case MixBlend.setup: {\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (!vertexAttachment.bones) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) {\n                                const setup = setupVertices[i];\n\n                                deform[i] = setup + (lastVertices[i] - setup) * alpha;\n                            }\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] = lastVertices[i] * alpha;\n                        }\n                        break;\n                    }\n                    case MixBlend.first:\n                    case MixBlend.replace:\n                        for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - deform[i]) * alpha;\n                        break;\n                    case MixBlend.add:\n                        const vertexAttachment = slotAttachment as VertexAttachment;\n\n                        if (!vertexAttachment.bones) {\n                            // Unweighted vertex positions, with alpha.\n                            const setupVertices = vertexAttachment.vertices;\n\n                            for (let i = 0; i < vertexCount; i++) deform[i] += (lastVertices[i] - setupVertices[i]) * alpha;\n                        } else {\n                            // Weighted deform offsets, with alpha.\n                            for (let i = 0; i < vertexCount; i++) deform[i] += lastVertices[i] * alpha;\n                        }\n                }\n            }\n\n            return;\n        }\n\n        // Interpolate between the previous frame and the current frame.\n        const frame = Timeline.search1(frames, time);\n        const percent = this.getCurvePercent(time, frame);\n        const prevVertices = vertices[frame];\n        const nextVertices = vertices[frame + 1];\n\n        if (alpha == 1) {\n            if (blend == MixBlend.add) {\n                const vertexAttachment = slotAttachment as VertexAttachment;\n\n                if (!vertexAttachment.bones) {\n                    // Unweighted vertex positions, with alpha.\n                    const setupVertices = vertexAttachment.vertices;\n\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent - setupVertices[i];\n                    }\n                } else {\n                    // Weighted deform offsets, with alpha.\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += prev + (nextVertices[i] - prev) * percent;\n                    }\n                }\n            } else {\n                for (let i = 0; i < vertexCount; i++) {\n                    const prev = prevVertices[i];\n\n                    deform[i] = prev + (nextVertices[i] - prev) * percent;\n                }\n            }\n        } else {\n            switch (blend) {\n                case MixBlend.setup: {\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n                            const setup = setupVertices[i];\n\n                            deform[i] = setup + (prev + (nextVertices[i] - prev) * percent - setup) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] = (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n                    break;\n                }\n                case MixBlend.first:\n                case MixBlend.replace:\n                    for (let i = 0; i < vertexCount; i++) {\n                        const prev = prevVertices[i];\n\n                        deform[i] += (prev + (nextVertices[i] - prev) * percent - deform[i]) * alpha;\n                    }\n                    break;\n                case MixBlend.add:\n                    const vertexAttachment = slotAttachment as VertexAttachment;\n\n                    if (!vertexAttachment.bones) {\n                        // Unweighted vertex positions, with alpha.\n                        const setupVertices = vertexAttachment.vertices;\n\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent - setupVertices[i]) * alpha;\n                        }\n                    } else {\n                        // Weighted deform offsets, with alpha.\n                        for (let i = 0; i < vertexCount; i++) {\n                            const prev = prevVertices[i];\n\n                            deform[i] += (prev + (nextVertices[i] - prev) * percent) * alpha;\n                        }\n                    }\n            }\n        }\n    }\n}\n\n/** Fires an {@link Event} when specific animation times are reached.\n * @public\n * */\nexport class EventTimeline extends Timeline {\n    static propertyIds = [`${Property.event}`];\n\n    /** The event for each key frame. */\n    events: Array<Event>;\n\n    constructor(frameCount: number) {\n        super(frameCount, EventTimeline.propertyIds);\n\n        this.events = new Array<Event>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the event for the specified key frame. */\n    setFrame(frame: number, event: Event) {\n        this.frames[frame] = event.time;\n        this.events[frame] = event;\n    }\n\n    /** Fires events for frames > `lastTime` and <= `time`. */\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (!firedEvents) return;\n\n        const frames = this.frames;\n        const frameCount = this.frames.length;\n\n        if (lastTime > time) {\n            // Fire events after last time for looped animations.\n            this.apply(skeleton, lastTime, Number.MAX_VALUE, firedEvents, alpha, blend, direction);\n            lastTime = -1;\n        } else if (lastTime >= frames[frameCount - 1])\n            // Last time is after last frame.\n            return;\n        if (time < frames[0]) return; // Time is before first frame.\n\n        let i = 0;\n\n        if (lastTime < frames[0]) i = 0;\n        else {\n            i = Timeline.search1(frames, lastTime) + 1;\n            const frameTime = frames[i];\n\n            while (i > 0) {\n                // Fire multiple events with the same frame.\n                if (frames[i - 1] != frameTime) break;\n                i--;\n            }\n        }\n        for (; i < frameCount && time >= frames[i]; i++) firedEvents.push(this.events[i]);\n    }\n}\n\n/** Changes a skeleton's {@link Skeleton#drawOrder}.\n * @public\n * */\nexport class DrawOrderTimeline extends Timeline {\n    static propertyIds = [`${Property.drawOrder}`];\n\n    /** The draw order for each key frame. See {@link #setFrame(int, float, int[])}. */\n    drawOrders: Array<Array<number> | null>;\n\n    constructor(frameCount: number) {\n        super(frameCount, DrawOrderTimeline.propertyIds);\n        this.drawOrders = new Array<Array<number> | null>(frameCount);\n    }\n\n    getFrameCount() {\n        return this.frames.length;\n    }\n\n    /** Sets the time in seconds and the draw order for the specified key frame.\n     * @param drawOrder For each slot in {@link Skeleton#slots}, the index of the new draw order. May be null to use setup pose\n     *           draw order. */\n    setFrame(frame: number, time: number, drawOrder: Array<number> | null) {\n        this.frames[frame] = time;\n        this.drawOrders[frame] = drawOrder;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        if (direction == MixDirection.mixOut) {\n            if (blend == MixBlend.setup) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        if (time < this.frames[0]) {\n            if (blend == MixBlend.setup || blend == MixBlend.first) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n\n            return;\n        }\n\n        const idx = Timeline.search1(this.frames, time);\n        const drawOrderToSetupIndex = this.drawOrders[idx];\n\n        if (!drawOrderToSetupIndex) Utils.arrayCopy(skeleton.slots, 0, skeleton.drawOrder, 0, skeleton.slots.length);\n        else {\n            const drawOrder: Array<Slot> = skeleton.drawOrder;\n            const slots: Array<Slot> = skeleton.slots;\n\n            for (let i = 0, n = drawOrderToSetupIndex.length; i < n; i++) drawOrder[i] = slots[drawOrderToSetupIndex[i]];\n        }\n    }\n}\n\n/** Changes an IK constraint's {@link IkConstraint#mix}, {@link IkConstraint#softness},\n * {@link IkConstraint#bendDirection}, {@link IkConstraint#stretch}, and {@link IkConstraint#compress}.\n * @public\n * */\nexport class IkConstraintTimeline extends CurveTimeline {\n    /** The index of the IK constraint slot in {@link Skeleton#ikConstraints} that will be changed. */\n    ikConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, ikConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.ikConstraint}|${ikConstraintIndex}`]);\n        this.ikConstraintIndex = ikConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 6 /* ENTRIES*/;\n    }\n\n    /** Sets the time in seconds, mix, softness, bend direction, compress, and stretch for the specified key frame. */\n    setFrame(frame: number, time: number, mix: number, softness: number, bendDirection: number, compress: boolean, stretch: boolean) {\n        frame *= 6 /* ENTRIES*/;\n        this.frames[frame] = time;\n        this.frames[frame + 1 /* MIX*/] = mix;\n        this.frames[frame + 2 /* SOFTNESS*/] = softness;\n        this.frames[frame + 3 /* BEND_DIRECTION*/] = bendDirection;\n        this.frames[frame + 4 /* COMPRESS*/] = compress ? 1 : 0;\n        this.frames[frame + 5 /* STRETCH*/] = stretch ? 1 : 0;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: IkConstraint = skeleton.ikConstraints[this.ikConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mix = constraint.data.mix;\n                    constraint.softness = constraint.data.softness;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mix += (constraint.data.mix - constraint.mix) * alpha;\n                    constraint.softness += (constraint.data.softness - constraint.softness) * alpha;\n                    constraint.bendDirection = constraint.data.bendDirection;\n                    constraint.compress = constraint.data.compress;\n                    constraint.stretch = constraint.data.stretch;\n            }\n\n            return;\n        }\n\n        let mix = 0;\n        let softness = 0;\n        const i = Timeline.search(frames, time, 6 /* ENTRIES*/);\n        const curveType = this.curves[i / 6 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                mix = frames[i + 1 /* MIX*/];\n                softness = frames[i + 2 /* SOFTNESS*/];\n                const t = (time - before) / (frames[i + 6 /* ENTRIES*/] - before);\n\n                mix += (frames[i + 6 /* ENTRIES*/ + 1 /* MIX*/] - mix) * t;\n                softness += (frames[i + 6 /* ENTRIES*/ + 2 /* SOFTNESS*/] - softness) * t;\n                break;\n            case 1 /* STEPPED*/:\n                mix = frames[i + 1 /* MIX*/];\n                softness = frames[i + 2 /* SOFTNESS*/];\n                break;\n            default:\n                mix = this.getBezierValue(time, i, 1 /* MIX*/, curveType - 2 /* BEZIER*/);\n                softness = this.getBezierValue(time, i, 2 /* SOFTNESS*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            constraint.mix = constraint.data.mix + (mix - constraint.data.mix) * alpha;\n            constraint.softness = constraint.data.softness + (softness - constraint.data.softness) * alpha;\n\n            if (direction == MixDirection.mixOut) {\n                constraint.bendDirection = constraint.data.bendDirection;\n                constraint.compress = constraint.data.compress;\n                constraint.stretch = constraint.data.stretch;\n            } else {\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\n            }\n        } else {\n            constraint.mix += (mix - constraint.mix) * alpha;\n            constraint.softness += (softness - constraint.softness) * alpha;\n            if (direction == MixDirection.mixIn) {\n                constraint.bendDirection = frames[i + 3 /* BEND_DIRECTION*/];\n                constraint.compress = frames[i + 4 /* COMPRESS*/] != 0;\n                constraint.stretch = frames[i + 5 /* STRETCH*/] != 0;\n            }\n        }\n    }\n}\n\n/** Changes a transform constraint's {@link TransformConstraint#rotateMix}, {@link TransformConstraint#translateMix},\n * {@link TransformConstraint#scaleMix}, and {@link TransformConstraint#shearMix}.\n * @public\n * */\nexport class TransformConstraintTimeline extends CurveTimeline {\n    /** The index of the transform constraint slot in {@link Skeleton#transformConstraints} that will be changed. */\n    transformConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, transformConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.transformConstraint}|${transformConstraintIndex}`]);\n        this.transformConstraintIndex = transformConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 7 /* ENTRIES*/;\n    }\n\n    /** The time in seconds, rotate mix, translate mix, scale mix, and shear mix for the specified key frame. */\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number, mixScaleX: number, mixScaleY: number, mixShearY: number) {\n        const frames = this.frames;\n\n        frame *= 7 /* ENTRIES*/;\n        frames[frame] = time;\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\n        frames[frame + 2 /* X*/] = mixX;\n        frames[frame + 3 /* Y*/] = mixY;\n        frames[frame + 4 /* SCALEX*/] = mixScaleX;\n        frames[frame + 5 /* SCALEY*/] = mixScaleY;\n        frames[frame + 6 /* SHEARY*/] = mixShearY;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: TransformConstraint = skeleton.transformConstraints[this.transformConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            const data = constraint.data;\n\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mixRotate = data.mixRotate;\n                    constraint.mixX = data.mixX;\n                    constraint.mixY = data.mixY;\n                    constraint.mixScaleX = data.mixScaleX;\n                    constraint.mixScaleY = data.mixScaleY;\n                    constraint.mixShearY = data.mixShearY;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mixRotate += (data.mixRotate - constraint.mixRotate) * alpha;\n                    constraint.mixX += (data.mixX - constraint.mixX) * alpha;\n                    constraint.mixY += (data.mixY - constraint.mixY) * alpha;\n                    constraint.mixScaleX += (data.mixScaleX - constraint.mixScaleX) * alpha;\n                    constraint.mixScaleY += (data.mixScaleY - constraint.mixScaleY) * alpha;\n                    constraint.mixShearY += (data.mixShearY - constraint.mixShearY) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate;\n        let x;\n        let y;\n        let scaleX;\n        let scaleY;\n        let shearY;\n        const i = Timeline.search(frames, time, 7 /* ENTRIES*/);\n        const curveType = this.curves[i / 7 /* ENTRIES*/];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                scaleX = frames[i + 4 /* SCALEX*/];\n                scaleY = frames[i + 5 /* SCALEY*/];\n                shearY = frames[i + 6 /* SHEARY*/];\n                const t = (time - before) / (frames[i + 7 /* ENTRIES*/] - before);\n\n                rotate += (frames[i + 7 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\n                x += (frames[i + 7 /* ENTRIES*/ + 2 /* X*/] - x) * t;\n                y += (frames[i + 7 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\n                scaleX += (frames[i + 7 /* ENTRIES*/ + 4 /* SCALEX*/] - scaleX) * t;\n                scaleY += (frames[i + 7 /* ENTRIES*/ + 5 /* SCALEY*/] - scaleY) * t;\n                shearY += (frames[i + 7 /* ENTRIES*/ + 6 /* SHEARY*/] - shearY) * t;\n                break;\n            case 1 /* STEPPED*/:\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                scaleX = frames[i + 4 /* SCALEX*/];\n                scaleY = frames[i + 5 /* SCALEY*/];\n                shearY = frames[i + 6 /* SHEARY*/];\n                break;\n            default:\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n                scaleX = this.getBezierValue(time, i, 4 /* SCALEX*/, curveType + 18 /* BEZIER_SIZE*/ * 3 - 2 /* BEZIER*/);\n                scaleY = this.getBezierValue(time, i, 5 /* SCALEY*/, curveType + 18 /* BEZIER_SIZE*/ * 4 - 2 /* BEZIER*/);\n                shearY = this.getBezierValue(time, i, 6 /* SHEARY*/, curveType + 18 /* BEZIER_SIZE*/ * 5 - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n            constraint.mixScaleX = data.mixScaleX + (scaleX - data.mixScaleX) * alpha;\n            constraint.mixScaleY = data.mixScaleY + (scaleY - data.mixScaleY) * alpha;\n            constraint.mixShearY = data.mixShearY + (shearY - data.mixShearY) * alpha;\n        } else {\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n            constraint.mixX += (x - constraint.mixX) * alpha;\n            constraint.mixY += (y - constraint.mixY) * alpha;\n            constraint.mixScaleX += (scaleX - constraint.mixScaleX) * alpha;\n            constraint.mixScaleY += (scaleY - constraint.mixScaleY) * alpha;\n            constraint.mixShearY += (shearY - constraint.mixShearY) * alpha;\n        }\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#position}.\n * @public\n * */\nexport class PathConstraintPositionTimeline extends CurveTimeline1 {\n    /** The index of the path constraint slot in {@link Skeleton#pathConstraints} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, `${Property.pathConstraintPosition}|${pathConstraintIndex}`);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.position = constraint.data.position;\n\n                    return;\n                case MixBlend.first:\n                    constraint.position += (constraint.data.position - constraint.position) * alpha;\n            }\n\n            return;\n        }\n\n        const position = this.getCurveValue(time);\n\n        if (blend == MixBlend.setup) constraint.position = constraint.data.position + (position - constraint.data.position) * alpha;\n        else constraint.position += (position - constraint.position) * alpha;\n    }\n}\n\n/** Changes a path constraint's {@link PathConstraint#spacing}.\n * @public\n * */\nexport class PathConstraintSpacingTimeline extends CurveTimeline1 {\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, `${Property.pathConstraintSpacing}|${pathConstraintIndex}`);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.spacing = constraint.data.spacing;\n\n                    return;\n                case MixBlend.first:\n                    constraint.spacing += (constraint.data.spacing - constraint.spacing) * alpha;\n            }\n\n            return;\n        }\n\n        const spacing = this.getCurveValue(time);\n\n        if (blend == MixBlend.setup) constraint.spacing = constraint.data.spacing + (spacing - constraint.data.spacing) * alpha;\n        else constraint.spacing += (spacing - constraint.spacing) * alpha;\n    }\n}\n\n/** Changes a transform constraint's {@link PathConstraint#getMixRotate()}, {@link PathConstraint#getMixX()}, and\n * {@link PathConstraint#getMixY()}.\n * @public\n * */\nexport class PathConstraintMixTimeline extends CurveTimeline {\n    /** The index of the path constraint slot in {@link Skeleton#getPathConstraints()} that will be changed. */\n    pathConstraintIndex = 0;\n\n    constructor(frameCount: number, bezierCount: number, pathConstraintIndex: number) {\n        super(frameCount, bezierCount, [`${Property.pathConstraintMix}|${pathConstraintIndex}`]);\n        this.pathConstraintIndex = pathConstraintIndex;\n    }\n\n    getFrameEntries() {\n        return 4 /* ENTRIES*/;\n    }\n\n    setFrame(frame: number, time: number, mixRotate: number, mixX: number, mixY: number) {\n        const frames = this.frames;\n\n        frame <<= 2;\n        frames[frame] = time;\n        frames[frame + 1 /* ROTATE*/] = mixRotate;\n        frames[frame + 2 /* X*/] = mixX;\n        frames[frame + 3 /* Y*/] = mixY;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, firedEvents: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const constraint: PathConstraint = skeleton.pathConstraints[this.pathConstraintIndex];\n\n        if (!constraint.active) return;\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    constraint.mixRotate = constraint.data.mixRotate;\n                    constraint.mixX = constraint.data.mixX;\n                    constraint.mixY = constraint.data.mixY;\n\n                    return;\n                case MixBlend.first:\n                    constraint.mixRotate += (constraint.data.mixRotate - constraint.mixRotate) * alpha;\n                    constraint.mixX += (constraint.data.mixX - constraint.mixX) * alpha;\n                    constraint.mixY += (constraint.data.mixY - constraint.mixY) * alpha;\n            }\n\n            return;\n        }\n\n        let rotate;\n        let x;\n        let y;\n        const i = Timeline.search(frames, time, 4 /* ENTRIES*/);\n        const curveType = this.curves[i >> 2];\n\n        switch (curveType) {\n            case 0 /* LINEAR*/:\n                const before = frames[i];\n\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                const t = (time - before) / (frames[i + 4 /* ENTRIES*/] - before);\n\n                rotate += (frames[i + 4 /* ENTRIES*/ + 1 /* ROTATE*/] - rotate) * t;\n                x += (frames[i + 4 /* ENTRIES*/ + 2 /* X*/] - x) * t;\n                y += (frames[i + 4 /* ENTRIES*/ + 3 /* Y*/] - y) * t;\n                break;\n            case 1 /* STEPPED*/:\n                rotate = frames[i + 1 /* ROTATE*/];\n                x = frames[i + 2 /* X*/];\n                y = frames[i + 3 /* Y*/];\n                break;\n            default:\n                rotate = this.getBezierValue(time, i, 1 /* ROTATE*/, curveType - 2 /* BEZIER*/);\n                x = this.getBezierValue(time, i, 2 /* X*/, curveType + 18 /* BEZIER_SIZE*/ - 2 /* BEZIER*/);\n                y = this.getBezierValue(time, i, 3 /* Y*/, curveType + 18 /* BEZIER_SIZE*/ * 2 - 2 /* BEZIER*/);\n        }\n\n        if (blend == MixBlend.setup) {\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate + (rotate - data.mixRotate) * alpha;\n            constraint.mixX = data.mixX + (x - data.mixX) * alpha;\n            constraint.mixY = data.mixY + (y - data.mixY) * alpha;\n        } else {\n            constraint.mixRotate += (rotate - constraint.mixRotate) * alpha;\n            constraint.mixX += (x - constraint.mixX) * alpha;\n            constraint.mixY += (y - constraint.mixY) * alpha;\n        }\n    }\n}\n\n/** Changes a slot's {@link Slot#getSequenceIndex()} for an attachment's {@link Sequence}.\n * @public\n * */\nexport class SequenceTimeline extends Timeline implements SlotTimeline {\n    static ENTRIES = 3;\n    static MODE = 1;\n    static DELAY = 2;\n\n    slotIndex: number;\n    attachment: IHasTextureRegion;\n\n    constructor(frameCount: number, slotIndex: number, attachment: IHasTextureRegion) {\n        super(frameCount, [`${Property.sequence}|${slotIndex}|${attachment.sequence.id}`]);\n        this.slotIndex = slotIndex;\n        this.attachment = attachment;\n    }\n\n    getFrameEntries() {\n        return SequenceTimeline.ENTRIES;\n    }\n\n    getSlotIndex() {\n        return this.slotIndex;\n    }\n\n    getAttachment() {\n        return this.attachment as unknown as Attachment;\n    }\n\n    /** Sets the time, mode, index, and frame time for the specified frame.\n     * @param frame Between 0 and <code>frameCount</code>, inclusive.\n     * @param time Seconds between frames. */\n    setFrame(frame: number, time: number, mode: SequenceMode, index: number, delay: number) {\n        const frames = this.frames;\n\n        frame *= SequenceTimeline.ENTRIES;\n        frames[frame] = time;\n        frames[frame + SequenceTimeline.MODE] = mode | (index << 4);\n        frames[frame + SequenceTimeline.DELAY] = delay;\n    }\n\n    apply(skeleton: Skeleton, lastTime: number, time: number, events: Array<Event>, alpha: number, blend: MixBlend, direction: MixDirection) {\n        const slot = skeleton.slots[this.slotIndex];\n\n        if (!slot.bone.active) return;\n        const slotAttachment = slot.attachment;\n        const attachment = this.attachment as unknown as Attachment;\n\n        if (slotAttachment != attachment) {\n            if (!(slotAttachment instanceof VertexAttachment) || (slotAttachment as VertexAttachment).timelineAttachment != attachment) return;\n        }\n\n        const frames = this.frames;\n\n        if (time < frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) slot.sequenceIndex = -1;\n\n            return;\n        }\n\n        const i = Timeline.search(frames, time, SequenceTimeline.ENTRIES);\n        const before = frames[i];\n        const modeAndIndex = frames[i + SequenceTimeline.MODE];\n        const delay = frames[i + SequenceTimeline.DELAY];\n\n        if (!this.attachment.sequence) return;\n        let index = modeAndIndex >> 4;\n        const count = this.attachment.sequence.regions.length;\n        const mode = SequenceModeValues[modeAndIndex & 0xf];\n\n        if (mode != SequenceMode.hold) {\n            index += ((time - before) / delay + 0.00001) | 0;\n            switch (mode) {\n                case SequenceMode.once:\n                    index = Math.min(count - 1, index);\n                    break;\n                case SequenceMode.loop:\n                    index %= count;\n                    break;\n                case SequenceMode.pingpong: {\n                    const n = (count << 1) - 2;\n\n                    index = n == 0 ? 0 : index % n;\n                    if (index >= count) index = n - index;\n                    break;\n                }\n                case SequenceMode.onceReverse:\n                    index = Math.max(count - 1 - index, 0);\n                    break;\n                case SequenceMode.loopReverse:\n                    index = count - 1 - (index % count);\n                    break;\n                case SequenceMode.pingpongReverse: {\n                    const n = (count << 1) - 2;\n\n                    index = n == 0 ? 0 : (index + count - 1) % n;\n                    if (index >= count) index = n - index;\n                }\n            }\n        }\n        slot.sequenceIndex = index;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}