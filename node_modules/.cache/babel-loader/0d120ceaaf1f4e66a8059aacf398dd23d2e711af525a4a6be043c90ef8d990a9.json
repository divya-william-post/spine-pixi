{"ast":null,"code":"import { Matrix } from '@pixi/core';\nimport { settings, MathUtils, TransformMode } from '@pixi-spine/base';\nclass Bone {\n  /** @param parent May be null. */\n  constructor(data, skeleton, parent) {\n    // be careful! Spine b,c is c,b in pixi matrix\n    this.matrix = new Matrix();\n    /** The parent bone, or null if this is the root bone. */\n    this.parent = null;\n    /** The immediate children of this bone. */\n    this.children = new Array();\n    /** The local x translation. */\n    this.x = 0;\n    /** The local y translation. */\n    this.y = 0;\n    /** The local rotation in degrees, counter clockwise. */\n    this.rotation = 0;\n    /** The local scaleX. */\n    this.scaleX = 0;\n    /** The local scaleY. */\n    this.scaleY = 0;\n    /** The local shearX. */\n    this.shearX = 0;\n    /** The local shearY. */\n    this.shearY = 0;\n    /** The applied local x translation. */\n    this.ax = 0;\n    /** The applied local y translation. */\n    this.ay = 0;\n    /** The applied local rotation in degrees, counter clockwise. */\n    this.arotation = 0;\n    /** The applied local scaleX. */\n    this.ascaleX = 0;\n    /** The applied local scaleY. */\n    this.ascaleY = 0;\n    /** The applied local shearX. */\n    this.ashearX = 0;\n    /** The applied local shearY. */\n    this.ashearY = 0;\n    this.sorted = false;\n    this.active = false;\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.skeleton = skeleton;\n    this.parent = parent;\n    this.setToSetupPose();\n  }\n  get worldX() {\n    return this.matrix.tx;\n  }\n  get worldY() {\n    return this.matrix.ty;\n  }\n  /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n   * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n  isActive() {\n    return this.active;\n  }\n  /** Computes the world transform using the parent bone and this bone's local applied transform. */\n  update() {\n    this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n  }\n  /** Computes the world transform using the parent bone and this bone's local transform.\n   *\n   * See {@link #updateWorldTransformWith()}. */\n  updateWorldTransform() {\n    this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n  }\n  /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n   * specified local transform. Child bones are not updated.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n  updateWorldTransformWith(x, y, rotation, scaleX, scaleY, shearX, shearY) {\n    this.ax = x;\n    this.ay = y;\n    this.arotation = rotation;\n    this.ascaleX = scaleX;\n    this.ascaleY = scaleY;\n    this.ashearX = shearX;\n    this.ashearY = shearY;\n    const parent = this.parent;\n    const m = this.matrix;\n    const sx = this.skeleton.scaleX;\n    const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n    if (!parent) {\n      const skeleton = this.skeleton;\n      const rotationY = rotation + 90 + shearY;\n      m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n      m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n      m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n      m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n      m.tx = x * sx + skeleton.x;\n      m.ty = y * sy + skeleton.y;\n      return;\n    }\n    let pa = parent.matrix.a;\n    let pb = parent.matrix.c;\n    let pc = parent.matrix.b;\n    let pd = parent.matrix.d;\n    m.tx = pa * x + pb * y + parent.matrix.tx;\n    m.ty = pc * x + pd * y + parent.matrix.ty;\n    switch (this.data.transformMode) {\n      case TransformMode.Normal:\n        {\n          const rotationY = rotation + 90 + shearY;\n          const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n          const lb = MathUtils.cosDeg(rotationY) * scaleY;\n          const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n          const ld = MathUtils.sinDeg(rotationY) * scaleY;\n          m.a = pa * la + pb * lc;\n          m.c = pa * lb + pb * ld;\n          m.b = pc * la + pd * lc;\n          m.d = pc * lb + pd * ld;\n          return;\n        }\n      case TransformMode.OnlyTranslation:\n        {\n          const rotationY = rotation + 90 + shearY;\n          m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n          m.c = MathUtils.cosDeg(rotationY) * scaleY;\n          m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n          m.d = MathUtils.sinDeg(rotationY) * scaleY;\n          break;\n        }\n      case TransformMode.NoRotationOrReflection:\n        {\n          let s = pa * pa + pc * pc;\n          let prx = 0;\n          if (s > 1e-4) {\n            s = Math.abs(pa * pd - pb * pc) / s;\n            pa /= sx;\n            pc /= sy;\n            pb = pc * s;\n            pd = pa * s;\n            prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n          } else {\n            pa = 0;\n            pc = 0;\n            prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n          }\n          const rx = rotation + shearX - prx;\n          const ry = rotation + shearY - prx + 90;\n          const la = MathUtils.cosDeg(rx) * scaleX;\n          const lb = MathUtils.cosDeg(ry) * scaleY;\n          const lc = MathUtils.sinDeg(rx) * scaleX;\n          const ld = MathUtils.sinDeg(ry) * scaleY;\n          m.a = pa * la - pb * lc;\n          m.c = pa * lb - pb * ld;\n          m.b = pc * la + pd * lc;\n          m.d = pc * lb + pd * ld;\n          break;\n        }\n      case TransformMode.NoScale:\n      case TransformMode.NoScaleOrReflection:\n        {\n          const cos = MathUtils.cosDeg(rotation);\n          const sin = MathUtils.sinDeg(rotation);\n          let za = (pa * cos + pb * sin) / sx;\n          let zc = (pc * cos + pd * sin) / sy;\n          let s = Math.sqrt(za * za + zc * zc);\n          if (s > 1e-5) s = 1 / s;\n          za *= s;\n          zc *= s;\n          s = Math.sqrt(za * za + zc * zc);\n          if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0)) s = -s;\n          const r = Math.PI / 2 + Math.atan2(zc, za);\n          const zb = Math.cos(r) * s;\n          const zd = Math.sin(r) * s;\n          const la = MathUtils.cosDeg(shearX) * scaleX;\n          const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n          const lc = MathUtils.sinDeg(shearX) * scaleX;\n          const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n          m.a = za * la + zb * lc;\n          m.c = za * lb + zb * ld;\n          m.b = zc * la + zd * lc;\n          m.d = zc * lb + zd * ld;\n          break;\n        }\n    }\n    m.a *= sx;\n    m.c *= sx;\n    m.b *= sy;\n    m.d *= sy;\n  }\n  /** Sets this bone's local transform to the setup pose. */\n  setToSetupPose() {\n    const data = this.data;\n    this.x = data.x;\n    this.y = data.y;\n    this.rotation = data.rotation;\n    this.scaleX = data.scaleX;\n    this.scaleY = data.scaleY;\n    this.shearX = data.shearX;\n    this.shearY = data.shearY;\n  }\n  /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n  getWorldRotationX() {\n    return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n  }\n  /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n  getWorldRotationY() {\n    return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n  }\n  /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n  getWorldScaleX() {\n    const m = this.matrix;\n    return Math.sqrt(m.a * m.a + m.b * m.b);\n  }\n  /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n  getWorldScaleY() {\n    const m = this.matrix;\n    return Math.sqrt(m.c * m.c + m.d * m.d);\n  }\n  /** Computes the applied transform values from the world transform.\n   *\n   * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n   * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n   * constraints).\n   *\n   * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n   * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n  updateAppliedTransform() {\n    const parent = this.parent;\n    const m = this.matrix;\n    if (!parent) {\n      this.ax = m.tx - this.skeleton.x;\n      this.ay = m.ty - this.skeleton.y;\n      this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n      this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n      this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n      this.ashearX = 0;\n      this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n      return;\n    }\n    const pm = parent.matrix;\n    const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n    const dx = m.tx - pm.tx;\n    const dy = m.ty - pm.ty;\n    this.ax = dx * pm.d * pid - dy * pm.c * pid;\n    this.ay = dy * pm.a * pid - dx * pm.b * pid;\n    const ia = pid * pm.d;\n    const id = pid * pm.a;\n    const ib = pid * pm.c;\n    const ic = pid * pm.b;\n    const ra = ia * m.a - ib * m.b;\n    const rb = ia * m.c - ib * m.d;\n    const rc = id * m.b - ic * m.a;\n    const rd = id * m.d - ic * m.c;\n    this.ashearX = 0;\n    this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n    if (this.ascaleX > 1e-4) {\n      const det = ra * rd - rb * rc;\n      this.ascaleY = det / this.ascaleX;\n      this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n      this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n    } else {\n      this.ascaleX = 0;\n      this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n      this.ashearY = 0;\n      this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n    }\n  }\n  /** Transforms a point from world coordinates to the bone's local coordinates. */\n  worldToLocal(world) {\n    const m = this.matrix;\n    const a = m.a;\n    const b = m.c;\n    const c = m.b;\n    const d = m.d;\n    const invDet = 1 / (a * d - b * c);\n    const x = world.x - m.tx;\n    const y = world.y - m.ty;\n    world.x = x * d * invDet - y * b * invDet;\n    world.y = y * a * invDet - x * c * invDet;\n    return world;\n  }\n  /** Transforms a point from the bone's local coordinates to world coordinates. */\n  localToWorld(local) {\n    const m = this.matrix;\n    const x = local.x;\n    const y = local.y;\n    local.x = x * m.a + y * m.c + m.tx;\n    local.y = x * m.b + y * m.d + m.ty;\n    return local;\n  }\n  /** Transforms a world rotation to a local rotation. */\n  worldToLocalRotation(worldRotation) {\n    const sin = MathUtils.sinDeg(worldRotation);\n    const cos = MathUtils.cosDeg(worldRotation);\n    const mat = this.matrix;\n    return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n  }\n  /** Transforms a local rotation to a world rotation. */\n  localToWorldRotation(localRotation) {\n    localRotation -= this.rotation - this.shearX;\n    const sin = MathUtils.sinDeg(localRotation);\n    const cos = MathUtils.cosDeg(localRotation);\n    const mat = this.matrix;\n    return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n  }\n  /** Rotates the world transform the specified amount.\n   * <p>\n   * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\n   * need to be called on any child bones, recursively. */\n  rotateWorld(degrees) {\n    const mat = this.matrix;\n    const a = mat.a;\n    const b = mat.c;\n    const c = mat.b;\n    const d = mat.d;\n    const cos = MathUtils.cosDeg(degrees);\n    const sin = MathUtils.sinDeg(degrees);\n    mat.a = cos * a - sin * c;\n    mat.c = cos * b - sin * d;\n    mat.b = sin * a + cos * c;\n    mat.d = sin * b + cos * d;\n  }\n}\nexport { Bone };","map":{"version":3,"names":["Bone","constructor","data","skeleton","parent","matrix","Matrix","children","Array","x","y","rotation","scaleX","scaleY","shearX","shearY","ax","ay","arotation","ascaleX","ascaleY","ashearX","ashearY","sorted","active","Error","setToSetupPose","worldX","tx","worldY","ty","isActive","update","updateWorldTransformWith","updateWorldTransform","m","sx","sy","settings","yDown","rotationY","a","MathUtils","cosDeg","c","b","sinDeg","d","pa","pb","pc","pd","transformMode","TransformMode","Normal","la","lb","lc","ld","OnlyTranslation","NoRotationOrReflection","s","prx","Math","abs","atan2","radDeg","rx","ry","NoScale","NoScaleOrReflection","cos","sin","za","zc","sqrt","r","PI","zb","zd","getWorldRotationX","getWorldRotationY","getWorldScaleX","getWorldScaleY","updateAppliedTransform","pm","pid","dx","dy","ia","id","ib","ic","ra","rb","rc","rd","det","worldToLocal","world","invDet","localToWorld","local","worldToLocalRotation","worldRotation","mat","localToWorldRotation","localRotation","rotateWorld","degrees"],"sources":["../../src/core/Bone.ts"],"sourcesContent":["import { Matrix } from '@pixi/core';\nimport type { Updatable } from './Updatable';\nimport type { BoneData } from './BoneData';\nimport type { Skeleton } from './Skeleton';\nimport { IBone, MathUtils, settings, TransformMode, Vector2 } from '@pixi-spine/base';\n\n/** Stores a bone's current pose.\n *\n * A bone has a local transform which is used to compute its world transform. A bone also has an applied transform, which is a\n * local transform that can be applied to compute the world transform. The local transform and applied transform may differ if a\n * constraint or application code modifies the world transform after it was computed from the local transform.\n * @public\n * */\nexport class Bone implements Updatable, IBone {\n    // be careful! Spine b,c is c,b in pixi matrix\n    matrix = new Matrix();\n\n    get worldX(): number {\n        return this.matrix.tx;\n    }\n\n    get worldY(): number {\n        return this.matrix.ty;\n    }\n\n    /** The bone's setup pose data. */\n    data: BoneData;\n\n    /** The skeleton this bone belongs to. */\n    skeleton: Skeleton;\n\n    /** The parent bone, or null if this is the root bone. */\n    parent: Bone | null = null;\n\n    /** The immediate children of this bone. */\n    children = new Array<Bone>();\n\n    /** The local x translation. */\n    x = 0;\n\n    /** The local y translation. */\n    y = 0;\n\n    /** The local rotation in degrees, counter clockwise. */\n    rotation = 0;\n\n    /** The local scaleX. */\n    scaleX = 0;\n\n    /** The local scaleY. */\n    scaleY = 0;\n\n    /** The local shearX. */\n    shearX = 0;\n\n    /** The local shearY. */\n    shearY = 0;\n\n    /** The applied local x translation. */\n    ax = 0;\n\n    /** The applied local y translation. */\n    ay = 0;\n\n    /** The applied local rotation in degrees, counter clockwise. */\n    arotation = 0;\n\n    /** The applied local scaleX. */\n    ascaleX = 0;\n\n    /** The applied local scaleY. */\n    ascaleY = 0;\n\n    /** The applied local shearX. */\n    ashearX = 0;\n\n    /** The applied local shearY. */\n    ashearY = 0;\n\n    sorted = false;\n    active = false;\n\n    /** @param parent May be null. */\n    constructor(data: BoneData, skeleton: Skeleton, parent: Bone | null) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.skeleton = skeleton;\n        this.parent = parent;\n        this.setToSetupPose();\n    }\n\n    /** Returns false when the bone has not been computed because {@link BoneData#skinRequired} is true and the\n     * {@link Skeleton#skin active skin} does not {@link Skin#bones contain} this bone. */\n    isActive() {\n        return this.active;\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local applied transform. */\n    update() {\n        this.updateWorldTransformWith(this.ax, this.ay, this.arotation, this.ascaleX, this.ascaleY, this.ashearX, this.ashearY);\n    }\n\n    /** Computes the world transform using the parent bone and this bone's local transform.\n     *\n     * See {@link #updateWorldTransformWith()}. */\n    updateWorldTransform() {\n        this.updateWorldTransformWith(this.x, this.y, this.rotation, this.scaleX, this.scaleY, this.shearX, this.shearY);\n    }\n\n    /** Computes the world transform using the parent bone and the specified local transform. The applied transform is set to the\n     * specified local transform. Child bones are not updated.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransformWith(x: number, y: number, rotation: number, scaleX: number, scaleY: number, shearX: number, shearY: number) {\n        this.ax = x;\n        this.ay = y;\n        this.arotation = rotation;\n        this.ascaleX = scaleX;\n        this.ascaleY = scaleY;\n        this.ashearX = shearX;\n        this.ashearY = shearY;\n\n        const parent = this.parent;\n        const m = this.matrix;\n\n        const sx = this.skeleton.scaleX;\n        const sy = settings.yDown ? -this.skeleton.scaleY : this.skeleton.scaleY;\n\n        if (!parent) {\n            // Root bone.\n            const skeleton = this.skeleton;\n            const rotationY = rotation + 90 + shearY;\n\n            m.a = MathUtils.cosDeg(rotation + shearX) * scaleX * sx;\n            m.c = MathUtils.cosDeg(rotationY) * scaleY * sx;\n            m.b = MathUtils.sinDeg(rotation + shearX) * scaleX * sy;\n            m.d = MathUtils.sinDeg(rotationY) * scaleY * sy;\n            m.tx = x * sx + skeleton.x;\n            m.ty = y * sy + skeleton.y;\n\n            return;\n        }\n\n        let pa = parent.matrix.a;\n        let pb = parent.matrix.c;\n        let pc = parent.matrix.b;\n        let pd = parent.matrix.d;\n\n        m.tx = pa * x + pb * y + parent.matrix.tx;\n        m.ty = pc * x + pd * y + parent.matrix.ty;\n\n        switch (this.data.transformMode) {\n            case TransformMode.Normal: {\n                const rotationY = rotation + 90 + shearY;\n                const la = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                const lb = MathUtils.cosDeg(rotationY) * scaleY;\n                const lc = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                const ld = MathUtils.sinDeg(rotationY) * scaleY;\n\n                m.a = pa * la + pb * lc;\n                m.c = pa * lb + pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n\n                return;\n            }\n            case TransformMode.OnlyTranslation: {\n                const rotationY = rotation + 90 + shearY;\n\n                m.a = MathUtils.cosDeg(rotation + shearX) * scaleX;\n                m.c = MathUtils.cosDeg(rotationY) * scaleY;\n                m.b = MathUtils.sinDeg(rotation + shearX) * scaleX;\n                m.d = MathUtils.sinDeg(rotationY) * scaleY;\n                break;\n            }\n            case TransformMode.NoRotationOrReflection: {\n                let s = pa * pa + pc * pc;\n                let prx = 0;\n\n                if (s > 0.0001) {\n                    s = Math.abs(pa * pd - pb * pc) / s;\n                    pa /= sx;\n                    pc /= sy;\n                    pb = pc * s;\n                    pd = pa * s;\n                    prx = Math.atan2(pc, pa) * MathUtils.radDeg;\n                } else {\n                    pa = 0;\n                    pc = 0;\n                    prx = 90 - Math.atan2(pd, pb) * MathUtils.radDeg;\n                }\n                const rx = rotation + shearX - prx;\n                const ry = rotation + shearY - prx + 90;\n                const la = MathUtils.cosDeg(rx) * scaleX;\n                const lb = MathUtils.cosDeg(ry) * scaleY;\n                const lc = MathUtils.sinDeg(rx) * scaleX;\n                const ld = MathUtils.sinDeg(ry) * scaleY;\n\n                m.a = pa * la - pb * lc;\n                m.c = pa * lb - pb * ld;\n                m.b = pc * la + pd * lc;\n                m.d = pc * lb + pd * ld;\n                break;\n            }\n            case TransformMode.NoScale:\n            case TransformMode.NoScaleOrReflection: {\n                const cos = MathUtils.cosDeg(rotation);\n                const sin = MathUtils.sinDeg(rotation);\n                let za = (pa * cos + pb * sin) / sx;\n                let zc = (pc * cos + pd * sin) / sy;\n                let s = Math.sqrt(za * za + zc * zc);\n\n                if (s > 0.00001) s = 1 / s;\n                za *= s;\n                zc *= s;\n                s = Math.sqrt(za * za + zc * zc);\n                if (this.data.transformMode == TransformMode.NoScale && pa * pd - pb * pc < 0 != (sx < 0 != sy < 0)) s = -s;\n                const r = Math.PI / 2 + Math.atan2(zc, za);\n                const zb = Math.cos(r) * s;\n                const zd = Math.sin(r) * s;\n                const la = MathUtils.cosDeg(shearX) * scaleX;\n                const lb = MathUtils.cosDeg(90 + shearY) * scaleY;\n                const lc = MathUtils.sinDeg(shearX) * scaleX;\n                const ld = MathUtils.sinDeg(90 + shearY) * scaleY;\n\n                m.a = za * la + zb * lc;\n                m.c = za * lb + zb * ld;\n                m.b = zc * la + zd * lc;\n                m.d = zc * lb + zd * ld;\n                break;\n            }\n        }\n        m.a *= sx;\n        m.c *= sx;\n        m.b *= sy;\n        m.d *= sy;\n    }\n\n    /** Sets this bone's local transform to the setup pose. */\n    setToSetupPose() {\n        const data = this.data;\n\n        this.x = data.x;\n        this.y = data.y;\n        this.rotation = data.rotation;\n        this.scaleX = data.scaleX;\n        this.scaleY = data.scaleY;\n        this.shearX = data.shearX;\n        this.shearY = data.shearY;\n    }\n\n    /** The world rotation for the X axis, calculated using {@link #a} and {@link #c}. */\n    getWorldRotationX() {\n        return Math.atan2(this.matrix.b, this.matrix.a) * MathUtils.radDeg;\n    }\n\n    /** The world rotation for the Y axis, calculated using {@link #b} and {@link #d}. */\n    getWorldRotationY() {\n        return Math.atan2(this.matrix.d, this.matrix.c) * MathUtils.radDeg;\n    }\n\n    /** The magnitude (always positive) of the world scale X, calculated using {@link #a} and {@link #c}. */\n    getWorldScaleX() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.a * m.a + m.b * m.b);\n    }\n\n    /** The magnitude (always positive) of the world scale Y, calculated using {@link #b} and {@link #d}. */\n    getWorldScaleY() {\n        const m = this.matrix;\n\n        return Math.sqrt(m.c * m.c + m.d * m.d);\n    }\n\n    /** Computes the applied transform values from the world transform.\n     *\n     * If the world transform is modified (by a constraint, {@link #rotateWorld(float)}, etc) then this method should be called so\n     * the applied transform matches the world transform. The applied transform may be needed by other code (eg to apply other\n     * constraints).\n     *\n     * Some information is ambiguous in the world transform, such as -1,-1 scale versus 180 rotation. The applied transform after\n     * calling this method is equivalent to the local transform used to compute the world transform, but may not be identical. */\n    updateAppliedTransform() {\n        const parent = this.parent;\n        const m = this.matrix;\n\n        if (!parent) {\n            this.ax = m.tx - this.skeleton.x;\n            this.ay = m.ty - this.skeleton.y;\n            this.arotation = Math.atan2(m.b, m.a) * MathUtils.radDeg;\n            this.ascaleX = Math.sqrt(m.a * m.a + m.b * m.b);\n            this.ascaleY = Math.sqrt(m.c * m.c + m.d * m.d);\n            this.ashearX = 0;\n            this.ashearY = Math.atan2(m.a * m.c + m.b * m.d, m.a * m.d - m.b * m.c) * MathUtils.radDeg;\n\n            return;\n        }\n        const pm = parent.matrix;\n        const pid = 1 / (pm.a * pm.d - pm.b * pm.c);\n        const dx = m.tx - pm.tx;\n        const dy = m.ty - pm.ty;\n\n        this.ax = dx * pm.d * pid - dy * pm.c * pid;\n        this.ay = dy * pm.a * pid - dx * pm.b * pid;\n        const ia = pid * pm.d;\n        const id = pid * pm.a;\n        const ib = pid * pm.c;\n        const ic = pid * pm.b;\n        const ra = ia * m.a - ib * m.b;\n        const rb = ia * m.c - ib * m.d;\n        const rc = id * m.b - ic * m.a;\n        const rd = id * m.d - ic * m.c;\n\n        this.ashearX = 0;\n        this.ascaleX = Math.sqrt(ra * ra + rc * rc);\n        if (this.ascaleX > 0.0001) {\n            const det = ra * rd - rb * rc;\n\n            this.ascaleY = det / this.ascaleX;\n            this.ashearY = Math.atan2(ra * rb + rc * rd, det) * MathUtils.radDeg;\n            this.arotation = Math.atan2(rc, ra) * MathUtils.radDeg;\n        } else {\n            this.ascaleX = 0;\n            this.ascaleY = Math.sqrt(rb * rb + rd * rd);\n            this.ashearY = 0;\n            this.arotation = 90 - Math.atan2(rd, rb) * MathUtils.radDeg;\n        }\n    }\n\n    /** Transforms a point from world coordinates to the bone's local coordinates. */\n    worldToLocal(world: Vector2) {\n        const m = this.matrix;\n        const a = m.a;\n        const b = m.c;\n        const c = m.b;\n        const d = m.d;\n        const invDet = 1 / (a * d - b * c);\n        const x = world.x - m.tx;\n        const y = world.y - m.ty;\n\n        world.x = x * d * invDet - y * b * invDet;\n        world.y = y * a * invDet - x * c * invDet;\n\n        return world;\n    }\n\n    /** Transforms a point from the bone's local coordinates to world coordinates. */\n    localToWorld(local: Vector2) {\n        const m = this.matrix;\n        const x = local.x;\n        const y = local.y;\n\n        local.x = x * m.a + y * m.c + m.tx;\n        local.y = x * m.b + y * m.d + m.ty;\n\n        return local;\n    }\n\n    /** Transforms a world rotation to a local rotation. */\n    worldToLocalRotation(worldRotation: number) {\n        const sin = MathUtils.sinDeg(worldRotation);\n        const cos = MathUtils.cosDeg(worldRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(mat.a * sin - mat.b * cos, mat.d * cos - mat.c * sin) * MathUtils.radDeg;\n    }\n\n    /** Transforms a local rotation to a world rotation. */\n    localToWorldRotation(localRotation: number) {\n        localRotation -= this.rotation - this.shearX;\n        const sin = MathUtils.sinDeg(localRotation);\n        const cos = MathUtils.cosDeg(localRotation);\n        const mat = this.matrix;\n\n        return Math.atan2(cos * mat.b + sin * mat.d, cos * mat.a + sin * mat.c) * MathUtils.radDeg;\n    }\n\n    /** Rotates the world transform the specified amount.\n     * <p>\n     * After changes are made to the world transform, {@link #updateAppliedTransform()} should be called and {@link #update()} will\n     * need to be called on any child bones, recursively. */\n    rotateWorld(degrees: number) {\n        const mat = this.matrix;\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        const cos = MathUtils.cosDeg(degrees);\n        const sin = MathUtils.sinDeg(degrees);\n\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}