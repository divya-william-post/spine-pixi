{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport './attachments/Attachment.mjs';\nimport { RotateMode, Utils, MathUtils, PositionMode } from '@pixi-spine/base';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\nimport { SpacingMode } from './PathConstraintData.mjs';\nconst _PathConstraint = class {\n  constructor(data, skeleton) {\n    /** The position along the path. */\n    this.position = 0;\n    /** The spacing between bones. */\n    this.spacing = 0;\n    this.mixRotate = 0;\n    this.mixX = 0;\n    this.mixY = 0;\n    this.spaces = new Array();\n    this.positions = new Array();\n    this.world = new Array();\n    this.curves = new Array();\n    this.lengths = new Array();\n    this.segments = new Array();\n    this.active = false;\n    if (!data) throw new Error(\"data cannot be null.\");\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0, n = data.bones.length; i < n; i++) {\n      const bone = skeleton.findBone(data.bones[i].name);\n      if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n      this.bones.push(bone);\n    }\n    const target = skeleton.findSlot(data.target.name);\n    if (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\n    this.target = target;\n    this.position = data.position;\n    this.spacing = data.spacing;\n    this.mixRotate = data.mixRotate;\n    this.mixX = data.mixX;\n    this.mixY = data.mixY;\n  }\n  isActive() {\n    return this.active;\n  }\n  update() {\n    const attachment = this.target.getAttachment();\n    if (!(attachment instanceof PathAttachment)) return;\n    const mixRotate = this.mixRotate;\n    const mixX = this.mixX;\n    const mixY = this.mixY;\n    if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n    const data = this.data;\n    const tangents = data.rotateMode == RotateMode.Tangent;\n    const scale = data.rotateMode == RotateMode.ChainScale;\n    const bones = this.bones;\n    const boneCount = bones.length;\n    const spacesCount = tangents ? boneCount : boneCount + 1;\n    const spaces = Utils.setArraySize(this.spaces, spacesCount);\n    const lengths = scale ? this.lengths = Utils.setArraySize(this.lengths, boneCount) : [];\n    const spacing = this.spacing;\n    switch (data.spacingMode) {\n      case SpacingMode.Percent:\n        if (scale) {\n          for (let i = 0, n = spacesCount - 1; i < n; i++) {\n            const bone = bones[i];\n            const setupLength = bone.data.length;\n            if (setupLength < _PathConstraint.epsilon) lengths[i] = 0;else {\n              const x = setupLength * bone.matrix.a;\n              const y = setupLength * bone.matrix.b;\n              lengths[i] = Math.sqrt(x * x + y * y);\n            }\n          }\n        }\n        Utils.arrayFill(spaces, 1, spacesCount, spacing);\n        break;\n      case SpacingMode.Proportional:\n        let sum = 0;\n        for (let i = 0, n = spacesCount - 1; i < n;) {\n          const bone = bones[i];\n          const setupLength = bone.data.length;\n          if (setupLength < _PathConstraint.epsilon) {\n            if (scale) lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            const x = setupLength * bone.matrix.a;\n            const y = setupLength * bone.matrix.b;\n            const length = Math.sqrt(x * x + y * y);\n            if (scale) lengths[i] = length;\n            spaces[++i] = length;\n            sum += length;\n          }\n        }\n        if (sum > 0) {\n          sum = spacesCount / sum * spacing;\n          for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\n        }\n        break;\n      default:\n        const lengthSpacing = data.spacingMode == SpacingMode.Length;\n        for (let i = 0, n = spacesCount - 1; i < n;) {\n          const bone = bones[i];\n          const setupLength = bone.data.length;\n          if (setupLength < _PathConstraint.epsilon) {\n            if (scale) lengths[i] = 0;\n            spaces[++i] = spacing;\n          } else {\n            const x = setupLength * bone.matrix.a;\n            const y = setupLength * bone.matrix.b;\n            const length = Math.sqrt(x * x + y * y);\n            if (scale) lengths[i] = length;\n            spaces[++i] = (lengthSpacing ? setupLength + spacing : spacing) * length / setupLength;\n          }\n        }\n    }\n    const positions = this.computeWorldPositions(attachment, spacesCount, tangents);\n    let boneX = positions[0];\n    let boneY = positions[1];\n    let offsetRotation = data.offsetRotation;\n    let tip = false;\n    if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;else {\n      tip = false;\n      const p = this.target.bone.matrix;\n      offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n    }\n    for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n      const bone = bones[i];\n      const mat = bone.matrix;\n      mat.tx += (boneX - mat.tx) * mixX;\n      mat.ty += (boneY - mat.ty) * mixY;\n      const x = positions[p];\n      const y = positions[p + 1];\n      const dx = x - boneX;\n      const dy = y - boneY;\n      if (scale) {\n        const length = lengths[i];\n        if (length != 0) {\n          const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n          mat.a *= s;\n          mat.b *= s;\n        }\n      }\n      boneX = x;\n      boneY = y;\n      if (mixRotate > 0) {\n        const a = mat.a;\n        const b = mat.c;\n        const c = mat.b;\n        const d = mat.d;\n        let r = 0;\n        let cos = 0;\n        let sin = 0;\n        if (tangents) r = positions[p - 1];else if (spaces[i + 1] == 0) r = positions[p + 2];else r = Math.atan2(dy, dx);\n        r -= Math.atan2(c, a);\n        if (tip) {\n          cos = Math.cos(r);\n          sin = Math.sin(r);\n          const length = bone.data.length;\n          boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n          boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n        } else {\n          r += offsetRotation;\n        }\n        if (r > MathUtils.PI) r -= MathUtils.PI2;else if (r < -MathUtils.PI) r += MathUtils.PI2;\n        r *= mixRotate;\n        cos = Math.cos(r);\n        sin = Math.sin(r);\n        mat.a = cos * a - sin * c;\n        mat.c = cos * b - sin * d;\n        mat.b = sin * a + cos * c;\n        mat.d = sin * b + cos * d;\n      }\n      bone.updateAppliedTransform();\n    }\n  }\n  computeWorldPositions(path, spacesCount, tangents) {\n    const target = this.target;\n    let position = this.position;\n    const spaces = this.spaces;\n    const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n    let world = this.world;\n    const closed = path.closed;\n    let verticesLength = path.worldVerticesLength;\n    let curveCount = verticesLength / 6;\n    let prevCurve = _PathConstraint.NONE;\n    if (!path.constantSpeed) {\n      const lengths = path.lengths;\n      curveCount -= closed ? 1 : 2;\n      const pathLength2 = lengths[curveCount];\n      if (this.data.positionMode == PositionMode.Percent) position *= pathLength2;\n      let multiplier2;\n      switch (this.data.spacingMode) {\n        case SpacingMode.Percent:\n          multiplier2 = pathLength2;\n          break;\n        case SpacingMode.Proportional:\n          multiplier2 = pathLength2 / spacesCount;\n          break;\n        default:\n          multiplier2 = 1;\n      }\n      world = Utils.setArraySize(this.world, 8);\n      for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n        const space = spaces[i] * multiplier2;\n        position += space;\n        let p = position;\n        if (closed) {\n          p %= pathLength2;\n          if (p < 0) p += pathLength2;\n          curve = 0;\n        } else if (p < 0) {\n          if (prevCurve != _PathConstraint.BEFORE) {\n            prevCurve = _PathConstraint.BEFORE;\n            path.computeWorldVertices(target, 2, 4, world, 0, 2);\n          }\n          this.addBeforePosition(p, world, 0, out, o);\n          continue;\n        } else if (p > pathLength2) {\n          if (prevCurve != _PathConstraint.AFTER) {\n            prevCurve = _PathConstraint.AFTER;\n            path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n          }\n          this.addAfterPosition(p - pathLength2, world, 0, out, o);\n          continue;\n        }\n        for (;; curve++) {\n          const length = lengths[curve];\n          if (p > length) continue;\n          if (curve == 0) p /= length;else {\n            const prev = lengths[curve - 1];\n            p = (p - prev) / (length - prev);\n          }\n          break;\n        }\n        if (curve != prevCurve) {\n          prevCurve = curve;\n          if (closed && curve == curveCount) {\n            path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 4, world, 4, 2);\n          } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n        }\n        this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || i > 0 && space == 0);\n      }\n      return out;\n    }\n    if (closed) {\n      verticesLength += 2;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n      path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n      world[verticesLength - 2] = world[0];\n      world[verticesLength - 1] = world[1];\n    } else {\n      curveCount--;\n      verticesLength -= 4;\n      world = Utils.setArraySize(this.world, verticesLength);\n      path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n    }\n    const curves = Utils.setArraySize(this.curves, curveCount);\n    let pathLength = 0;\n    let x1 = world[0];\n    let y1 = world[1];\n    let cx1 = 0;\n    let cy1 = 0;\n    let cx2 = 0;\n    let cy2 = 0;\n    let x2 = 0;\n    let y2 = 0;\n    let tmpx = 0;\n    let tmpy = 0;\n    let dddfx = 0;\n    let dddfy = 0;\n    let ddfx = 0;\n    let ddfy = 0;\n    let dfx = 0;\n    let dfy = 0;\n    for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n      cx1 = world[w];\n      cy1 = world[w + 1];\n      cx2 = world[w + 2];\n      cy2 = world[w + 3];\n      x2 = world[w + 4];\n      y2 = world[w + 5];\n      tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n      tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n      dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n      dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n      ddfx = tmpx * 2 + dddfx;\n      ddfy = tmpy * 2 + dddfy;\n      dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n      dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      ddfx += dddfx;\n      ddfy += dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx;\n      dfy += ddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      dfx += ddfx + dddfx;\n      dfy += ddfy + dddfy;\n      pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n      curves[i] = pathLength;\n      x1 = x2;\n      y1 = y2;\n    }\n    if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n    let multiplier;\n    switch (this.data.spacingMode) {\n      case SpacingMode.Percent:\n        multiplier = pathLength;\n        break;\n      case SpacingMode.Proportional:\n        multiplier = pathLength / spacesCount;\n        break;\n      default:\n        multiplier = 1;\n    }\n    const segments = this.segments;\n    let curveLength = 0;\n    for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n      const space = spaces[i] * multiplier;\n      position += space;\n      let p = position;\n      if (closed) {\n        p %= pathLength;\n        if (p < 0) p += pathLength;\n        curve = 0;\n      } else if (p < 0) {\n        this.addBeforePosition(p, world, 0, out, o);\n        continue;\n      } else if (p > pathLength) {\n        this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n        continue;\n      }\n      for (;; curve++) {\n        const length = curves[curve];\n        if (p > length) continue;\n        if (curve == 0) p /= length;else {\n          const prev = curves[curve - 1];\n          p = (p - prev) / (length - prev);\n        }\n        break;\n      }\n      if (curve != prevCurve) {\n        prevCurve = curve;\n        let ii = curve * 6;\n        x1 = world[ii];\n        y1 = world[ii + 1];\n        cx1 = world[ii + 2];\n        cy1 = world[ii + 3];\n        cx2 = world[ii + 4];\n        cy2 = world[ii + 5];\n        x2 = world[ii + 6];\n        y2 = world[ii + 7];\n        tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n        tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n        dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 6e-3;\n        dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 6e-3;\n        ddfx = tmpx * 2 + dddfx;\n        ddfy = tmpy * 2 + dddfy;\n        dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n        dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n        curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[0] = curveLength;\n        for (ii = 1; ii < 8; ii++) {\n          dfx += ddfx;\n          dfy += ddfy;\n          ddfx += dddfx;\n          ddfy += dddfy;\n          curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n          segments[ii] = curveLength;\n        }\n        dfx += ddfx;\n        dfy += ddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[8] = curveLength;\n        dfx += ddfx + dddfx;\n        dfy += ddfy + dddfy;\n        curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n        segments[9] = curveLength;\n        segment = 0;\n      }\n      p *= curveLength;\n      for (;; segment++) {\n        const length = segments[segment];\n        if (p > length) continue;\n        if (segment == 0) p /= length;else {\n          const prev = segments[segment - 1];\n          p = segment + (p - prev) / (length - prev);\n        }\n        break;\n      }\n      this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || i > 0 && space == 0);\n    }\n    return out;\n  }\n  addBeforePosition(p, temp, i, out, o) {\n    const x1 = temp[i];\n    const y1 = temp[i + 1];\n    const dx = temp[i + 2] - x1;\n    const dy = temp[i + 3] - y1;\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addAfterPosition(p, temp, i, out, o) {\n    const x1 = temp[i + 2];\n    const y1 = temp[i + 3];\n    const dx = x1 - temp[i];\n    const dy = y1 - temp[i + 1];\n    const r = Math.atan2(dy, dx);\n    out[o] = x1 + p * Math.cos(r);\n    out[o + 1] = y1 + p * Math.sin(r);\n    out[o + 2] = r;\n  }\n  addCurvePosition(p, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents) {\n    if (p == 0 || isNaN(p)) {\n      out[o] = x1;\n      out[o + 1] = y1;\n      out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n      return;\n    }\n    const tt = p * p;\n    const ttt = tt * p;\n    const u = 1 - p;\n    const uu = u * u;\n    const uuu = uu * u;\n    const ut = u * p;\n    const ut3 = ut * 3;\n    const uut3 = u * ut3;\n    const utt3 = ut3 * p;\n    const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n    const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n    out[o] = x;\n    out[o + 1] = y;\n    if (tangents) {\n      if (p < 1e-3) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n    }\n  }\n};\nlet PathConstraint = _PathConstraint;\nPathConstraint.NONE = -1;\nPathConstraint.BEFORE = -2;\nPathConstraint.AFTER = -3;\nPathConstraint.epsilon = 1e-5;\nexport { PathConstraint };","map":{"version":3,"names":["_PathConstraint","constructor","data","skeleton","position","spacing","mixRotate","mixX","mixY","spaces","Array","positions","world","curves","lengths","segments","active","Error","bones","i","n","length","bone","findBone","name","push","target","findSlot","isActive","update","attachment","getAttachment","PathAttachment","tangents","rotateMode","RotateMode","Tangent","scale","ChainScale","boneCount","spacesCount","Utils","setArraySize","spacingMode","SpacingMode","Percent","setupLength","epsilon","x","matrix","a","y","b","Math","sqrt","arrayFill","Proportional","sum","lengthSpacing","Length","computeWorldPositions","boneX","boneY","offsetRotation","tip","Chain","p","d","c","MathUtils","degRad","mat","tx","ty","dx","dy","s","r","cos","sin","atan2","PI","PI2","updateAppliedTransform","path","out","closed","verticesLength","worldVerticesLength","curveCount","prevCurve","NONE","constantSpeed","pathLength2","positionMode","PositionMode","multiplier2","o","curve","space","BEFORE","computeWorldVertices","addBeforePosition","AFTER","addAfterPosition","prev","addCurvePosition","pathLength","x1","y1","cx1","cy1","cx2","cy2","x2","y2","tmpx","tmpy","dddfx","dddfy","ddfx","ddfy","dfx","dfy","w","multiplier","curveLength","segment","ii","temp","isNaN","tt","ttt","u","uu","uuu","ut","ut3","uut3","utt3","PathConstraint"],"sources":["../../src/core/PathConstraint.ts"],"sourcesContent":["import { PathAttachment } from './attachments';\nimport type { Updatable } from './Updatable';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport type { Bone } from './Bone';\nimport type { Slot } from './Slot';\nimport type { Skeleton } from './Skeleton';\nimport { MathUtils, PositionMode, RotateMode, Utils } from '@pixi-spine/base';\n/** Stores the current pose for a path constraint. A path constraint adjusts the rotation, translation, and scale of the\n * constrained bones so they follow a {@link PathAttachment}.\n *\n * See [Path constraints](http://esotericsoftware.com/spine-path-constraints) in the Spine User Guide.\n * @public\n * */\nexport class PathConstraint implements Updatable {\n    static NONE = -1;\n    static BEFORE = -2;\n    static AFTER = -3;\n    static epsilon = 0.00001;\n\n    /** The path constraint's setup pose data. */\n    data: PathConstraintData;\n\n    /** The bones that will be modified by this path constraint. */\n    bones: Array<Bone>;\n\n    /** The slot whose path attachment will be used to constrained the bones. */\n    target: Slot;\n\n    /** The position along the path. */\n    position = 0;\n\n    /** The spacing between bones. */\n    spacing = 0;\n\n    mixRotate = 0;\n\n    mixX = 0;\n\n    mixY = 0;\n\n    spaces = new Array<number>();\n    positions = new Array<number>();\n    world = new Array<number>();\n    curves = new Array<number>();\n    lengths = new Array<number>();\n    segments = new Array<number>();\n\n    active = false;\n\n    constructor(data: PathConstraintData, skeleton: Skeleton) {\n        if (!data) throw new Error('data cannot be null.');\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        this.data = data;\n        this.bones = new Array<Bone>();\n        for (let i = 0, n = data.bones.length; i < n; i++) {\n            const bone = skeleton.findBone(data.bones[i].name);\n\n            if (!bone) throw new Error(`Couldn't find bone ${data.bones[i].name}.`);\n            this.bones.push(bone);\n        }\n        const target = skeleton.findSlot(data.target.name);\n\n        if (!target) throw new Error(`Couldn't find target bone ${data.target.name}`);\n        this.target = target;\n        this.position = data.position;\n        this.spacing = data.spacing;\n        this.mixRotate = data.mixRotate;\n        this.mixX = data.mixX;\n        this.mixY = data.mixY;\n    }\n\n    isActive() {\n        return this.active;\n    }\n\n    update() {\n        const attachment = this.target.getAttachment();\n\n        if (!(attachment instanceof PathAttachment)) return;\n\n        const mixRotate = this.mixRotate;\n        const mixX = this.mixX;\n        const mixY = this.mixY;\n\n        if (mixRotate == 0 && mixX == 0 && mixY == 0) return;\n\n        const data = this.data;\n        const tangents = data.rotateMode == RotateMode.Tangent;\n        const scale = data.rotateMode == RotateMode.ChainScale;\n\n        const bones = this.bones;\n        const boneCount = bones.length;\n        const spacesCount = tangents ? boneCount : boneCount + 1;\n        const spaces = Utils.setArraySize(this.spaces, spacesCount);\n        const lengths: Array<number> = scale ? (this.lengths = Utils.setArraySize(this.lengths, boneCount)) : [];\n        const spacing = this.spacing;\n\n        switch (data.spacingMode) {\n            case SpacingMode.Percent:\n                if (scale) {\n                    for (let i = 0, n = spacesCount - 1; i < n; i++) {\n                        const bone = bones[i];\n                        const setupLength = bone.data.length;\n\n                        if (setupLength < PathConstraint.epsilon) lengths[i] = 0;\n                        else {\n                            const x = setupLength * bone.matrix.a;\n                            const y = setupLength * bone.matrix.b;\n\n                            lengths[i] = Math.sqrt(x * x + y * y);\n                        }\n                    }\n                }\n                Utils.arrayFill(spaces, 1, spacesCount, spacing);\n                break;\n            case SpacingMode.Proportional:\n                let sum = 0;\n\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\n                    const bone = bones[i];\n                    const setupLength = bone.data.length;\n\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale) lengths[i] = 0;\n                        spaces[++i] = spacing;\n                    } else {\n                        const x = setupLength * bone.matrix.a;\n                        const y = setupLength * bone.matrix.b;\n                        const length = Math.sqrt(x * x + y * y);\n\n                        if (scale) lengths[i] = length;\n                        spaces[++i] = length;\n                        sum += length;\n                    }\n                }\n                if (sum > 0) {\n                    sum = (spacesCount / sum) * spacing;\n                    for (let i = 1; i < spacesCount; i++) spaces[i] *= sum;\n                }\n                break;\n            default:\n                const lengthSpacing = data.spacingMode == SpacingMode.Length;\n\n                for (let i = 0, n = spacesCount - 1; i < n; ) {\n                    const bone = bones[i];\n                    const setupLength = bone.data.length;\n\n                    if (setupLength < PathConstraint.epsilon) {\n                        if (scale) lengths[i] = 0;\n                        spaces[++i] = spacing;\n                    } else {\n                        const x = setupLength * bone.matrix.a;\n                        const y = setupLength * bone.matrix.b;\n                        const length = Math.sqrt(x * x + y * y);\n\n                        if (scale) lengths[i] = length;\n                        spaces[++i] = ((lengthSpacing ? setupLength + spacing : spacing) * length) / setupLength;\n                    }\n                }\n        }\n\n        const positions = this.computeWorldPositions(<PathAttachment>attachment, spacesCount, tangents);\n        let boneX = positions[0];\n        let boneY = positions[1];\n        let offsetRotation = data.offsetRotation;\n        let tip = false;\n\n        if (offsetRotation == 0) tip = data.rotateMode == RotateMode.Chain;\n        else {\n            tip = false;\n            const p = this.target.bone.matrix;\n\n            offsetRotation *= p.a * p.d - p.b * p.c > 0 ? MathUtils.degRad : -MathUtils.degRad;\n        }\n        for (let i = 0, p = 3; i < boneCount; i++, p += 3) {\n            const bone = bones[i];\n            const mat = bone.matrix;\n\n            mat.tx += (boneX - mat.tx) * mixX;\n            mat.ty += (boneY - mat.ty) * mixY;\n            const x = positions[p];\n            const y = positions[p + 1];\n            const dx = x - boneX;\n            const dy = y - boneY;\n\n            if (scale) {\n                const length = lengths[i];\n\n                if (length != 0) {\n                    const s = (Math.sqrt(dx * dx + dy * dy) / length - 1) * mixRotate + 1;\n\n                    mat.a *= s;\n                    mat.b *= s;\n                }\n            }\n            boneX = x;\n            boneY = y;\n            if (mixRotate > 0) {\n                const a = mat.a;\n                const b = mat.c;\n                const c = mat.b;\n                const d = mat.d;\n                let r = 0;\n                let cos = 0;\n                let sin = 0;\n\n                if (tangents) r = positions[p - 1];\n                else if (spaces[i + 1] == 0) r = positions[p + 2];\n                else r = Math.atan2(dy, dx);\n                r -= Math.atan2(c, a);\n                if (tip) {\n                    cos = Math.cos(r);\n                    sin = Math.sin(r);\n                    const length = bone.data.length;\n\n                    boneX += (length * (cos * a - sin * c) - dx) * mixRotate;\n                    boneY += (length * (sin * a + cos * c) - dy) * mixRotate;\n                } else {\n                    r += offsetRotation;\n                }\n                if (r > MathUtils.PI) r -= MathUtils.PI2;\n                else if (r < -MathUtils.PI)\n                    //\n                    r += MathUtils.PI2;\n                r *= mixRotate;\n                cos = Math.cos(r);\n                sin = Math.sin(r);\n                mat.a = cos * a - sin * c;\n                mat.c = cos * b - sin * d;\n                mat.b = sin * a + cos * c;\n                mat.d = sin * b + cos * d;\n            }\n            bone.updateAppliedTransform();\n        }\n    }\n\n    computeWorldPositions(path: PathAttachment, spacesCount: number, tangents: boolean) {\n        const target = this.target;\n        let position = this.position;\n        const spaces = this.spaces;\n        const out = Utils.setArraySize(this.positions, spacesCount * 3 + 2);\n        let world: Array<number> = this.world;\n        const closed = path.closed;\n        let verticesLength = path.worldVerticesLength;\n        let curveCount = verticesLength / 6;\n        let prevCurve = PathConstraint.NONE;\n\n        if (!path.constantSpeed) {\n            const lengths = path.lengths;\n\n            curveCount -= closed ? 1 : 2;\n            const pathLength = lengths[curveCount];\n\n            if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n            let multiplier;\n\n            switch (this.data.spacingMode) {\n                case SpacingMode.Percent:\n                    multiplier = pathLength;\n                    break;\n                case SpacingMode.Proportional:\n                    multiplier = pathLength / spacesCount;\n                    break;\n                default:\n                    multiplier = 1;\n            }\n            world = Utils.setArraySize(this.world, 8);\n            for (let i = 0, o = 0, curve = 0; i < spacesCount; i++, o += 3) {\n                const space = spaces[i] * multiplier;\n\n                position += space;\n                let p = position;\n\n                if (closed) {\n                    p %= pathLength;\n                    if (p < 0) p += pathLength;\n                    curve = 0;\n                } else if (p < 0) {\n                    if (prevCurve != PathConstraint.BEFORE) {\n                        prevCurve = PathConstraint.BEFORE;\n                        path.computeWorldVertices(target, 2, 4, world, 0, 2);\n                    }\n                    this.addBeforePosition(p, world, 0, out, o);\n                    continue;\n                } else if (p > pathLength) {\n                    if (prevCurve != PathConstraint.AFTER) {\n                        prevCurve = PathConstraint.AFTER;\n                        path.computeWorldVertices(target, verticesLength - 6, 4, world, 0, 2);\n                    }\n                    this.addAfterPosition(p - pathLength, world, 0, out, o);\n                    continue;\n                }\n\n                // Determine curve containing position.\n                for (; ; curve++) {\n                    const length = lengths[curve];\n\n                    if (p > length) continue;\n                    if (curve == 0) p /= length;\n                    else {\n                        const prev = lengths[curve - 1];\n\n                        p = (p - prev) / (length - prev);\n                    }\n                    break;\n                }\n                if (curve != prevCurve) {\n                    prevCurve = curve;\n                    if (closed && curve == curveCount) {\n                        path.computeWorldVertices(target, verticesLength - 4, 4, world, 0, 2);\n                        path.computeWorldVertices(target, 0, 4, world, 4, 2);\n                    } else path.computeWorldVertices(target, curve * 6 + 2, 8, world, 0, 2);\n                }\n                this.addCurvePosition(p, world[0], world[1], world[2], world[3], world[4], world[5], world[6], world[7], out, o, tangents || (i > 0 && space == 0));\n            }\n\n            return out;\n        }\n\n        // World vertices.\n        if (closed) {\n            verticesLength += 2;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength - 4, world, 0, 2);\n            path.computeWorldVertices(target, 0, 2, world, verticesLength - 4, 2);\n            world[verticesLength - 2] = world[0];\n            world[verticesLength - 1] = world[1];\n        } else {\n            curveCount--;\n            verticesLength -= 4;\n            world = Utils.setArraySize(this.world, verticesLength);\n            path.computeWorldVertices(target, 2, verticesLength, world, 0, 2);\n        }\n\n        // Curve lengths.\n        const curves = Utils.setArraySize(this.curves, curveCount);\n        let pathLength = 0;\n        let x1 = world[0];\n        let y1 = world[1];\n        let cx1 = 0;\n        let cy1 = 0;\n        let cx2 = 0;\n        let cy2 = 0;\n        let x2 = 0;\n        let y2 = 0;\n        let tmpx = 0;\n        let tmpy = 0;\n        let dddfx = 0;\n        let dddfy = 0;\n        let ddfx = 0;\n        let ddfy = 0;\n        let dfx = 0;\n        let dfy = 0;\n\n        for (let i = 0, w = 2; i < curveCount; i++, w += 6) {\n            cx1 = world[w];\n            cy1 = world[w + 1];\n            cx2 = world[w + 2];\n            cy2 = world[w + 3];\n            x2 = world[w + 4];\n            y2 = world[w + 5];\n            tmpx = (x1 - cx1 * 2 + cx2) * 0.1875;\n            tmpy = (y1 - cy1 * 2 + cy2) * 0.1875;\n            dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.09375;\n            dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.09375;\n            ddfx = tmpx * 2 + dddfx;\n            ddfy = tmpy * 2 + dddfy;\n            dfx = (cx1 - x1) * 0.75 + tmpx + dddfx * 0.16666667;\n            dfy = (cy1 - y1) * 0.75 + tmpy + dddfy * 0.16666667;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            ddfx += dddfx;\n            ddfy += dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx;\n            dfy += ddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            dfx += ddfx + dddfx;\n            dfy += ddfy + dddfy;\n            pathLength += Math.sqrt(dfx * dfx + dfy * dfy);\n            curves[i] = pathLength;\n            x1 = x2;\n            y1 = y2;\n        }\n\n        if (this.data.positionMode == PositionMode.Percent) position *= pathLength;\n\n        let multiplier;\n\n        switch (this.data.spacingMode) {\n            case SpacingMode.Percent:\n                multiplier = pathLength;\n                break;\n            case SpacingMode.Proportional:\n                multiplier = pathLength / spacesCount;\n                break;\n            default:\n                multiplier = 1;\n        }\n\n        const segments = this.segments;\n        let curveLength = 0;\n\n        for (let i = 0, o = 0, curve = 0, segment = 0; i < spacesCount; i++, o += 3) {\n            const space = spaces[i] * multiplier;\n\n            position += space;\n            let p = position;\n\n            if (closed) {\n                p %= pathLength;\n                if (p < 0) p += pathLength;\n                curve = 0;\n            } else if (p < 0) {\n                this.addBeforePosition(p, world, 0, out, o);\n                continue;\n            } else if (p > pathLength) {\n                this.addAfterPosition(p - pathLength, world, verticesLength - 4, out, o);\n                continue;\n            }\n\n            // Determine curve containing position.\n            for (; ; curve++) {\n                const length = curves[curve];\n\n                if (p > length) continue;\n                if (curve == 0) p /= length;\n                else {\n                    const prev = curves[curve - 1];\n\n                    p = (p - prev) / (length - prev);\n                }\n                break;\n            }\n\n            // Curve segment lengths.\n            if (curve != prevCurve) {\n                prevCurve = curve;\n                let ii = curve * 6;\n\n                x1 = world[ii];\n                y1 = world[ii + 1];\n                cx1 = world[ii + 2];\n                cy1 = world[ii + 3];\n                cx2 = world[ii + 4];\n                cy2 = world[ii + 5];\n                x2 = world[ii + 6];\n                y2 = world[ii + 7];\n                tmpx = (x1 - cx1 * 2 + cx2) * 0.03;\n                tmpy = (y1 - cy1 * 2 + cy2) * 0.03;\n                dddfx = ((cx1 - cx2) * 3 - x1 + x2) * 0.006;\n                dddfy = ((cy1 - cy2) * 3 - y1 + y2) * 0.006;\n                ddfx = tmpx * 2 + dddfx;\n                ddfy = tmpy * 2 + dddfy;\n                dfx = (cx1 - x1) * 0.3 + tmpx + dddfx * 0.16666667;\n                dfy = (cy1 - y1) * 0.3 + tmpy + dddfy * 0.16666667;\n                curveLength = Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[0] = curveLength;\n                for (ii = 1; ii < 8; ii++) {\n                    dfx += ddfx;\n                    dfy += ddfy;\n                    ddfx += dddfx;\n                    ddfy += dddfy;\n                    curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                    segments[ii] = curveLength;\n                }\n                dfx += ddfx;\n                dfy += ddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[8] = curveLength;\n                dfx += ddfx + dddfx;\n                dfy += ddfy + dddfy;\n                curveLength += Math.sqrt(dfx * dfx + dfy * dfy);\n                segments[9] = curveLength;\n                segment = 0;\n            }\n\n            // Weight by segment length.\n            p *= curveLength;\n            for (; ; segment++) {\n                const length = segments[segment];\n\n                if (p > length) continue;\n                if (segment == 0) p /= length;\n                else {\n                    const prev = segments[segment - 1];\n\n                    p = segment + (p - prev) / (length - prev);\n                }\n                break;\n            }\n            this.addCurvePosition(p * 0.1, x1, y1, cx1, cy1, cx2, cy2, x2, y2, out, o, tangents || (i > 0 && space == 0));\n        }\n\n        return out;\n    }\n\n    addBeforePosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i];\n        const y1 = temp[i + 1];\n        const dx = temp[i + 2] - x1;\n        const dy = temp[i + 3] - y1;\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addAfterPosition(p: number, temp: Array<number>, i: number, out: Array<number>, o: number) {\n        const x1 = temp[i + 2];\n        const y1 = temp[i + 3];\n        const dx = x1 - temp[i];\n        const dy = y1 - temp[i + 1];\n        const r = Math.atan2(dy, dx);\n\n        out[o] = x1 + p * Math.cos(r);\n        out[o + 1] = y1 + p * Math.sin(r);\n        out[o + 2] = r;\n    }\n\n    addCurvePosition(\n        p: number,\n        x1: number,\n        y1: number,\n        cx1: number,\n        cy1: number,\n        cx2: number,\n        cy2: number,\n        x2: number,\n        y2: number,\n        out: Array<number>,\n        o: number,\n        tangents: boolean\n    ) {\n        if (p == 0 || isNaN(p)) {\n            out[o] = x1;\n            out[o + 1] = y1;\n            out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n\n            return;\n        }\n        const tt = p * p;\n        const ttt = tt * p;\n        const u = 1 - p;\n        const uu = u * u;\n        const uuu = uu * u;\n        const ut = u * p;\n        const ut3 = ut * 3;\n        const uut3 = u * ut3;\n        const utt3 = ut3 * p;\n        const x = x1 * uuu + cx1 * uut3 + cx2 * utt3 + x2 * ttt;\n        const y = y1 * uuu + cy1 * uut3 + cy2 * utt3 + y2 * ttt;\n\n        out[o] = x;\n        out[o + 1] = y;\n        if (tangents) {\n            if (p < 0.001) out[o + 2] = Math.atan2(cy1 - y1, cx1 - x1);\n            else out[o + 2] = Math.atan2(y - (y1 * uu + cy1 * ut * 2 + cy2 * tt), x - (x1 * uu + cx1 * ut * 2 + cx2 * tt));\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}