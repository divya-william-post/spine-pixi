{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Container, Graphics, Text } from 'pixi.js';\nimport { RegionAttachment, MeshAttachment, ClippingAttachment, SkeletonBounds, PathAttachment } from '@esotericsoftware/spine-core';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass SpineDebugRenderer {\n  constructor() {\n    __publicField(this, \"registeredSpines\", /* @__PURE__ */new Map());\n    __publicField(this, \"drawMeshHull\", true);\n    __publicField(this, \"drawMeshTriangles\", true);\n    __publicField(this, \"drawBones\", true);\n    __publicField(this, \"drawPaths\", true);\n    __publicField(this, \"drawBoundingBoxes\", true);\n    __publicField(this, \"drawClipping\", true);\n    __publicField(this, \"drawRegionAttachments\", true);\n    __publicField(this, \"drawEvents\", true);\n    __publicField(this, \"lineWidth\", 1);\n    __publicField(this, \"regionAttachmentsColor\", 30975);\n    __publicField(this, \"meshHullColor\", 30975);\n    __publicField(this, \"meshTrianglesColor\", 16763904);\n    __publicField(this, \"clippingPolygonColor\", 16711935);\n    __publicField(this, \"boundingBoxesRectColor\", 65280);\n    __publicField(this, \"boundingBoxesPolygonColor\", 65280);\n    __publicField(this, \"boundingBoxesCircleColor\", 65280);\n    __publicField(this, \"pathsCurveColor\", 16711680);\n    __publicField(this, \"pathsLineColor\", 16711935);\n    __publicField(this, \"skeletonXYColor\", 16711680);\n    __publicField(this, \"bonesColor\", 61132);\n    __publicField(this, \"eventFontSize\", 24);\n    __publicField(this, \"eventFontColor\", 0);\n  }\n  /**\n   * The debug is attached by force to each spine object.\n   * So we need to create it inside the spine when we get the first update\n   */\n  registerSpine(spine) {\n    if (this.registeredSpines.has(spine)) {\n      console.warn(\"SpineDebugRenderer.registerSpine() - this spine is already registered!\", spine);\n      return;\n    }\n    const debugDisplayObjects = {\n      parentDebugContainer: new Container(),\n      bones: new Container(),\n      skeletonXY: new Graphics(),\n      regionAttachmentsShape: new Graphics(),\n      meshTrianglesLine: new Graphics(),\n      meshHullLine: new Graphics(),\n      clippingPolygon: new Graphics(),\n      boundingBoxesRect: new Graphics(),\n      boundingBoxesCircle: new Graphics(),\n      boundingBoxesPolygon: new Graphics(),\n      pathsCurve: new Graphics(),\n      pathsLine: new Graphics(),\n      eventText: new Container(),\n      eventCallback: {\n        event: (_, event) => {\n          if (this.drawEvents) {\n            const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\n            const text = new Text({\n              text: event.data.name,\n              style: {\n                fontSize: this.eventFontSize / scale,\n                fill: this.eventFontColor,\n                fontFamily: \"monospace\"\n              }\n            });\n            text.scale.x = Math.sign(spine.scale.x);\n            text.anchor.set(0.5);\n            debugDisplayObjects.eventText.addChild(text);\n            setTimeout(() => {\n              if (!text.destroyed) {\n                text.destroy();\n              }\n            }, 250);\n          }\n        }\n      }\n    };\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.eventText);\n    debugDisplayObjects.parentDebugContainer.zIndex = 9999999;\n    debugDisplayObjects.parentDebugContainer.accessibleChildren = false;\n    debugDisplayObjects.parentDebugContainer.eventMode = \"none\";\n    debugDisplayObjects.parentDebugContainer.interactiveChildren = false;\n    spine.addChild(debugDisplayObjects.parentDebugContainer);\n    spine.state.addListener(debugDisplayObjects.eventCallback);\n    this.registeredSpines.set(spine, debugDisplayObjects);\n  }\n  renderDebug(spine) {\n    if (!this.registeredSpines.has(spine)) {\n      this.registerSpine(spine);\n    }\n    const debugDisplayObjects = this.registeredSpines.get(spine);\n    if (!debugDisplayObjects) {\n      return;\n    }\n    spine.addChild(debugDisplayObjects.parentDebugContainer);\n    debugDisplayObjects.skeletonXY.clear();\n    debugDisplayObjects.regionAttachmentsShape.clear();\n    debugDisplayObjects.meshTrianglesLine.clear();\n    debugDisplayObjects.meshHullLine.clear();\n    debugDisplayObjects.clippingPolygon.clear();\n    debugDisplayObjects.boundingBoxesRect.clear();\n    debugDisplayObjects.boundingBoxesCircle.clear();\n    debugDisplayObjects.boundingBoxesPolygon.clear();\n    debugDisplayObjects.pathsCurve.clear();\n    debugDisplayObjects.pathsLine.clear();\n    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\n      debugDisplayObjects.bones.children[len - 1].destroy({\n        children: true,\n        texture: true,\n        textureSource: true\n      });\n    }\n    const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\n    const lineWidth = this.lineWidth / scale;\n    if (this.drawBones) {\n      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n    }\n    if (this.drawPaths) {\n      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawBoundingBoxes) {\n      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawClipping) {\n      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawMeshHull || this.drawMeshTriangles) {\n      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawRegionAttachments) {\n      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawEvents) {\n      for (const child of debugDisplayObjects.eventText.children) {\n        child.alpha -= 0.05;\n        child.y -= 2;\n      }\n    }\n  }\n  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {\n    const skeleton = spine.skeleton;\n    const skeletonX = skeleton.x;\n    const skeletonY = skeleton.y;\n    const bones = skeleton.bones;\n    debugDisplayObjects.skeletonXY.strokeStyle = {\n      width: lineWidth,\n      color: this.skeletonXYColor\n    };\n    for (let i = 0, len = bones.length; i < len; i++) {\n      const bone = bones[i];\n      const boneLen = bone.data.length;\n      const starX = skeletonX + bone.worldX;\n      const starY = skeletonY + bone.worldY;\n      const endX = skeletonX + boneLen * bone.a + bone.worldX;\n      const endY = skeletonY + boneLen * bone.b + bone.worldY;\n      if (bone.data.name === \"root\" || bone.data.parent === null) {\n        continue;\n      }\n      const w = Math.abs(starX - endX);\n      const h = Math.abs(starY - endY);\n      const a2 = Math.pow(w, 2);\n      const b = h;\n      const b2 = Math.pow(h, 2);\n      const c = Math.sqrt(a2 + b2);\n      const c2 = Math.pow(c, 2);\n      const rad = Math.PI / 180;\n      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;\n      if (c === 0) {\n        continue;\n      }\n      const gp = new Graphics();\n      debugDisplayObjects.bones.addChild(gp);\n      const refRation = c / 50 / scale;\n      gp.context.poly([0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3]).fill(this.bonesColor);\n      gp.x = starX;\n      gp.y = starY;\n      gp.pivot.y = c;\n      let rotation = 0;\n      if (starX < endX && starY < endY) {\n        rotation = -B + 180 * rad;\n      } else if (starX > endX && starY < endY) {\n        rotation = 180 * (rad + B);\n      } else if (starX > endX && starY > endY) {\n        rotation = -B;\n      } else if (starX < endX && starY > endY) {\n        rotation = B;\n      } else if (starY === endY && starX < endX) {\n        rotation = 90 * rad;\n      } else if (starY === endY && starX > endX) {\n        rotation = -90 * rad;\n      } else if (starX === endX && starY < endY) {\n        rotation = 180 * rad;\n      } else if (starX === endX && starY > endY) {\n        rotation = 0;\n      }\n      gp.rotation = rotation;\n      gp.circle(0, c, refRation * 1.2).fill({\n        color: 0,\n        alpha: 0.6\n      }).stroke({\n        width: lineWidth,\n        color: this.skeletonXYColor\n      });\n    }\n    const startDotSize = lineWidth * 3;\n    debugDisplayObjects.skeletonXY.context.moveTo(skeletonX - startDotSize, skeletonY - startDotSize).lineTo(skeletonX + startDotSize, skeletonY + startDotSize).moveTo(skeletonX + startDotSize, skeletonY - startDotSize).lineTo(skeletonX - startDotSize, skeletonY + startDotSize).stroke();\n  }\n  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      const attachment = slot.getAttachment();\n      if (attachment === null || !(attachment instanceof RegionAttachment)) {\n        continue;\n      }\n      const regionAttachment = attachment;\n      const vertices = new Float32Array(8);\n      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n      debugDisplayObjects.regionAttachmentsShape.poly(Array.from(vertices.slice(0, 8)));\n    }\n    debugDisplayObjects.regionAttachmentsShape.stroke({\n      color: this.regionAttachmentsColor,\n      width: lineWidth\n    });\n  }\n  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment === null || !(attachment instanceof MeshAttachment)) {\n        continue;\n      }\n      const meshAttachment = attachment;\n      const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n      const triangles = meshAttachment.triangles;\n      let hullLength = meshAttachment.hullLength;\n      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n      if (this.drawMeshTriangles) {\n        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {\n          const v1 = triangles[i2] * 2;\n          const v2 = triangles[i2 + 1] * 2;\n          const v3 = triangles[i2 + 2] * 2;\n          debugDisplayObjects.meshTrianglesLine.context.moveTo(vertices[v1], vertices[v1 + 1]).lineTo(vertices[v2], vertices[v2 + 1]).lineTo(vertices[v3], vertices[v3 + 1]);\n        }\n      }\n      if (this.drawMeshHull && hullLength > 0) {\n        hullLength = (hullLength >> 1) * 2;\n        let lastX = vertices[hullLength - 2];\n        let lastY = vertices[hullLength - 1];\n        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {\n          const x = vertices[i2];\n          const y = vertices[i2 + 1];\n          debugDisplayObjects.meshHullLine.context.moveTo(x, y).lineTo(lastX, lastY);\n          lastX = x;\n          lastY = y;\n        }\n      }\n    }\n    debugDisplayObjects.meshHullLine.stroke({\n      width: lineWidth,\n      color: this.meshHullColor\n    });\n    debugDisplayObjects.meshTrianglesLine.stroke({\n      width: lineWidth,\n      color: this.meshTrianglesColor\n    });\n  }\n  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment === null || !(attachment instanceof ClippingAttachment)) {\n        continue;\n      }\n      const clippingAttachment = attachment;\n      const nn = clippingAttachment.worldVerticesLength;\n      const world = new Float32Array(nn);\n      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n      debugDisplayObjects.clippingPolygon.poly(Array.from(world));\n    }\n    debugDisplayObjects.clippingPolygon.stroke({\n      width: lineWidth,\n      color: this.clippingPolygonColor,\n      alpha: 1\n    });\n  }\n  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {\n    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n    const bounds = new SkeletonBounds();\n    bounds.update(spine.skeleton, true);\n    debugDisplayObjects.boundingBoxesRect.rect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight()).stroke({\n      width: lineWidth,\n      color: this.boundingBoxesRectColor\n    });\n    const polygons = bounds.polygons;\n    const drawPolygon = (polygonVertices, _offset, count) => {\n      if (count < 3) {\n        throw new Error(\"Polygon must contain at least 3 vertices\");\n      }\n      const paths = [];\n      const dotSize = lineWidth * 2;\n      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\n        const x1 = polygonVertices[i];\n        const y1 = polygonVertices[i + 1];\n        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n        debugDisplayObjects.boundingBoxesCircle.fill(0);\n        paths.push(x1, y1);\n      }\n      debugDisplayObjects.boundingBoxesPolygon.poly(paths).fill({\n        color: this.boundingBoxesPolygonColor,\n        alpha: 0.1\n      }).stroke({\n        width: lineWidth,\n        color: this.boundingBoxesPolygonColor\n      });\n    };\n    for (let i = 0, len = polygons.length; i < len; i++) {\n      const polygon = polygons[i];\n      drawPolygon(polygon, 0, polygon.length);\n    }\n  }\n  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment === null || !(attachment instanceof PathAttachment)) {\n        continue;\n      }\n      const pathAttachment = attachment;\n      let nn = pathAttachment.worldVerticesLength;\n      const world = new Float32Array(nn);\n      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n      let x1 = world[2];\n      let y1 = world[3];\n      let x2 = 0;\n      let y2 = 0;\n      if (pathAttachment.closed) {\n        const cx1 = world[0];\n        const cy1 = world[1];\n        const cx2 = world[nn - 2];\n        const cy2 = world[nn - 1];\n        x2 = world[nn - 4];\n        y2 = world[nn - 3];\n        debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        debugDisplayObjects.pathsLine.moveTo(x1, y1);\n        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n        debugDisplayObjects.pathsLine.moveTo(x2, y2);\n        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n      }\n      nn -= 4;\n      for (let ii = 4; ii < nn; ii += 6) {\n        const cx1 = world[ii];\n        const cy1 = world[ii + 1];\n        const cx2 = world[ii + 2];\n        const cy2 = world[ii + 3];\n        x2 = world[ii + 4];\n        y2 = world[ii + 5];\n        debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        debugDisplayObjects.pathsLine.moveTo(x1, y1);\n        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n        debugDisplayObjects.pathsLine.moveTo(x2, y2);\n        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n        x1 = x2;\n        y1 = y2;\n      }\n    }\n    debugDisplayObjects.pathsCurve.stroke({\n      width: lineWidth,\n      color: this.pathsCurveColor\n    });\n    debugDisplayObjects.pathsLine.stroke({\n      width: lineWidth,\n      color: this.pathsLineColor\n    });\n  }\n  unregisterSpine(spine) {\n    if (!this.registeredSpines.has(spine)) {\n      console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\n    }\n    const debugDisplayObjects = this.registeredSpines.get(spine);\n    if (!debugDisplayObjects) {\n      return;\n    }\n    spine.state.removeListener(debugDisplayObjects.eventCallback);\n    debugDisplayObjects.parentDebugContainer.destroy({\n      textureSource: true,\n      children: true,\n      texture: true\n    });\n    this.registeredSpines.delete(spine);\n  }\n}\nexport { SpineDebugRenderer };","map":{"version":3,"names":["SpineDebugRenderer","constructor","__publicField","Map","registerSpine","spine","registeredSpines","has","console","warn","debugDisplayObjects","parentDebugContainer","Container","bones","skeletonXY","Graphics","regionAttachmentsShape","meshTrianglesLine","meshHullLine","clippingPolygon","boundingBoxesRect","boundingBoxesCircle","boundingBoxesPolygon","pathsCurve","pathsLine","eventText","eventCallback","event","_","drawEvents","scale","Math","abs","x","y","text","Text","data","name","style","fontSize","eventFontSize","fill","eventFontColor","fontFamily","sign","anchor","set","addChild","setTimeout","destroyed","destroy","zIndex","accessibleChildren","eventMode","interactiveChildren","state","addListener","renderDebug","get","clear","len","children","length","texture","textureSource","lineWidth","drawBones","drawBonesFunc","drawPaths","drawPathsFunc","drawBoundingBoxes","drawBoundingBoxesFunc","drawClipping","drawClippingFunc","drawMeshHull","drawMeshTriangles","drawMeshHullAndMeshTriangles","drawRegionAttachments","drawRegionAttachmentsFunc","child","alpha","skeleton","skeletonX","skeletonY","strokeStyle","width","color","skeletonXYColor","i","bone","boneLen","starX","worldX","starY","worldY","endX","a","endY","b","parent","w","h","a2","pow","b2","c","sqrt","c2","rad","PI","B","acos","gp","refRation","context","poly","bonesColor","pivot","rotation","circle","stroke","startDotSize","moveTo","lineTo","slots","slot","attachment","getAttachment","RegionAttachment","regionAttachment","vertices","Float32Array","computeWorldVertices","Array","from","slice","regionAttachmentsColor","active","MeshAttachment","meshAttachment","worldVerticesLength","triangles","hullLength","i2","len2","v1","v2","v3","lastX","lastY","meshHullColor","meshTrianglesColor","ClippingAttachment","clippingAttachment","nn","world","clippingPolygonColor","lineStyle","boundingBoxesRectColor","bounds","SkeletonBounds","update","rect","minX","minY","getWidth","getHeight","polygons","drawPolygon","polygonVertices","_offset","count","Error","paths","dotSize","x1","y1","beginFill","boundingBoxesCircleColor","drawCircle","push","boundingBoxesPolygonColor","polygon","PathAttachment","pathAttachment","x2","y2","closed","cx1","cy1","cx2","cy2","bezierCurveTo","ii","pathsCurveColor","pathsLineColor","unregisterSpine","removeListener","delete"],"sources":["../src/SpineDebugRenderer.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Container, Graphics, Text } from 'pixi.js';\nimport { Spine } from './Spine';\nimport {\n    ClippingAttachment,\n    MeshAttachment,\n    PathAttachment,\n    RegionAttachment,\n    SkeletonBounds\n} from '@esotericsoftware/spine-core';\n\nimport type { AnimationStateListener } from '@esotericsoftware/spine-core';\n\n/**\n * Make a class that extends from this interface to create your own debug renderer.\n * @public\n */\nexport interface ISpineDebugRenderer\n{\n    /**\n     * This will be called every frame, after the spine has been updated.\n     */\n    renderDebug: (spine: Spine) => void;\n\n    /**\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\n     */\n    unregisterSpine: (spine: Spine) => void;\n\n    /**\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\n     */\n    registerSpine: (spine: Spine) => void;\n}\n\ntype DebugDisplayObjects = {\n    bones: Container;\n    skeletonXY: Graphics;\n    regionAttachmentsShape: Graphics;\n    meshTrianglesLine: Graphics;\n    meshHullLine: Graphics;\n    clippingPolygon: Graphics;\n    boundingBoxesRect: Graphics;\n    boundingBoxesCircle: Graphics;\n    boundingBoxesPolygon: Graphics;\n    pathsCurve: Graphics;\n    pathsLine: Graphics;\n    parentDebugContainer: Container;\n    eventText: Container;\n    eventCallback: AnimationStateListener;\n};\n\n/**\n * This is a debug renderer that uses PixiJS Graphics under the hood.\n * @public\n */\nexport class SpineDebugRenderer implements ISpineDebugRenderer\n{\n    private readonly registeredSpines: Map<Spine, DebugDisplayObjects> = new Map();\n\n    public drawMeshHull = true;\n    public drawMeshTriangles = true;\n    public drawBones = true;\n    public drawPaths = true;\n    public drawBoundingBoxes = true;\n    public drawClipping = true;\n    public drawRegionAttachments = true;\n    public drawEvents = true;\n\n    public lineWidth = 1;\n    public regionAttachmentsColor = 0x0078ff;\n    public meshHullColor = 0x0078ff;\n    public meshTrianglesColor = 0xffcc00;\n    public clippingPolygonColor = 0xff00ff;\n    public boundingBoxesRectColor = 0x00ff00;\n    public boundingBoxesPolygonColor = 0x00ff00;\n    public boundingBoxesCircleColor = 0x00ff00;\n    public pathsCurveColor = 0xff0000;\n    public pathsLineColor = 0xff00ff;\n    public skeletonXYColor = 0xff0000;\n    public bonesColor = 0x00eecc;\n    public eventFontSize = 24;\n    public eventFontColor = 0x0;\n\n    /**\n     * The debug is attached by force to each spine object.\n     * So we need to create it inside the spine when we get the first update\n     */\n    public registerSpine(spine: Spine): void\n    {\n        if (this.registeredSpines.has(spine))\n        {\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\n\n            return;\n        }\n        const debugDisplayObjects: DebugDisplayObjects = {\n            parentDebugContainer: new Container(),\n            bones: new Container(),\n            skeletonXY: new Graphics(),\n            regionAttachmentsShape: new Graphics(),\n            meshTrianglesLine: new Graphics(),\n            meshHullLine: new Graphics(),\n            clippingPolygon: new Graphics(),\n            boundingBoxesRect: new Graphics(),\n            boundingBoxesCircle: new Graphics(),\n            boundingBoxesPolygon: new Graphics(),\n            pathsCurve: new Graphics(),\n            pathsLine: new Graphics(),\n            eventText: new Container(),\n            eventCallback: {\n                event: (_, event) =>\n                {\n                    if (this.drawEvents)\n                    {\n                        const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\n                        const text = new Text({\n                            text: event.data.name,\n                            style: {\n                                fontSize: this.eventFontSize / scale,\n                                fill: this.eventFontColor,\n                                fontFamily: 'monospace'\n                            }\n                        });\n\n                        text.scale.x = Math.sign(spine.scale.x);\n                        text.anchor.set(0.5);\n                        debugDisplayObjects.eventText.addChild(text);\n                        setTimeout(() =>\n                        {\n                            if (!text.destroyed)\n                            {\n                                text.destroy();\n                            }\n                        }, 250);\n                    }\n                },\n            },\n        };\n\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.eventText);\n\n        debugDisplayObjects.parentDebugContainer.zIndex = 9999999;\n\n        // Disable screen reader and mouse input on debug objects.\n        (debugDisplayObjects.parentDebugContainer as any).accessibleChildren = false;\n        (debugDisplayObjects.parentDebugContainer as any).eventMode = 'none';\n        (debugDisplayObjects.parentDebugContainer as any).interactiveChildren = false;\n\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        spine.state.addListener(debugDisplayObjects.eventCallback);\n\n        this.registeredSpines.set(spine, debugDisplayObjects);\n    }\n\n    public renderDebug(spine: Spine): void\n    {\n        if (!this.registeredSpines.has(spine))\n        {\n            // This should never happen. Spines are registered when you assign spine.debug\n            this.registerSpine(spine);\n        }\n\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        if (!debugDisplayObjects)\n        {\n            return;\n        }\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        debugDisplayObjects.skeletonXY.clear();\n        debugDisplayObjects.regionAttachmentsShape.clear();\n        debugDisplayObjects.meshTrianglesLine.clear();\n        debugDisplayObjects.meshHullLine.clear();\n        debugDisplayObjects.clippingPolygon.clear();\n        debugDisplayObjects.boundingBoxesRect.clear();\n        debugDisplayObjects.boundingBoxesCircle.clear();\n        debugDisplayObjects.boundingBoxesPolygon.clear();\n        debugDisplayObjects.pathsCurve.clear();\n        debugDisplayObjects.pathsLine.clear();\n\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--)\n        {\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, textureSource: true });\n        }\n\n        const scale = Math.abs(spine.scale.x || spine.scale.y || 1);\n        const lineWidth = this.lineWidth / scale;\n\n        if (this.drawBones)\n        {\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n        }\n\n        if (this.drawPaths)\n        {\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawBoundingBoxes)\n        {\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawClipping)\n        {\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawMeshHull || this.drawMeshTriangles)\n        {\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawRegionAttachments)\n        {\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawEvents)\n        {\n            for (const child of debugDisplayObjects.eventText.children)\n            {\n                child.alpha -= 0.05;\n                child.y -= 2;\n            }\n        }\n    }\n\n    private drawBonesFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number, scale: number): void\n    {\n        const skeleton = spine.skeleton;\n        const skeletonX = skeleton.x;\n        const skeletonY = skeleton.y;\n        const bones = skeleton.bones;\n\n        debugDisplayObjects.skeletonXY.strokeStyle = { width: lineWidth, color: this.skeletonXYColor };\n\n        for (let i = 0, len = bones.length; i < len; i++)\n        {\n            const bone = bones[i];\n            const boneLen = bone.data.length;\n            const starX = skeletonX + bone.worldX;\n            const starY = skeletonY + bone.worldY;\n            const endX = skeletonX + (boneLen * bone.a) + bone.worldX;\n            const endY = skeletonY + (boneLen * bone.b) + bone.worldY;\n\n            if (bone.data.name === 'root' || bone.data.parent === null)\n            {\n                continue;\n            }\n\n            const w = Math.abs(starX - endX);\n            const h = Math.abs(starY - endY);\n            // a = w, // side length a\n            const a2 = Math.pow(w, 2); // square root of side length a\n            const b = h; // side length b\n            const b2 = Math.pow(h, 2); // square root of side length b\n            const c = Math.sqrt(a2 + b2); // side length c\n            const c2 = Math.pow(c, 2); // square root of side length c\n            const rad = Math.PI / 180;\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\n\n            if (c === 0)\n            {\n                continue;\n            }\n\n            const gp = new Graphics();\n\n            debugDisplayObjects.bones.addChild(gp);\n\n            // draw bone\n            const refRation = c / 50 / scale;\n\n            gp.context\n                .poly([0, 0, 0 - refRation, c - (refRation * 3), 0, c - refRation, 0 + refRation, c - (refRation * 3)])\n                .fill(this.bonesColor);\n            gp.x = starX;\n            gp.y = starY;\n            gp.pivot.y = c;\n\n            // Calculate bone rotation angle\n            let rotation = 0;\n\n            if (starX < endX && starY < endY)\n            {\n                // bottom right\n                rotation = -B + (180 * rad);\n            }\n            else if (starX > endX && starY < endY)\n            {\n                // bottom left\n                rotation = 180 * (rad + B);\n            }\n            else if (starX > endX && starY > endY)\n            {\n                // top left\n                rotation = -B;\n            }\n            else if (starX < endX && starY > endY)\n            {\n                // bottom left\n                rotation = B;\n            }\n            else if (starY === endY && starX < endX)\n            {\n                // To the right\n                rotation = 90 * rad;\n            }\n            else if (starY === endY && starX > endX)\n            {\n                // go left\n                rotation = -90 * rad;\n            }\n            else if (starX === endX && starY < endY)\n            {\n                // down\n                rotation = 180 * rad;\n            }\n            else if (starX === endX && starY > endY)\n            {\n                // up\n                rotation = 0;\n            }\n            gp.rotation = rotation;\n\n            // Draw the starting rotation point of the bone\n            gp.circle(0, c, refRation * 1.2)\n                .fill({ color: 0x000000, alpha: 0.6 })\n                .stroke({ width: lineWidth, color: this.skeletonXYColor });\n        }\n\n        // Draw the skeleton starting point \"X\" form\n        const startDotSize = lineWidth * 3;\n\n        debugDisplayObjects.skeletonXY.context\n            .moveTo(skeletonX - startDotSize, skeletonY - startDotSize)\n            .lineTo(skeletonX + startDotSize, skeletonY + startDotSize)\n            .moveTo(skeletonX + startDotSize, skeletonY - startDotSize)\n            .lineTo(skeletonX - startDotSize, skeletonY + startDotSize)\n            .stroke();\n    }\n\n    private drawRegionAttachmentsFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof RegionAttachment))\n            {\n                continue;\n            }\n\n            const regionAttachment = attachment;\n\n            const vertices = new Float32Array(8);\n\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n\n            debugDisplayObjects.regionAttachmentsShape.poly(Array.from(vertices.slice(0, 8)));\n        }\n\n        debugDisplayObjects.regionAttachmentsShape.stroke({\n            color: this.regionAttachmentsColor,\n            width: lineWidth\n        });\n    }\n\n    private drawMeshHullAndMeshTriangles(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n\n            if (!slot.bone.active)\n            {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof MeshAttachment))\n            {\n                continue;\n            }\n\n            const meshAttachment = attachment;\n\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n            const triangles = meshAttachment.triangles;\n            let hullLength = meshAttachment.hullLength;\n\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n            // draw the skinned mesh (triangle)\n            if (this.drawMeshTriangles)\n            {\n                for (let i = 0, len = triangles.length; i < len; i += 3)\n                {\n                    const v1 = triangles[i] * 2;\n                    const v2 = triangles[i + 1] * 2;\n                    const v3 = triangles[i + 2] * 2;\n\n                    debugDisplayObjects.meshTrianglesLine.context\n                        .moveTo(vertices[v1], vertices[v1 + 1])\n                        .lineTo(vertices[v2], vertices[v2 + 1])\n                        .lineTo(vertices[v3], vertices[v3 + 1]);\n                }\n            }\n\n            // draw skin border\n            if (this.drawMeshHull && hullLength > 0)\n            {\n                hullLength = (hullLength >> 1) * 2;\n                let lastX = vertices[hullLength - 2];\n                let lastY = vertices[hullLength - 1];\n\n                for (let i = 0, len = hullLength; i < len; i += 2)\n                {\n                    const x = vertices[i];\n                    const y = vertices[i + 1];\n\n                    debugDisplayObjects.meshHullLine.context\n                        .moveTo(x, y)\n                        .lineTo(lastX, lastY);\n                    lastX = x;\n                    lastY = y;\n                }\n            }\n        }\n\n        debugDisplayObjects.meshHullLine.stroke({ width: lineWidth, color: this.meshHullColor });\n        debugDisplayObjects.meshTrianglesLine.stroke({ width: lineWidth, color: this.meshTrianglesColor });\n    }\n\n    drawClippingFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n\n            if (!slot.bone.active)\n            {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof ClippingAttachment))\n            {\n                continue;\n            }\n\n            const clippingAttachment = attachment;\n\n            const nn = clippingAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            debugDisplayObjects.clippingPolygon.poly(Array.from(world));\n        }\n\n        debugDisplayObjects.clippingPolygon.stroke({\n            width: lineWidth, color: this.clippingPolygonColor, alpha: 1\n        });\n    }\n\n    drawBoundingBoxesFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        // draw the total outline of the bounding box\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n\n        const bounds = new SkeletonBounds();\n\n        bounds.update(spine.skeleton, true);\n\n        debugDisplayObjects.boundingBoxesRect\n            .rect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight())\n            .stroke({ width: lineWidth, color: this.boundingBoxesRectColor });\n\n        const polygons = bounds.polygons;\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void =>\n        {\n            if (count < 3)\n            {\n                throw new Error('Polygon must contain at least 3 vertices');\n            }\n            const paths:number[] = [];\n            const dotSize = lineWidth * 2;\n\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2)\n            {\n                const x1 = polygonVertices[i];\n                const y1 = polygonVertices[i + 1];\n\n                // draw the bounding box node\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n                debugDisplayObjects.boundingBoxesCircle.fill(0);\n\n                paths.push(x1, y1);\n            }\n\n            // draw the bounding box area\n            debugDisplayObjects.boundingBoxesPolygon\n                .poly(paths)\n                .fill({\n                    color: this.boundingBoxesPolygonColor,\n                    alpha: 0.1\n                })\n                .stroke({\n                    width: lineWidth,\n                    color: this.boundingBoxesPolygonColor\n                });\n        };\n\n        for (let i = 0, len = polygons.length; i < len; i++)\n        {\n            const polygon = polygons[i];\n\n            drawPolygon(polygon, 0, polygon.length);\n        }\n    }\n\n    private drawPathsFunc(spine: Spine, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void\n    {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        for (let i = 0, len = slots.length; i < len; i++)\n        {\n            const slot = slots[i];\n\n            if (!slot.bone.active)\n            {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment === null || !(attachment instanceof PathAttachment))\n            {\n                continue;\n            }\n\n            const pathAttachment = attachment;\n            let nn = pathAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            let x1 = world[2];\n            let y1 = world[3];\n            let x2 = 0;\n            let y2 = 0;\n\n            if (pathAttachment.closed)\n            {\n                const cx1 = world[0];\n                const cy1 = world[1];\n                const cx2 = world[nn - 2];\n                const cy2 = world[nn - 1];\n\n                x2 = world[nn - 4];\n                y2 = world[nn - 3];\n\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n            }\n            nn -= 4;\n            for (let ii = 4; ii < nn; ii += 6)\n            {\n                const cx1 = world[ii];\n                const cy1 = world[ii + 1];\n                const cx2 = world[ii + 2];\n                const cy2 = world[ii + 3];\n\n                x2 = world[ii + 4];\n                y2 = world[ii + 5];\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n                x1 = x2;\n                y1 = y2;\n            }\n        }\n\n        debugDisplayObjects.pathsCurve.stroke({ width: lineWidth, color: this.pathsCurveColor });\n        debugDisplayObjects.pathsLine.stroke({ width: lineWidth, color: this.pathsLineColor });\n    }\n\n    public unregisterSpine(spine: Spine): void\n    {\n        if (!this.registeredSpines.has(spine))\n        {\n            console.warn('SpineDebugRenderer.unregisterSpine() - spine is not registered, can\\'t unregister!', spine);\n        }\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        if (!debugDisplayObjects)\n        {\n            return;\n        }\n\n        spine.state.removeListener(debugDisplayObjects.eventCallback);\n\n        debugDisplayObjects.parentDebugContainer.destroy({ textureSource: true, children: true, texture: true });\n        this.registeredSpines.delete(spine);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}