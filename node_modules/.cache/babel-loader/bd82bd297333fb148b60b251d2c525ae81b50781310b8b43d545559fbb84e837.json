{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { AttachmentTimeline, RGBATimeline, RGBTimeline, AlphaTimeline, RGBA2Timeline, RGB2Timeline, RotateTimeline, TranslateTimeline, TranslateXTimeline, TranslateYTimeline, ScaleTimeline, ScaleXTimeline, ScaleYTimeline, ShearTimeline, ShearXTimeline, ShearYTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintPositionTimeline, PathConstraintSpacingTimeline, PathConstraintMixTimeline, DeformTimeline, SequenceTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { Utils, TransformMode, Color, PositionMode, RotateMode, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport { Sequence, SequenceMode } from './attachments/Sequence.mjs';\nclass SkeletonJson {\n  constructor(attachmentLoader) {\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(json) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    const root = typeof json === \"string\" ? JSON.parse(json) : json;\n    const skeletonMap = root.skeleton;\n    if (skeletonMap) {\n      skeletonData.hash = skeletonMap.hash;\n      skeletonData.version = skeletonMap.spine;\n      const verShort = skeletonData.version.substr(0, 3);\n      if (verShort !== \"4.0\" && verShort !== \"4.1\") {\n        const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n        console.error(error);\n      }\n      skeletonData.x = skeletonMap.x;\n      skeletonData.y = skeletonMap.y;\n      skeletonData.width = skeletonMap.width;\n      skeletonData.height = skeletonMap.height;\n      skeletonData.fps = skeletonMap.fps;\n      skeletonData.imagesPath = skeletonMap.images;\n    }\n    if (root.bones) {\n      for (let i = 0; i < root.bones.length; i++) {\n        const boneMap = root.bones[i];\n        let parent = null;\n        const parentName = getValue(boneMap, \"parent\", null);\n        if (parentName != null) {\n          parent = skeletonData.findBone(parentName);\n          if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n        }\n        const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n        data.length = getValue(boneMap, \"length\", 0) * scale;\n        data.x = getValue(boneMap, \"x\", 0) * scale;\n        data.y = getValue(boneMap, \"y\", 0) * scale;\n        data.rotation = getValue(boneMap, \"rotation\", 0);\n        data.scaleX = getValue(boneMap, \"scaleX\", 1);\n        data.scaleY = getValue(boneMap, \"scaleY\", 1);\n        data.shearX = getValue(boneMap, \"shearX\", 0);\n        data.shearY = getValue(boneMap, \"shearY\", 0);\n        data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, \"transform\", \"Normal\"));\n        data.skinRequired = getValue(boneMap, \"skin\", false);\n        const color = getValue(boneMap, \"color\", null);\n        if (color) data.color.setFromString(color);\n        skeletonData.bones.push(data);\n      }\n    }\n    if (root.slots) {\n      for (let i = 0; i < root.slots.length; i++) {\n        const slotMap = root.slots[i];\n        const boneData = skeletonData.findBone(slotMap.bone);\n        if (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\n        const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n        const color = getValue(slotMap, \"color\", null);\n        if (color) data.color.setFromString(color);\n        const dark = getValue(slotMap, \"dark\", null);\n        if (dark) data.darkColor = Color.fromString(dark);\n        data.attachmentName = getValue(slotMap, \"attachment\", null);\n        data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, \"blend\", \"normal\"));\n        skeletonData.slots.push(data);\n      }\n    }\n    if (root.ik) {\n      for (let i = 0; i < root.ik.length; i++) {\n        const constraintMap = root.ik[i];\n        const data = new IkConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n          data.bones.push(bone);\n        }\n        data.target = skeletonData.findBone(constraintMap.target);\n        data.mix = getValue(constraintMap, \"mix\", 1);\n        data.softness = getValue(constraintMap, \"softness\", 0) * scale;\n        data.bendDirection = getValue(constraintMap, \"bendPositive\", true) ? 1 : -1;\n        data.compress = getValue(constraintMap, \"compress\", false);\n        data.stretch = getValue(constraintMap, \"stretch\", false);\n        data.uniform = getValue(constraintMap, \"uniform\", false);\n        skeletonData.ikConstraints.push(data);\n      }\n    }\n    if (root.transform) {\n      for (let i = 0; i < root.transform.length; i++) {\n        const constraintMap = root.transform[i];\n        const data = new TransformConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        const target = skeletonData.findBone(targetName);\n        if (!target) throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\n        data.target = target;\n        data.local = getValue(constraintMap, \"local\", false);\n        data.relative = getValue(constraintMap, \"relative\", false);\n        data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n        data.offsetX = getValue(constraintMap, \"x\", 0) * scale;\n        data.offsetY = getValue(constraintMap, \"y\", 0) * scale;\n        data.offsetScaleX = getValue(constraintMap, \"scaleX\", 0);\n        data.offsetScaleY = getValue(constraintMap, \"scaleY\", 0);\n        data.offsetShearY = getValue(constraintMap, \"shearY\", 0);\n        data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n        data.mixX = getValue(constraintMap, \"mixX\", 1);\n        data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n        data.mixScaleX = getValue(constraintMap, \"mixScaleX\", 1);\n        data.mixScaleY = getValue(constraintMap, \"mixScaleY\", data.mixScaleX);\n        data.mixShearY = getValue(constraintMap, \"mixShearY\", 1);\n        skeletonData.transformConstraints.push(data);\n      }\n    }\n    if (root.path) {\n      for (let i = 0; i < root.path.length; i++) {\n        const constraintMap = root.path[i];\n        const data = new PathConstraintData(constraintMap.name);\n        data.order = getValue(constraintMap, \"order\", 0);\n        data.skinRequired = getValue(constraintMap, \"skin\", false);\n        for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n          const boneName = constraintMap.bones[ii];\n          const bone = skeletonData.findBone(boneName);\n          if (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\n          data.bones.push(bone);\n        }\n        const targetName = constraintMap.target;\n        const target = skeletonData.findSlot(targetName);\n        if (!target) throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\n        data.target = target;\n        data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, \"positionMode\", \"Percent\"));\n        data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, \"spacingMode\", \"Length\"));\n        data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, \"rotateMode\", \"Tangent\"));\n        data.offsetRotation = getValue(constraintMap, \"rotation\", 0);\n        data.position = getValue(constraintMap, \"position\", 0);\n        if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n        data.spacing = getValue(constraintMap, \"spacing\", 0);\n        if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n        data.mixRotate = getValue(constraintMap, \"mixRotate\", 1);\n        data.mixX = getValue(constraintMap, \"mixX\", 1);\n        data.mixY = getValue(constraintMap, \"mixY\", data.mixX);\n        skeletonData.pathConstraints.push(data);\n      }\n    }\n    if (root.skins) {\n      for (let i = 0; i < root.skins.length; i++) {\n        const skinMap = root.skins[i];\n        const skin = new Skin(skinMap.name);\n        if (skinMap.bones) {\n          for (let ii = 0; ii < skinMap.bones.length; ii++) {\n            const boneName = skinMap.bones[ii];\n            const bone = skeletonData.findBone(boneName);\n            if (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\n            skin.bones.push(bone);\n          }\n        }\n        if (skinMap.ik) {\n          for (let ii = 0; ii < skinMap.ik.length; ii++) {\n            const constraintName = skinMap.ik[ii];\n            const constraint = skeletonData.findIkConstraint(constraintName);\n            if (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.transform) {\n          for (let ii = 0; ii < skinMap.transform.length; ii++) {\n            const constraintName = skinMap.transform[ii];\n            const constraint = skeletonData.findTransformConstraint(constraintName);\n            if (!constraint) throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        if (skinMap.path) {\n          for (let ii = 0; ii < skinMap.path.length; ii++) {\n            const constraintName = skinMap.path[ii];\n            const constraint = skeletonData.findPathConstraint(constraintName);\n            if (!constraint) throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\n            skin.constraints.push(constraint);\n          }\n        }\n        for (const slotName in skinMap.attachments) {\n          const slot = skeletonData.findSlot(slotName);\n          if (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\n          const slotMap = skinMap.attachments[slotName];\n          for (const entryName in slotMap) {\n            const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n            if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n          }\n        }\n        skeletonData.skins.push(skin);\n        if (skin.name == \"default\") skeletonData.defaultSkin = skin;\n      }\n    }\n    for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    if (root.events) {\n      for (const eventName in root.events) {\n        const eventMap = root.events[eventName];\n        const data = new EventData(eventName);\n        data.intValue = getValue(eventMap, \"int\", 0);\n        data.floatValue = getValue(eventMap, \"float\", 0);\n        data.stringValue = getValue(eventMap, \"string\", \"\");\n        data.audioPath = getValue(eventMap, \"audio\", null);\n        if (data.audioPath) {\n          data.volume = getValue(eventMap, \"volume\", 1);\n          data.balance = getValue(eventMap, \"balance\", 0);\n        }\n        skeletonData.events.push(data);\n      }\n    }\n    if (root.animations) {\n      for (const animationName in root.animations) {\n        const animationMap = root.animations[animationName];\n        this.readAnimation(animationMap, animationName, skeletonData);\n      }\n    }\n    return skeletonData;\n  }\n  readAttachment(map, skin, slotIndex, name, skeletonData) {\n    const scale = this.scale;\n    name = getValue(map, \"name\", name);\n    switch (getValue(map, \"type\", \"region\")) {\n      case \"region\":\n        {\n          const path = getValue(map, \"path\", name);\n          const sequence = this.readSequence(getValue(map, \"sequence\", null));\n          const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n          if (!region) return null;\n          region.path = path;\n          region.x = getValue(map, \"x\", 0) * scale;\n          region.y = getValue(map, \"y\", 0) * scale;\n          region.scaleX = getValue(map, \"scaleX\", 1);\n          region.scaleY = getValue(map, \"scaleY\", 1);\n          region.rotation = getValue(map, \"rotation\", 0);\n          region.width = map.width * scale;\n          region.height = map.height * scale;\n          region.sequence = sequence;\n          const color = getValue(map, \"color\", null);\n          if (color) region.color.setFromString(color);\n          return region;\n        }\n      case \"boundingbox\":\n        {\n          const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n          if (!box) return null;\n          this.readVertices(map, box, map.vertexCount << 1);\n          const color = getValue(map, \"color\", null);\n          if (color) box.color.setFromString(color);\n          return box;\n        }\n      case \"mesh\":\n      case \"linkedmesh\":\n        {\n          const path = getValue(map, \"path\", name);\n          const sequence = this.readSequence(getValue(map, \"sequence\", null));\n          const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n          if (!mesh) return null;\n          mesh.path = path;\n          const color = getValue(map, \"color\", null);\n          if (color) mesh.color.setFromString(color);\n          mesh.width = getValue(map, \"width\", 0) * scale;\n          mesh.height = getValue(map, \"height\", 0) * scale;\n          mesh.sequence = sequence;\n          const parent = getValue(map, \"parent\", null);\n          if (parent) {\n            this.linkedMeshes.push(new LinkedMesh(mesh, getValue(map, \"skin\", null), slotIndex, parent, getValue(map, \"timelines\", true)));\n            return mesh;\n          }\n          const uvs = map.uvs;\n          this.readVertices(map, mesh, uvs.length);\n          mesh.triangles = map.triangles;\n          mesh.regionUVs = new Float32Array(uvs);\n          mesh.edges = getValue(map, \"edges\", null);\n          mesh.hullLength = getValue(map, \"hull\", 0) * 2;\n          return mesh;\n        }\n      case \"path\":\n        {\n          const path = this.attachmentLoader.newPathAttachment(skin, name);\n          if (!path) return null;\n          path.closed = getValue(map, \"closed\", false);\n          path.constantSpeed = getValue(map, \"constantSpeed\", true);\n          const vertexCount = map.vertexCount;\n          this.readVertices(map, path, vertexCount << 1);\n          const lengths = Utils.newArray(vertexCount / 3, 0);\n          for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n          path.lengths = lengths;\n          const color = getValue(map, \"color\", null);\n          if (color) path.color.setFromString(color);\n          return path;\n        }\n      case \"point\":\n        {\n          const point = this.attachmentLoader.newPointAttachment(skin, name);\n          if (!point) return null;\n          point.x = getValue(map, \"x\", 0) * scale;\n          point.y = getValue(map, \"y\", 0) * scale;\n          point.rotation = getValue(map, \"rotation\", 0);\n          const color = getValue(map, \"color\", null);\n          if (color) point.color.setFromString(color);\n          return point;\n        }\n      case \"clipping\":\n        {\n          const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n          if (!clip) return null;\n          const end = getValue(map, \"end\", null);\n          if (end != null) {\n            const slot = skeletonData.findSlot(end);\n            if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n            clip.endSlot = slot;\n          }\n          const vertexCount = map.vertexCount;\n          this.readVertices(map, clip, vertexCount << 1);\n          const color = getValue(map, \"color\", null);\n          if (color) clip.color.setFromString(color);\n          return clip;\n        }\n    }\n    return null;\n  }\n  readSequence(map) {\n    if (map == null) return null;\n    const sequence = new Sequence(getValue(map, \"count\", 0));\n    sequence.start = getValue(map, \"start\", 1);\n    sequence.digits = getValue(map, \"digits\", 0);\n    sequence.setupIndex = getValue(map, \"setup\", 0);\n    return sequence;\n  }\n  readVertices(map, attachment, verticesLength) {\n    const scale = this.scale;\n    attachment.worldVerticesLength = verticesLength;\n    const vertices = map.vertices;\n    if (verticesLength == vertices.length) {\n      const scaledVertices = Utils.toFloatArray(vertices);\n      if (scale != 1) {\n        for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n      }\n      attachment.vertices = scaledVertices;\n      return;\n    }\n    const weights = new Array();\n    const bones = new Array();\n    for (let i = 0, n = vertices.length; i < n;) {\n      const boneCount = vertices[i++];\n      bones.push(boneCount);\n      for (let nn = i + boneCount * 4; i < nn; i += 4) {\n        bones.push(vertices[i]);\n        weights.push(vertices[i + 1] * scale);\n        weights.push(vertices[i + 2] * scale);\n        weights.push(vertices[i + 3]);\n      }\n    }\n    attachment.bones = bones;\n    attachment.vertices = Utils.toFloatArray(weights);\n  }\n  readAnimation(map, name, skeletonData) {\n    const scale = this.scale;\n    const timelines = new Array();\n    if (map.slots) {\n      for (const slotName in map.slots) {\n        const slotMap = map.slots[slotName];\n        const slot = skeletonData.findSlot(slotName);\n        if (!slot) throw new Error(`Slot not found: ${slotName}`);\n        const slotIndex = slot.index;\n        for (const timelineName in slotMap) {\n          const timelineMap = slotMap[timelineName];\n          if (!timelineMap) continue;\n          const frames = timelineMap.length;\n          if (timelineName == \"attachment\") {\n            const timeline = new AttachmentTimeline(frames, slotIndex);\n            for (let frame = 0; frame < frames; frame++) {\n              const keyMap = timelineMap[frame];\n              timeline.setFrame(frame, getValue(keyMap, \"time\", 0), getValue(keyMap, \"name\", null));\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"rgba\") {\n            const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.color);\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.color);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n              }\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"rgb\") {\n            const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.color);\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.color);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"alpha\") {\n            timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n          } else if (timelineName == \"rgba2\") {\n            const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.light);\n              const newColor2 = Color.fromString(nextMap.dark);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          } else if (timelineName == \"rgb2\") {\n            const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n            let keyMap = timelineMap[0];\n            let time = getValue(keyMap, \"time\", 0);\n            let color = Color.fromString(keyMap.light);\n            let color2 = Color.fromString(keyMap.dark);\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const newColor = Color.fromString(nextMap.light);\n              const newColor2 = Color.fromString(nextMap.dark);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n              }\n              time = time2;\n              color = newColor;\n              color2 = newColor2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n    if (map.bones) {\n      for (const boneName in map.bones) {\n        const boneMap = map.bones[boneName];\n        const bone = skeletonData.findBone(boneName);\n        if (!bone) throw new Error(`Bone not found: ${boneName}`);\n        const boneIndex = bone.index;\n        for (const timelineName in boneMap) {\n          const timelineMap = boneMap[timelineName];\n          const frames = timelineMap.length;\n          if (frames == 0) continue;\n          if (timelineName === \"rotate\") {\n            timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n          } else if (timelineName === \"translate\") {\n            const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, scale));\n          } else if (timelineName === \"translatex\") {\n            const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === \"translatey\") {\n            const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n          } else if (timelineName === \"scale\") {\n            const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 1, 1));\n          } else if (timelineName === \"scalex\") {\n            const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === \"scaley\") {\n            const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n          } else if (timelineName === \"shear\") {\n            const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n            timelines.push(readTimeline2(timelineMap, timeline, \"x\", \"y\", 0, 1));\n          } else if (timelineName === \"shearx\") {\n            const timeline = new ShearXTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n          } else if (timelineName === \"sheary\") {\n            const timeline = new ShearYTimeline(frames, frames, boneIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n          }\n        }\n      }\n    }\n    if (map.ik) {\n      for (const constraintName in map.ik) {\n        const constraintMap = map.ik[constraintName];\n        let keyMap = constraintMap[0];\n        if (!keyMap) continue;\n        const constraint = skeletonData.findIkConstraint(constraintName);\n        if (!constraint) throw new Error(`IK Constraint not found: ${constraintName}`);\n        const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n        const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n        let time = getValue(keyMap, \"time\", 0);\n        let mix = getValue(keyMap, \"mix\", 1);\n        let softness = getValue(keyMap, \"softness\", 0) * scale;\n        for (let frame = 0, bezier = 0;; frame++) {\n          timeline.setFrame(frame, time, mix, softness, getValue(keyMap, \"bendPositive\", true) ? 1 : -1, getValue(keyMap, \"compress\", false), getValue(keyMap, \"stretch\", false));\n          const nextMap = constraintMap[frame + 1];\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n          const time2 = getValue(nextMap, \"time\", 0);\n          const mix2 = getValue(nextMap, \"mix\", 1);\n          const softness2 = getValue(nextMap, \"softness\", 0) * scale;\n          const curve = keyMap.curve;\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n          }\n          time = time2;\n          mix = mix2;\n          softness = softness2;\n          keyMap = nextMap;\n        }\n        timelines.push(timeline);\n      }\n    }\n    if (map.transform) {\n      for (const constraintName in map.transform) {\n        const timelineMap = map.transform[constraintName];\n        let keyMap = timelineMap[0];\n        if (!keyMap) continue;\n        const constraint = skeletonData.findTransformConstraint(constraintName);\n        if (!constraint) throw new Error(`Transform constraint not found: ${constraintName}`);\n        const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n        const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n        let time = getValue(keyMap, \"time\", 0);\n        let mixRotate = getValue(keyMap, \"mixRotate\", 1);\n        let mixX = getValue(keyMap, \"mixX\", 1);\n        let mixY = getValue(keyMap, \"mixY\", mixX);\n        let mixScaleX = getValue(keyMap, \"mixScaleX\", 1);\n        let mixScaleY = getValue(keyMap, \"mixScaleY\", mixScaleX);\n        const mixShearY = getValue(keyMap, \"mixShearY\", 1);\n        for (let frame = 0, bezier = 0;; frame++) {\n          timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n          const nextMap = timelineMap[frame + 1];\n          if (!nextMap) {\n            timeline.shrink(bezier);\n            break;\n          }\n          const time2 = getValue(nextMap, \"time\", 0);\n          const mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n          const mixX2 = getValue(nextMap, \"mixX\", 1);\n          const mixY2 = getValue(nextMap, \"mixY\", mixX2);\n          const mixScaleX2 = getValue(nextMap, \"mixScaleX\", 1);\n          const mixScaleY2 = getValue(nextMap, \"mixScaleY\", mixScaleX2);\n          const mixShearY2 = getValue(nextMap, \"mixShearY\", 1);\n          const curve = keyMap.curve;\n          if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n          }\n          time = time2;\n          mixRotate = mixRotate2;\n          mixX = mixX2;\n          mixY = mixY2;\n          mixScaleX = mixScaleX2;\n          mixScaleY = mixScaleY2;\n          mixScaleX = mixScaleX2;\n          keyMap = nextMap;\n        }\n        timelines.push(timeline);\n      }\n    }\n    if (map.path) {\n      for (const constraintName in map.path) {\n        const constraintMap = map.path[constraintName];\n        const constraint = skeletonData.findPathConstraint(constraintName);\n        if (!constraint) throw new Error(`Path constraint not found: ${constraintName}`);\n        const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\n        for (const timelineName in constraintMap) {\n          const timelineMap = constraintMap[timelineName];\n          let keyMap = timelineMap[0];\n          if (!keyMap) continue;\n          const frames = timelineMap.length;\n          if (timelineName === \"position\") {\n            const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n          } else if (timelineName === \"spacing\") {\n            const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n            timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1));\n          } else if (timelineName === \"mix\") {\n            const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n            let time = getValue(keyMap, \"time\", 0);\n            let mixRotate = getValue(keyMap, \"mixRotate\", 1);\n            let mixX = getValue(keyMap, \"mixX\", 1);\n            let mixY = getValue(keyMap, \"mixY\", mixX);\n            for (let frame = 0, bezier = 0;; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              const nextMap = timelineMap[frame + 1];\n              if (!nextMap) {\n                timeline.shrink(bezier);\n                break;\n              }\n              const time2 = getValue(nextMap, \"time\", 0);\n              const mixRotate2 = getValue(nextMap, \"mixRotate\", 1);\n              const mixX2 = getValue(nextMap, \"mixX\", 1);\n              const mixY2 = getValue(nextMap, \"mixY\", mixX2);\n              const curve = keyMap.curve;\n              if (curve) {\n                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n              keyMap = nextMap;\n            }\n            timelines.push(timeline);\n          }\n        }\n      }\n    }\n    if (map.deform) {\n      map.attachments = {};\n      for (const deformName in map.deform) {\n        const deformMap = map.deform[deformName];\n        const outMap = map.attachments[deformName] = {};\n        for (const slotName in deformMap) {\n          const slotMap = deformMap[slotName];\n          const outMap2 = outMap[slotName] = {};\n          for (const innerMapName in slotMap) {\n            outMap2[innerMapName] = {\n              deform: slotMap[innerMapName]\n            };\n          }\n        }\n      }\n    }\n    if (map.attachments) {\n      for (const attachmentsName in map.attachments) {\n        const attachmentsMap = map.attachments[attachmentsName];\n        const skin = skeletonData.findSkin(attachmentsName);\n        if (skin == null) {\n          if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n            throw new Error(`Skin not found: ${attachmentsName}`);\n          } else {\n            continue;\n          }\n        }\n        for (const slotMapName in attachmentsMap) {\n          const slotMap = attachmentsMap[slotMapName];\n          const slot = skeletonData.findSlot(slotMapName);\n          if (!slot) throw new Error(`Slot not found: ${slotMapName}`);\n          const slotIndex = slot.index;\n          for (const attachmentMapName in slotMap) {\n            const attachmentMap = slotMap[attachmentMapName];\n            const attachment = skin.getAttachment(slotIndex, attachmentMapName);\n            for (const timelineMapName in attachmentMap) {\n              const timelineMap = attachmentMap[timelineMapName];\n              let keyMap = timelineMap[0];\n              if (!keyMap) continue;\n              if (timelineMapName == \"deform\") {\n                const weighted = attachment.bones;\n                const vertices = attachment.vertices;\n                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                let time = getValue(keyMap, \"time\", 0);\n                for (let frame = 0, bezier = 0;; frame++) {\n                  let deform;\n                  const verticesValue = getValue(keyMap, \"vertices\", null);\n                  if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;else {\n                    deform = Utils.newFloatArray(deformLength);\n                    const start = getValue(keyMap, \"offset\", 0);\n                    Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                    if (scale != 1) {\n                      for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                    }\n                    if (!weighted) {\n                      for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                    }\n                  }\n                  timeline.setFrame(frame, time, deform);\n                  const nextMap = timelineMap[frame + 1];\n                  if (!nextMap) {\n                    timeline.shrink(bezier);\n                    break;\n                  }\n                  const time2 = getValue(nextMap, \"time\", 0);\n                  const curve = keyMap.curve;\n                  if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                  time = time2;\n                  keyMap = nextMap;\n                }\n                timelines.push(timeline);\n              } else if (timelineMapName == \"sequence\") {\n                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment);\n                let lastDelay = 0;\n                for (let frame = 0; frame < timelineMap.length; frame++) {\n                  const delay = getValue(keyMap, \"delay\", lastDelay);\n                  const time = getValue(keyMap, \"time\", 0);\n                  const mode = SequenceMode[getValue(keyMap, \"mode\", \"hold\")];\n                  const index = getValue(keyMap, \"index\", 0);\n                  timeline.setFrame(frame, time, mode, index, delay);\n                  lastDelay = delay;\n                  keyMap = timelineMap[frame + 1];\n                }\n                timelines.push(timeline);\n              }\n            }\n          }\n        }\n      }\n    }\n    if (map.drawOrder) {\n      const timeline = new DrawOrderTimeline(map.drawOrder.length);\n      const slotCount = skeletonData.slots.length;\n      let frame = 0;\n      for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n        const drawOrderMap = map.drawOrder[i];\n        let drawOrder = null;\n        const offsets = getValue(drawOrderMap, \"offsets\", null);\n        if (offsets) {\n          drawOrder = Utils.newArray(slotCount, -1);\n          const unchanged = Utils.newArray(slotCount - offsets.length, 0);\n          let originalIndex = 0;\n          let unchangedIndex = 0;\n          for (let ii = 0; ii < offsets.length; ii++) {\n            const offsetMap = offsets[ii];\n            const slot = skeletonData.findSlot(offsetMap.slot);\n            if (!slot) throw new Error(`Slot not found: ${slot}`);\n            const slotIndex = slot.index;\n            while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n            drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n          }\n          while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n          for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n        }\n        timeline.setFrame(frame, getValue(drawOrderMap, \"time\", 0), drawOrder);\n      }\n      timelines.push(timeline);\n    }\n    if (map.events) {\n      const timeline = new EventTimeline(map.events.length);\n      let frame = 0;\n      for (let i = 0; i < map.events.length; i++, frame++) {\n        const eventMap = map.events[i];\n        const eventData = skeletonData.findEvent(eventMap.name);\n        if (!eventData) throw new Error(`Event not found: ${eventMap.name}`);\n        const event = new Event(Utils.toSinglePrecision(getValue(eventMap, \"time\", 0)), eventData);\n        event.intValue = getValue(eventMap, \"int\", eventData.intValue);\n        event.floatValue = getValue(eventMap, \"float\", eventData.floatValue);\n        event.stringValue = getValue(eventMap, \"string\", eventData.stringValue);\n        if (event.data.audioPath) {\n          event.volume = getValue(eventMap, \"volume\", 1);\n          event.balance = getValue(eventMap, \"balance\", 0);\n        }\n        timeline.setFrame(frame, event);\n      }\n      timelines.push(timeline);\n    }\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n    if (isNaN(duration)) {\n      throw new Error(\"Error while parsing animation, duration is NaN\");\n    }\n    skeletonData.animations.push(new Animation(name, timelines, duration));\n  }\n  static blendModeFromString(str) {\n    str = str.toLowerCase();\n    if (str == \"normal\") return BLEND_MODES.NORMAL;\n    if (str == \"additive\") return BLEND_MODES.ADD;\n    if (str == \"multiply\") return BLEND_MODES.MULTIPLY;\n    if (str == \"screen\") return BLEND_MODES.SCREEN;\n    throw new Error(`Unknown blend mode: ${str}`);\n  }\n}\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\nfunction readTimeline1(keys, timeline, defaultValue, scale) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, \"time\", 0);\n  let value = getValue(keyMap, \"value\", defaultValue) * scale;\n  let bezier = 0;\n  for (let frame = 0;; frame++) {\n    timeline.setFrame(frame, time, value);\n    const nextMap = keys[frame + 1];\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n    const time2 = getValue(nextMap, \"time\", 0);\n    const value2 = getValue(nextMap, \"value\", defaultValue) * scale;\n    if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n    time = time2;\n    value = value2;\n    keyMap = nextMap;\n  }\n}\nfunction readTimeline2(keys, timeline, name1, name2, defaultValue, scale) {\n  let keyMap = keys[0];\n  let time = getValue(keyMap, \"time\", 0);\n  let value1 = getValue(keyMap, name1, defaultValue) * scale;\n  let value2 = getValue(keyMap, name2, defaultValue) * scale;\n  let bezier = 0;\n  for (let frame = 0;; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    const nextMap = keys[frame + 1];\n    if (!nextMap) {\n      timeline.shrink(bezier);\n      return timeline;\n    }\n    const time2 = getValue(nextMap, \"time\", 0);\n    const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n    const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n    const curve = keyMap.curve;\n    if (curve) {\n      bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n      bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n    keyMap = nextMap;\n  }\n}\nfunction readCurve(curve, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  if (curve == \"stepped\") {\n    timeline.setStepped(frame);\n    return bezier;\n  }\n  const i = value << 2;\n  const cx1 = curve[i];\n  const cy1 = curve[i + 1] * scale;\n  const cx2 = curve[i + 2];\n  const cy2 = curve[i + 3] * scale;\n  timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n  return bezier + 1;\n}\nfunction getValue(map, property, defaultValue) {\n  return map[property] !== void 0 ? map[property] : defaultValue;\n}\nexport { SkeletonJson };","map":{"version":3,"names":["SkeletonJson","constructor","attachmentLoader","scale","linkedMeshes","Array","readSkeletonData","json","skeletonData","SkeletonData","root","JSON","parse","skeletonMap","skeleton","hash","version","spine","verShort","substr","error","console","x","y","width","height","fps","imagesPath","images","bones","i","length","boneMap","parent","parentName","getValue","findBone","Error","data","BoneData","name","rotation","scaleX","scaleY","shearX","shearY","transformMode","Utils","enumValue","TransformMode","skinRequired","color","setFromString","push","slots","slotMap","boneData","bone","SlotData","dark","darkColor","Color","fromString","attachmentName","blendMode","blendModeFromString","ik","constraintMap","IkConstraintData","order","ii","boneName","target","mix","softness","bendDirection","compress","stretch","uniform","ikConstraints","transform","TransformConstraintData","targetName","local","relative","offsetRotation","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","transformConstraints","path","PathConstraintData","findSlot","positionMode","PositionMode","spacingMode","SpacingMode","rotateMode","RotateMode","position","Fixed","spacing","Length","pathConstraints","skins","skinMap","skin","Skin","constraintName","constraint","findIkConstraint","constraints","findTransformConstraint","findPathConstraint","slotName","attachments","slot","entryName","attachment","readAttachment","index","setAttachment","defaultSkin","n","linkedMesh","findSkin","getAttachment","slotIndex","mesh","timelineAttachment","inheritTimeline","setParentMesh","events","eventName","eventMap","EventData","intValue","floatValue","stringValue","audioPath","volume","balance","animations","animationName","animationMap","readAnimation","map","sequence","readSequence","region","newRegionAttachment","box","newBoundingBoxAttachment","readVertices","vertexCount","newMeshAttachment","LinkedMesh","uvs","triangles","regionUVs","Float32Array","edges","hullLength","newPathAttachment","closed","constantSpeed","lengths","newArray","point","newPointAttachment","clip","newClippingAttachment","end","endSlot","Sequence","start","digits","setupIndex","verticesLength","worldVerticesLength","vertices","scaledVertices","toFloatArray","weights","boneCount","nn","timelines","timelineName","timelineMap","frames","timeline","AttachmentTimeline","frame","keyMap","setFrame","RGBATimeline","time","bezier","r","g","b","a","nextMap","shrink","time2","newColor","curve","readCurve","RGBTimeline","readTimeline1","AlphaTimeline","RGBA2Timeline","light","color2","newColor2","RGB2Timeline","boneIndex","RotateTimeline","TranslateTimeline","readTimeline2","TranslateXTimeline","TranslateYTimeline","ScaleTimeline","ScaleXTimeline","ScaleYTimeline","ShearTimeline","ShearXTimeline","ShearYTimeline","constraintIndex","indexOf","IkConstraintTimeline","mix2","softness2","TransformConstraintTimeline","mixRotate2","mixX2","mixY2","mixScaleX2","mixScaleY2","mixShearY2","PathConstraintPositionTimeline","PathConstraintSpacingTimeline","PathConstraintMixTimeline","deform","deformName","deformMap","outMap","outMap2","innerMapName","attachmentsName","attachmentsMap","settings","FAIL_ON_NON_EXISTING_SKIN","slotMapName","attachmentMapName","attachmentMap","timelineMapName","weighted","deformLength","DeformTimeline","verticesValue","newFloatArray","arrayCopy","SequenceTimeline","lastDelay","delay","mode","SequenceMode","drawOrder","DrawOrderTimeline","slotCount","drawOrderMap","offsets","unchanged","originalIndex","unchangedIndex","offsetMap","offset","EventTimeline","eventData","findEvent","event","Event","toSinglePrecision","duration","Math","max","getDuration","isNaN","Animation","str","toLowerCase","BLEND_MODES","NORMAL","ADD","MULTIPLY","SCREEN","inheritDeform","keys","defaultValue","value","value2","name1","name2","value1","nvalue1","nvalue2","time1","setStepped","cx1","cy1","cx2","cy2","setBezier","property"],"sources":["../../src/core/SkeletonJson.ts"],"sourcesContent":["import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    SequenceTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { NumberArrayLike, Color, IHasTextureRegion, PositionMode, RotateMode, TransformMode, Utils, settings } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport { Sequence, SequenceMode } from './attachments/Sequence';\n\n/** Loads skeleton data in the Spine JSON format.\n *\n * See [Spine JSON format](http://esotericsoftware.com/spine-json-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonJson {\n    attachmentLoader: AttachmentLoader;\n\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(json: string | any): SkeletonData {\n        const scale = this.scale;\n        const skeletonData = new SkeletonData();\n        const root = typeof json === 'string' ? JSON.parse(json) : json;\n\n        // Skeleton\n        const skeletonMap = root.skeleton;\n\n        if (skeletonMap) {\n            skeletonData.hash = skeletonMap.hash;\n            skeletonData.version = skeletonMap.spine;\n            const verShort = skeletonData.version.substr(0, 3);\n\n            if (verShort !== '4.0' && verShort !== '4.1') {\n                const error = `Spine 4.1 loader cant load version ${skeletonMap.spine}. Please configure your pixi-spine bundle`;\n\n                console.error(error);\n            }\n            skeletonData.x = skeletonMap.x;\n            skeletonData.y = skeletonMap.y;\n            skeletonData.width = skeletonMap.width;\n            skeletonData.height = skeletonMap.height;\n            skeletonData.fps = skeletonMap.fps;\n            skeletonData.imagesPath = skeletonMap.images;\n        }\n\n        // Bones\n        if (root.bones) {\n            for (let i = 0; i < root.bones.length; i++) {\n                const boneMap = root.bones[i];\n\n                let parent: BoneData = null;\n                const parentName: string = getValue(boneMap, 'parent', null);\n\n                if (parentName != null) {\n                    parent = skeletonData.findBone(parentName);\n                    if (parent == null) throw new Error(`Parent bone not found: ${parentName}`);\n                }\n                const data = new BoneData(skeletonData.bones.length, boneMap.name, parent);\n\n                data.length = getValue(boneMap, 'length', 0) * scale;\n                data.x = getValue(boneMap, 'x', 0) * scale;\n                data.y = getValue(boneMap, 'y', 0) * scale;\n                data.rotation = getValue(boneMap, 'rotation', 0);\n                data.scaleX = getValue(boneMap, 'scaleX', 1);\n                data.scaleY = getValue(boneMap, 'scaleY', 1);\n                data.shearX = getValue(boneMap, 'shearX', 0);\n                data.shearY = getValue(boneMap, 'shearY', 0);\n                data.transformMode = Utils.enumValue(TransformMode, getValue(boneMap, 'transform', 'Normal'));\n                data.skinRequired = getValue(boneMap, 'skin', false);\n\n                const color = getValue(boneMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                skeletonData.bones.push(data);\n            }\n        }\n\n        // Slots.\n        if (root.slots) {\n            for (let i = 0; i < root.slots.length; i++) {\n                const slotMap = root.slots[i];\n                const boneData = skeletonData.findBone(slotMap.bone);\n\n                if (!boneData) throw new Error(`Couldn't find bone ${slotMap.bone} for slot ${slotMap.name}`);\n                const data = new SlotData(skeletonData.slots.length, slotMap.name, boneData);\n\n                const color: string = getValue(slotMap, 'color', null);\n\n                if (color) data.color.setFromString(color);\n\n                const dark: string = getValue(slotMap, 'dark', null);\n\n                if (dark) data.darkColor = Color.fromString(dark);\n\n                data.attachmentName = getValue(slotMap, 'attachment', null);\n                data.blendMode = SkeletonJson.blendModeFromString(getValue(slotMap, 'blend', 'normal'));\n                skeletonData.slots.push(data);\n            }\n        }\n\n        // IK constraints\n        if (root.ik) {\n            for (let i = 0; i < root.ik.length; i++) {\n                const constraintMap = root.ik[i];\n                const data = new IkConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (bone == null) throw new Error(`IK bone not found: ${boneName}`);\n                    data.bones.push(bone);\n                }\n\n                data.target = skeletonData.findBone(constraintMap.target);\n\n                data.mix = getValue(constraintMap, 'mix', 1);\n                data.softness = getValue(constraintMap, 'softness', 0) * scale;\n                data.bendDirection = getValue(constraintMap, 'bendPositive', true) ? 1 : -1;\n                data.compress = getValue(constraintMap, 'compress', false);\n                data.stretch = getValue(constraintMap, 'stretch', false);\n                data.uniform = getValue(constraintMap, 'uniform', false);\n\n                skeletonData.ikConstraints.push(data);\n            }\n        }\n\n        // Transform constraints.\n        if (root.transform) {\n            for (let i = 0; i < root.transform.length; i++) {\n                const constraintMap = root.transform[i];\n                const data = new TransformConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for transform constraint ${constraintMap.name}.`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n                const target = skeletonData.findBone(targetName);\n\n                if (!target) throw new Error(`Couldn't find target bone ${targetName} for transform constraint ${constraintMap.name}.`);\n                data.target = target;\n\n                data.local = getValue(constraintMap, 'local', false);\n                data.relative = getValue(constraintMap, 'relative', false);\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.offsetX = getValue(constraintMap, 'x', 0) * scale;\n                data.offsetY = getValue(constraintMap, 'y', 0) * scale;\n                data.offsetScaleX = getValue(constraintMap, 'scaleX', 0);\n                data.offsetScaleY = getValue(constraintMap, 'scaleY', 0);\n                data.offsetShearY = getValue(constraintMap, 'shearY', 0);\n\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n                data.mixScaleX = getValue(constraintMap, 'mixScaleX', 1);\n                data.mixScaleY = getValue(constraintMap, 'mixScaleY', data.mixScaleX);\n                data.mixShearY = getValue(constraintMap, 'mixShearY', 1);\n\n                skeletonData.transformConstraints.push(data);\n            }\n        }\n\n        // Path constraints.\n        if (root.path) {\n            for (let i = 0; i < root.path.length; i++) {\n                const constraintMap = root.path[i];\n                const data = new PathConstraintData(constraintMap.name);\n\n                data.order = getValue(constraintMap, 'order', 0);\n                data.skinRequired = getValue(constraintMap, 'skin', false);\n\n                for (let ii = 0; ii < constraintMap.bones.length; ii++) {\n                    const boneName = constraintMap.bones[ii];\n                    const bone = skeletonData.findBone(boneName);\n\n                    if (!bone) throw new Error(`Couldn't find bone ${boneName} for path constraint ${constraintMap.name}.`);\n                    data.bones.push(bone);\n                }\n\n                const targetName: string = constraintMap.target;\n                const target = skeletonData.findSlot(targetName);\n\n                if (!target) throw new Error(`Couldn't find target slot ${targetName} for path constraint ${constraintMap.name}.`);\n                data.target = target;\n\n                data.positionMode = Utils.enumValue(PositionMode, getValue(constraintMap, 'positionMode', 'Percent'));\n                data.spacingMode = Utils.enumValue(SpacingMode, getValue(constraintMap, 'spacingMode', 'Length'));\n                data.rotateMode = Utils.enumValue(RotateMode, getValue(constraintMap, 'rotateMode', 'Tangent'));\n                data.offsetRotation = getValue(constraintMap, 'rotation', 0);\n                data.position = getValue(constraintMap, 'position', 0);\n                if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n                data.spacing = getValue(constraintMap, 'spacing', 0);\n                if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n                data.mixRotate = getValue(constraintMap, 'mixRotate', 1);\n                data.mixX = getValue(constraintMap, 'mixX', 1);\n                data.mixY = getValue(constraintMap, 'mixY', data.mixX);\n\n                skeletonData.pathConstraints.push(data);\n            }\n        }\n\n        // Skins.\n        if (root.skins) {\n            for (let i = 0; i < root.skins.length; i++) {\n                const skinMap = root.skins[i];\n                const skin = new Skin(skinMap.name);\n\n                if (skinMap.bones) {\n                    for (let ii = 0; ii < skinMap.bones.length; ii++) {\n                        const boneName = skinMap.bones[ii];\n                        const bone = skeletonData.findBone(boneName);\n\n                        if (!bone) throw new Error(`Couldn't find bone ${boneName} for skin ${skinMap.name}.`);\n                        skin.bones.push(bone);\n                    }\n                }\n\n                if (skinMap.ik) {\n                    for (let ii = 0; ii < skinMap.ik.length; ii++) {\n                        const constraintName = skinMap.ik[ii];\n                        const constraint = skeletonData.findIkConstraint(constraintName);\n\n                        if (!constraint) throw new Error(`Couldn't find IK constraint ${constraintName} for skin ${skinMap.name}.`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.transform) {\n                    for (let ii = 0; ii < skinMap.transform.length; ii++) {\n                        const constraintName = skinMap.transform[ii];\n                        const constraint = skeletonData.findTransformConstraint(constraintName);\n\n                        if (!constraint) throw new Error(`Couldn't find transform constraint ${constraintName} for skin ${skinMap.name}.`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                if (skinMap.path) {\n                    for (let ii = 0; ii < skinMap.path.length; ii++) {\n                        const constraintName = skinMap.path[ii];\n                        const constraint = skeletonData.findPathConstraint(constraintName);\n\n                        if (!constraint) throw new Error(`Couldn't find path constraint ${constraintName} for skin ${skinMap.name}.`);\n                        skin.constraints.push(constraint);\n                    }\n                }\n\n                for (const slotName in skinMap.attachments) {\n                    const slot = skeletonData.findSlot(slotName);\n\n                    if (!slot) throw new Error(`Couldn't find slot ${slotName} for skin ${skinMap.name}.`);\n                    const slotMap = skinMap.attachments[slotName];\n\n                    for (const entryName in slotMap) {\n                        const attachment = this.readAttachment(slotMap[entryName], skin, slot.index, entryName, skeletonData);\n\n                        if (attachment) skin.setAttachment(slot.index, entryName, attachment);\n                    }\n                }\n                skeletonData.skins.push(skin);\n                if (skin.name == 'default') skeletonData.defaultSkin = skin;\n            }\n        }\n\n        // Linked meshes.\n        for (let i = 0, n = this.linkedMeshes.length; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (!skin) throw new Error(`Skin not found: ${linkedMesh.skin}`);\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? <VertexAttachment>parent : <VertexAttachment>linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(<MeshAttachment>parent);\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        if (root.events) {\n            for (const eventName in root.events) {\n                const eventMap = root.events[eventName];\n                const data = new EventData(eventName);\n\n                data.intValue = getValue(eventMap, 'int', 0);\n                data.floatValue = getValue(eventMap, 'float', 0);\n                data.stringValue = getValue(eventMap, 'string', '');\n                data.audioPath = getValue(eventMap, 'audio', null);\n                if (data.audioPath) {\n                    data.volume = getValue(eventMap, 'volume', 1);\n                    data.balance = getValue(eventMap, 'balance', 0);\n                }\n                skeletonData.events.push(data);\n            }\n        }\n\n        // Animations.\n        if (root.animations) {\n            for (const animationName in root.animations) {\n                const animationMap = root.animations[animationName];\n\n                this.readAnimation(animationMap, animationName, skeletonData);\n            }\n        }\n\n        return skeletonData;\n    }\n\n    readAttachment(map: any, skin: Skin, slotIndex: number, name: string, skeletonData: SkeletonData): Attachment | null {\n        const scale = this.scale;\n\n        name = getValue(map, 'name', name);\n\n        switch (getValue(map, 'type', 'region')) {\n            case 'region': {\n                const path = getValue(map, 'path', name);\n                const sequence = this.readSequence(getValue(map, 'sequence', null));\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = getValue(map, 'x', 0) * scale;\n                region.y = getValue(map, 'y', 0) * scale;\n                region.scaleX = getValue(map, 'scaleX', 1);\n                region.scaleY = getValue(map, 'scaleY', 1);\n                region.rotation = getValue(map, 'rotation', 0);\n                region.width = map.width * scale;\n                region.height = map.height * scale;\n                region.sequence = sequence;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) region.color.setFromString(color);\n\n                // if (region.region != null) region.updateRegion();\n                return region;\n            }\n            case 'boundingbox': {\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                this.readVertices(map, box, map.vertexCount << 1);\n                const color: string = getValue(map, 'color', null);\n\n                if (color) box.color.setFromString(color);\n\n                return box;\n            }\n            case 'mesh':\n            case 'linkedmesh': {\n                const path = getValue(map, 'path', name);\n                const sequence = this.readSequence(getValue(map, 'sequence', null));\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\n                if (!mesh) return null;\n                mesh.path = path;\n\n                const color = getValue(map, 'color', null);\n\n                if (color) mesh.color.setFromString(color);\n\n                mesh.width = getValue(map, 'width', 0) * scale;\n                mesh.height = getValue(map, 'height', 0) * scale;\n                mesh.sequence = sequence;\n\n                const parent: string = getValue(map, 'parent', null);\n\n                if (parent) {\n                    this.linkedMeshes.push(new LinkedMesh(mesh, <string>getValue(map, 'skin', null), slotIndex, parent, getValue(map, 'timelines', true)));\n\n                    return mesh;\n                }\n\n                const uvs: Array<number> = map.uvs;\n\n                this.readVertices(map, mesh, uvs.length);\n                mesh.triangles = map.triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // if (mesh.region != null) mesh.updateRegion();\n\n                mesh.edges = getValue(map, 'edges', null);\n                mesh.hullLength = getValue(map, 'hull', 0) * 2;\n\n                return mesh;\n            }\n            case 'path': {\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = getValue(map, 'closed', false);\n                path.constantSpeed = getValue(map, 'constantSpeed', true);\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, path, vertexCount << 1);\n\n                const lengths: Array<number> = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0; i < map.lengths.length; i++) lengths[i] = map.lengths[i] * scale;\n                path.lengths = lengths;\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) path.color.setFromString(color);\n\n                return path;\n            }\n            case 'point': {\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = getValue(map, 'x', 0) * scale;\n                point.y = getValue(map, 'y', 0) * scale;\n                point.rotation = getValue(map, 'rotation', 0);\n\n                const color = getValue(map, 'color', null);\n\n                if (color) point.color.setFromString(color);\n\n                return point;\n            }\n            case 'clipping': {\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n\n                const end = getValue(map, 'end', null);\n\n                if (end != null) {\n                    const slot = skeletonData.findSlot(end);\n\n                    if (slot == null) throw new Error(`Clipping end slot not found: ${end}`);\n                    clip.endSlot = slot;\n                }\n\n                const vertexCount = map.vertexCount;\n\n                this.readVertices(map, clip, vertexCount << 1);\n\n                const color: string = getValue(map, 'color', null);\n\n                if (color) clip.color.setFromString(color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    readSequence(map: any) {\n        if (map == null) return null;\n        const sequence = new Sequence(getValue(map, 'count', 0));\n\n        sequence.start = getValue(map, 'start', 1);\n        sequence.digits = getValue(map, 'digits', 0);\n        sequence.setupIndex = getValue(map, 'setup', 0);\n\n        return sequence;\n    }\n\n    readVertices(map: any, attachment: VertexAttachment, verticesLength: number) {\n        const scale = this.scale;\n\n        attachment.worldVerticesLength = verticesLength;\n        const vertices: Array<number> = map.vertices;\n\n        if (verticesLength == vertices.length) {\n            const scaledVertices = Utils.toFloatArray(vertices);\n\n            if (scale != 1) {\n                for (let i = 0, n = vertices.length; i < n; i++) scaledVertices[i] *= scale;\n            }\n            attachment.vertices = scaledVertices;\n\n            return;\n        }\n        const weights = new Array<number>();\n        const bones = new Array<number>();\n\n        for (let i = 0, n = vertices.length; i < n; ) {\n            const boneCount = vertices[i++];\n\n            bones.push(boneCount);\n            for (let nn = i + boneCount * 4; i < nn; i += 4) {\n                bones.push(vertices[i]);\n                weights.push(vertices[i + 1] * scale);\n                weights.push(vertices[i + 2] * scale);\n                weights.push(vertices[i + 3]);\n            }\n        }\n        attachment.bones = bones;\n        attachment.vertices = Utils.toFloatArray(weights);\n    }\n\n    readAnimation(map: any, name: string, skeletonData: SkeletonData) {\n        const scale = this.scale;\n        const timelines = new Array<Timeline>();\n\n        // Slot timelines.\n        if (map.slots) {\n            for (const slotName in map.slots) {\n                const slotMap = map.slots[slotName];\n                const slot = skeletonData.findSlot(slotName);\n\n                if (!slot) throw new Error(`Slot not found: ${slotName}`);\n                const slotIndex = slot.index;\n\n                for (const timelineName in slotMap) {\n                    const timelineMap = slotMap[timelineName];\n\n                    if (!timelineMap) continue;\n                    const frames = timelineMap.length;\n\n                    if (timelineName == 'attachment') {\n                        const timeline = new AttachmentTimeline(frames, slotIndex);\n\n                        for (let frame = 0; frame < frames; frame++) {\n                            const keyMap = timelineMap[frame];\n\n                            timeline.setFrame(frame, getValue(keyMap, 'time', 0), getValue(keyMap, 'name', null));\n                        }\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgba') {\n                        const timeline = new RGBATimeline(frames, frames << 2, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb') {\n                        const timeline = new RGBTimeline(frames, frames * 3, slotIndex);\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.color);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.color);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'alpha') {\n                        timelines.push(readTimeline1(timelineMap, new AlphaTimeline(frames, frames, slotIndex), 0, 1));\n                    } else if (timelineName == 'rgba2') {\n                        const timeline = new RGBA2Timeline(frames, frames * 7, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color.a, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color.a, newColor.a, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 6, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    } else if (timelineName == 'rgb2') {\n                        const timeline = new RGB2Timeline(frames, frames * 6, slotIndex);\n\n                        let keyMap = timelineMap[0];\n                        let time = getValue(keyMap, 'time', 0);\n                        let color = Color.fromString(keyMap.light);\n                        let color2 = Color.fromString(keyMap.dark);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, color.r, color.g, color.b, color2.r, color2.g, color2.b);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const newColor = Color.fromString(nextMap.light);\n                            const newColor2 = Color.fromString(nextMap.dark);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, color.r, newColor.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, color.g, newColor.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, color.b, newColor.b, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, color2.r, newColor2.r, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, color2.g, newColor2.g, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, color2.b, newColor2.b, 1);\n                            }\n                            time = time2;\n                            color = newColor;\n                            color2 = newColor2;\n                            keyMap = nextMap;\n                        }\n\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Bone timelines.\n        if (map.bones) {\n            for (const boneName in map.bones) {\n                const boneMap = map.bones[boneName];\n                const bone = skeletonData.findBone(boneName);\n\n                if (!bone) throw new Error(`Bone not found: ${boneName}`);\n                const boneIndex = bone.index;\n\n                for (const timelineName in boneMap) {\n                    const timelineMap = boneMap[timelineName];\n                    const frames = timelineMap.length;\n\n                    if (frames == 0) continue;\n\n                    if (timelineName === 'rotate') {\n                        timelines.push(readTimeline1(timelineMap, new RotateTimeline(frames, frames, boneIndex), 0, 1));\n                    } else if (timelineName === 'translate') {\n                        const timeline = new TranslateTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, scale));\n                    } else if (timelineName === 'translatex') {\n                        const timeline = new TranslateXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'translatey') {\n                        const timeline = new TranslateYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, scale));\n                    } else if (timelineName === 'scale') {\n                        const timeline = new ScaleTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 1, 1));\n                    } else if (timelineName === 'scalex') {\n                        const timeline = new ScaleXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'scaley') {\n                        const timeline = new ScaleYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 1, 1));\n                    } else if (timelineName === 'shear') {\n                        const timeline = new ShearTimeline(frames, frames << 1, boneIndex);\n\n                        timelines.push(readTimeline2(timelineMap, timeline, 'x', 'y', 0, 1));\n                    } else if (timelineName === 'shearx') {\n                        const timeline = new ShearXTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    } else if (timelineName === 'sheary') {\n                        const timeline = new ShearYTimeline(frames, frames, boneIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, 1));\n                    }\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        if (map.ik) {\n            for (const constraintName in map.ik) {\n                const constraintMap = map.ik[constraintName];\n                let keyMap = constraintMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findIkConstraint(constraintName);\n\n                if (!constraint) throw new Error(`IK Constraint not found: ${constraintName}`);\n                const constraintIndex = skeletonData.ikConstraints.indexOf(constraint);\n                const timeline = new IkConstraintTimeline(constraintMap.length, constraintMap.length << 1, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mix = getValue(keyMap, 'mix', 1);\n                let softness = getValue(keyMap, 'softness', 0) * scale;\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(\n                        frame,\n                        time,\n                        mix,\n                        softness,\n                        getValue(keyMap, 'bendPositive', true) ? 1 : -1,\n                        getValue(keyMap, 'compress', false),\n                        getValue(keyMap, 'stretch', false)\n                    );\n                    const nextMap = constraintMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mix2 = getValue(nextMap, 'mix', 1);\n                    const softness2 = getValue(nextMap, 'softness', 0) * scale;\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mix, mix2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, softness, softness2, scale);\n                    }\n\n                    time = time2;\n                    mix = mix2;\n                    softness = softness2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Transform constraint timelines.\n        if (map.transform) {\n            for (const constraintName in map.transform) {\n                const timelineMap = map.transform[constraintName];\n                let keyMap = timelineMap[0];\n\n                if (!keyMap) continue;\n\n                const constraint = skeletonData.findTransformConstraint(constraintName);\n\n                if (!constraint) throw new Error(`Transform constraint not found: ${constraintName}`);\n                const constraintIndex = skeletonData.transformConstraints.indexOf(constraint);\n                const timeline = new TransformConstraintTimeline(timelineMap.length, timelineMap.length * 6, constraintIndex);\n\n                let time = getValue(keyMap, 'time', 0);\n                let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                let mixX = getValue(keyMap, 'mixX', 1);\n                let mixY = getValue(keyMap, 'mixY', mixX);\n                let mixScaleX = getValue(keyMap, 'mixScaleX', 1);\n                let mixScaleY = getValue(keyMap, 'mixScaleY', mixScaleX);\n                const mixShearY = getValue(keyMap, 'mixShearY', 1);\n\n                for (let frame = 0, bezier = 0; ; frame++) {\n                    timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                    const nextMap = timelineMap[frame + 1];\n\n                    if (!nextMap) {\n                        timeline.shrink(bezier);\n                        break;\n                    }\n\n                    const time2 = getValue(nextMap, 'time', 0);\n                    const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                    const mixX2 = getValue(nextMap, 'mixX', 1);\n                    const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                    const mixScaleX2 = getValue(nextMap, 'mixScaleX', 1);\n                    const mixScaleY2 = getValue(nextMap, 'mixScaleY', mixScaleX2);\n                    const mixShearY2 = getValue(nextMap, 'mixShearY', 1);\n                    const curve = keyMap.curve;\n\n                    if (curve) {\n                        bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        bezier = readCurve(curve, timeline, bezier, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                    }\n\n                    time = time2;\n                    mixRotate = mixRotate2;\n                    mixX = mixX2;\n                    mixY = mixY2;\n                    mixScaleX = mixScaleX2;\n                    mixScaleY = mixScaleY2;\n                    mixScaleX = mixScaleX2;\n                    keyMap = nextMap;\n                }\n                timelines.push(timeline);\n            }\n        }\n\n        // Path constraint timelines.\n        if (map.path) {\n            for (const constraintName in map.path) {\n                const constraintMap = map.path[constraintName];\n                const constraint = skeletonData.findPathConstraint(constraintName);\n\n                if (!constraint) throw new Error(`Path constraint not found: ${constraintName}`);\n                const constraintIndex = skeletonData.pathConstraints.indexOf(constraint);\n\n                for (const timelineName in constraintMap) {\n                    const timelineMap = constraintMap[timelineName];\n                    let keyMap = timelineMap[0];\n\n                    if (!keyMap) continue;\n\n                    const frames = timelineMap.length;\n\n                    if (timelineName === 'position') {\n                        const timeline = new PathConstraintPositionTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(readTimeline1(timelineMap, timeline, 0, constraint.positionMode == PositionMode.Fixed ? scale : 1));\n                    } else if (timelineName === 'spacing') {\n                        const timeline = new PathConstraintSpacingTimeline(frames, frames, constraintIndex);\n\n                        timelines.push(\n                            readTimeline1(timelineMap, timeline, 0, constraint.spacingMode == SpacingMode.Length || constraint.spacingMode == SpacingMode.Fixed ? scale : 1)\n                        );\n                    } else if (timelineName === 'mix') {\n                        const timeline = new PathConstraintMixTimeline(frames, frames * 3, constraintIndex);\n                        let time = getValue(keyMap, 'time', 0);\n                        let mixRotate = getValue(keyMap, 'mixRotate', 1);\n                        let mixX = getValue(keyMap, 'mixX', 1);\n                        let mixY = getValue(keyMap, 'mixY', mixX);\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            const nextMap = timelineMap[frame + 1];\n\n                            if (!nextMap) {\n                                timeline.shrink(bezier);\n                                break;\n                            }\n                            const time2 = getValue(nextMap, 'time', 0);\n                            const mixRotate2 = getValue(nextMap, 'mixRotate', 1);\n                            const mixX2 = getValue(nextMap, 'mixX', 1);\n                            const mixY2 = getValue(nextMap, 'mixY', mixX2);\n                            const curve = keyMap.curve;\n\n                            if (curve) {\n                                bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, mixX, mixX2, 1);\n                                bezier = readCurve(curve, timeline, bezier, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                            keyMap = nextMap;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // ver40 compatibility\n        if (map.deform) {\n            map.attachments = {};\n            for (const deformName in map.deform) {\n                const deformMap = map.deform[deformName];\n                const outMap = (map.attachments[deformName] = {});\n\n                for (const slotName in deformMap) {\n                    const slotMap = deformMap[slotName];\n                    const outMap2 = (outMap[slotName] = {});\n\n                    for (const innerMapName in slotMap) {\n                        outMap2[innerMapName] = {\n                            deform: slotMap[innerMapName],\n                        };\n                    }\n                }\n            }\n        }\n\n        // Attachment timelines.\n        if (map.attachments) {\n            for (const attachmentsName in map.attachments) {\n                const attachmentsMap = map.attachments[attachmentsName];\n                const skin = skeletonData.findSkin(attachmentsName);\n\n                if (skin == null) {\n                    if (settings.FAIL_ON_NON_EXISTING_SKIN) {\n                        throw new Error(`Skin not found: ${attachmentsName}`);\n                    } else {\n                        continue;\n                    }\n                }\n                for (const slotMapName in attachmentsMap) {\n                    const slotMap = attachmentsMap[slotMapName];\n                    const slot = skeletonData.findSlot(slotMapName);\n\n                    if (!slot) throw new Error(`Slot not found: ${slotMapName}`);\n                    const slotIndex = slot.index;\n\n                    for (const attachmentMapName in slotMap) {\n                        const attachmentMap = slotMap[attachmentMapName];\n                        const attachment = <VertexAttachment>skin.getAttachment(slotIndex, attachmentMapName);\n\n                        for (const timelineMapName in attachmentMap) {\n                            const timelineMap = attachmentMap[timelineMapName];\n                            let keyMap = timelineMap[0];\n\n                            if (!keyMap) continue;\n\n                            if (timelineMapName == 'deform') {\n                                const weighted = attachment.bones;\n                                const vertices = attachment.vertices;\n                                const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                                const timeline = new DeformTimeline(timelineMap.length, timelineMap.length, slotIndex, attachment);\n                                let time = getValue(keyMap, 'time', 0);\n\n                                for (let frame = 0, bezier = 0; ; frame++) {\n                                    let deform: NumberArrayLike;\n                                    const verticesValue: Array<Number> = getValue(keyMap, 'vertices', null);\n\n                                    if (!verticesValue) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                                    else {\n                                        deform = Utils.newFloatArray(deformLength);\n                                        const start = <number>getValue(keyMap, 'offset', 0);\n\n                                        Utils.arrayCopy(verticesValue, 0, deform, start, verticesValue.length);\n                                        if (scale != 1) {\n                                            for (let i = start, n = i + verticesValue.length; i < n; i++) deform[i] *= scale;\n                                        }\n                                        if (!weighted) {\n                                            for (let i = 0; i < deformLength; i++) deform[i] += vertices[i];\n                                        }\n                                    }\n\n                                    timeline.setFrame(frame, time, deform);\n                                    const nextMap = timelineMap[frame + 1];\n\n                                    if (!nextMap) {\n                                        timeline.shrink(bezier);\n                                        break;\n                                    }\n                                    const time2 = getValue(nextMap, 'time', 0);\n                                    const curve = keyMap.curve;\n\n                                    if (curve) bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, 0, 1, 1);\n                                    time = time2;\n                                    keyMap = nextMap;\n                                }\n                                timelines.push(timeline);\n                            } else if (timelineMapName == 'sequence') {\n                                const timeline = new SequenceTimeline(timelineMap.length, slotIndex, attachment as unknown as IHasTextureRegion);\n                                let lastDelay = 0;\n\n                                for (let frame = 0; frame < timelineMap.length; frame++) {\n                                    const delay = getValue(keyMap, 'delay', lastDelay);\n                                    const time = getValue(keyMap, 'time', 0);\n                                    const mode = SequenceMode[getValue(keyMap, 'mode', 'hold')] as unknown as number;\n                                    const index = getValue(keyMap, 'index', 0);\n\n                                    timeline.setFrame(frame, time, mode, index, delay);\n                                    lastDelay = delay;\n                                    keyMap = timelineMap[frame + 1];\n                                }\n                                timelines.push(timeline);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        // Draw order timelines.\n        if (map.drawOrder) {\n            const timeline = new DrawOrderTimeline(map.drawOrder.length);\n            const slotCount = skeletonData.slots.length;\n            let frame = 0;\n\n            for (let i = 0; i < map.drawOrder.length; i++, frame++) {\n                const drawOrderMap = map.drawOrder[i];\n                let drawOrder: Array<number> | null = null;\n                const offsets = getValue(drawOrderMap, 'offsets', null);\n\n                if (offsets) {\n                    drawOrder = Utils.newArray<number>(slotCount, -1);\n                    const unchanged = Utils.newArray<number>(slotCount - offsets.length, 0);\n                    let originalIndex = 0;\n                    let unchangedIndex = 0;\n\n                    for (let ii = 0; ii < offsets.length; ii++) {\n                        const offsetMap = offsets[ii];\n                        const slot = skeletonData.findSlot(offsetMap.slot);\n\n                        if (!slot) throw new Error(`Slot not found: ${slot}`);\n                        const slotIndex = slot.index;\n                        // Collect unchanged items.\n\n                        while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                        // Set changed items.\n                        drawOrder[originalIndex + offsetMap.offset] = originalIndex++;\n                    }\n                    // Collect remaining unchanged items.\n                    while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                    // Fill in unchanged items.\n                    for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                }\n                timeline.setFrame(frame, getValue(drawOrderMap, 'time', 0), drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timelines.\n        if (map.events) {\n            const timeline = new EventTimeline(map.events.length);\n            let frame = 0;\n\n            for (let i = 0; i < map.events.length; i++, frame++) {\n                const eventMap = map.events[i];\n                const eventData = skeletonData.findEvent(eventMap.name);\n\n                if (!eventData) throw new Error(`Event not found: ${eventMap.name}`);\n                const event = new Event(Utils.toSinglePrecision(getValue(eventMap, 'time', 0)), eventData);\n\n                event.intValue = getValue(eventMap, 'int', eventData.intValue);\n                event.floatValue = getValue(eventMap, 'float', eventData.floatValue);\n                event.stringValue = getValue(eventMap, 'string', eventData.stringValue);\n                if (event.data.audioPath) {\n                    event.volume = getValue(eventMap, 'volume', 1);\n                    event.balance = getValue(eventMap, 'balance', 0);\n                }\n                timeline.setFrame(frame, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n        if (isNaN(duration)) {\n            throw new Error('Error while parsing animation, duration is NaN');\n        }\n\n        skeletonData.animations.push(new Animation(name, timelines, duration));\n    }\n    static blendModeFromString(str: string) {\n        str = str.toLowerCase();\n        if (str == 'normal') return BLEND_MODES.NORMAL;\n        if (str == 'additive') return BLEND_MODES.ADD;\n        if (str == 'multiply') return BLEND_MODES.MULTIPLY;\n        if (str == 'screen') return BLEND_MODES.SCREEN;\n        throw new Error(`Unknown blend mode: ${str}`);\n    }\n}\n\nclass LinkedMesh {\n    parent: string;\n    skin: string;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritTimeline: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string, slotIndex: number, parent: string, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritTimeline = inheritDeform;\n    }\n}\n\nfunction readTimeline1(keys: any[], timeline: CurveTimeline1, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value = getValue(keyMap, 'value', defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const value2 = getValue(nextMap, 'value', defaultValue) * scale;\n\n        if (keyMap.curve) bezier = readCurve(keyMap.curve, timeline, bezier, frame, 0, time, time2, value, value2, scale);\n        time = time2;\n        value = value2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readTimeline2(keys: any[], timeline: CurveTimeline2, name1: string, name2: string, defaultValue: number, scale: number) {\n    let keyMap = keys[0];\n    let time = getValue(keyMap, 'time', 0);\n    let value1 = getValue(keyMap, name1, defaultValue) * scale;\n    let value2 = getValue(keyMap, name2, defaultValue) * scale;\n    let bezier = 0;\n\n    for (let frame = 0; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        const nextMap = keys[frame + 1];\n\n        if (!nextMap) {\n            timeline.shrink(bezier);\n\n            return timeline;\n        }\n        const time2 = getValue(nextMap, 'time', 0);\n        const nvalue1 = getValue(nextMap, name1, defaultValue) * scale;\n        const nvalue2 = getValue(nextMap, name2, defaultValue) * scale;\n        const curve = keyMap.curve;\n\n        if (curve) {\n            bezier = readCurve(curve, timeline, bezier, frame, 0, time, time2, value1, nvalue1, scale);\n            bezier = readCurve(curve, timeline, bezier, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n        keyMap = nextMap;\n    }\n}\n\nfunction readCurve(curve: any, timeline: CurveTimeline, bezier: number, frame: number, value: number, time1: number, time2: number, value1: number, value2: number, scale: number) {\n    if (curve == 'stepped') {\n        timeline.setStepped(frame);\n\n        return bezier;\n    }\n    const i = value << 2;\n    const cx1 = curve[i];\n    const cy1 = curve[i + 1] * scale;\n    const cx2 = curve[i + 2];\n    const cy2 = curve[i + 3] * scale;\n\n    timeline.setBezier(bezier, frame, value, time1, value1, cx1, cy1, cx2, cy2, time2, value2);\n\n    return bezier + 1;\n}\n\nfunction getValue(map: any, property: string, defaultValue: any) {\n    return map[property] !== undefined ? map[property] : defaultValue;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}