{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport './attachments/Attachment.mjs';\nimport { Color, Utils, MathUtils, settings, Vector2 } from '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport { PathAttachment } from './attachments/PathAttachment.mjs';\nimport { RegionAttachment } from './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\nimport { Bone } from './Bone.mjs';\nimport { Slot } from './Slot.mjs';\nimport { IkConstraint } from './IkConstraint.mjs';\nimport { TransformConstraint } from './TransformConstraint.mjs';\nimport { PathConstraint } from './PathConstraint.mjs';\nconst _Skeleton = class {\n  constructor(data) {\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    this._updateCache = new Array();\n    /** The skeleton's current skin. May be null. */\n    this.skin = null;\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    this.scaleX = 1;\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    this.scaleY = 1;\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\n    this.x = 0;\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    this.y = 0;\n    if (!data) throw new Error(\"data cannot be null.\");\n    this.data = data;\n    this.bones = new Array();\n    for (let i = 0; i < data.bones.length; i++) {\n      const boneData = data.bones[i];\n      let bone;\n      if (!boneData.parent) bone = new Bone(boneData, this, null);else {\n        const parent = this.bones[boneData.parent.index];\n        bone = new Bone(boneData, this, parent);\n        parent.children.push(bone);\n      }\n      this.bones.push(bone);\n    }\n    this.slots = new Array();\n    this.drawOrder = new Array();\n    for (let i = 0; i < data.slots.length; i++) {\n      const slotData = data.slots[i];\n      const bone = this.bones[slotData.boneData.index];\n      const slot = new Slot(slotData, bone);\n      this.slots.push(slot);\n      this.drawOrder.push(slot);\n    }\n    this.ikConstraints = new Array();\n    for (let i = 0; i < data.ikConstraints.length; i++) {\n      const ikConstraintData = data.ikConstraints[i];\n      this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n    }\n    this.transformConstraints = new Array();\n    for (let i = 0; i < data.transformConstraints.length; i++) {\n      const transformConstraintData = data.transformConstraints[i];\n      this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n    }\n    this.pathConstraints = new Array();\n    for (let i = 0; i < data.pathConstraints.length; i++) {\n      const pathConstraintData = data.pathConstraints[i];\n      this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n    }\n    this.color = new Color(1, 1, 1, 1);\n    this.updateCache();\n  }\n  /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n   * constraints, or weighted path attachments are added or removed. */\n  updateCache() {\n    const updateCache = this._updateCache;\n    updateCache.length = 0;\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      bone.sorted = bone.data.skinRequired;\n      bone.active = !bone.sorted;\n    }\n    if (this.skin) {\n      const skinBones = this.skin.bones;\n      for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n        let bone = this.bones[skinBones[i].index];\n        do {\n          bone.sorted = false;\n          bone.active = true;\n          bone = bone.parent;\n        } while (bone);\n      }\n    }\n    const ikConstraints = this.ikConstraints;\n    const transformConstraints = this.transformConstraints;\n    const pathConstraints = this.pathConstraints;\n    const ikCount = ikConstraints.length;\n    const transformCount = transformConstraints.length;\n    const pathCount = pathConstraints.length;\n    const constraintCount = ikCount + transformCount + pathCount;\n    outer: for (let i = 0; i < constraintCount; i++) {\n      for (let ii = 0; ii < ikCount; ii++) {\n        const constraint = ikConstraints[ii];\n        if (constraint.data.order == i) {\n          this.sortIkConstraint(constraint);\n          continue outer;\n        }\n      }\n      for (let ii = 0; ii < transformCount; ii++) {\n        const constraint = transformConstraints[ii];\n        if (constraint.data.order == i) {\n          this.sortTransformConstraint(constraint);\n          continue outer;\n        }\n      }\n      for (let ii = 0; ii < pathCount; ii++) {\n        const constraint = pathConstraints[ii];\n        if (constraint.data.order == i) {\n          this.sortPathConstraint(constraint);\n          continue outer;\n        }\n      }\n    }\n    for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n  }\n  sortIkConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    const target = constraint.target;\n    this.sortBone(target);\n    const constrained = constraint.bones;\n    const parent = constrained[0];\n    this.sortBone(parent);\n    if (constrained.length == 1) {\n      this._updateCache.push(constraint);\n      this.sortReset(parent.children);\n    } else {\n      const child = constrained[constrained.length - 1];\n      this.sortBone(child);\n      this._updateCache.push(constraint);\n      this.sortReset(parent.children);\n      child.sorted = true;\n    }\n  }\n  sortPathConstraint(constraint) {\n    constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    const slot = constraint.target;\n    const slotIndex = slot.data.index;\n    const slotBone = slot.bone;\n    if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n    if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n    for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n    const attachment = slot.getAttachment();\n    if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n  }\n  sortTransformConstraint(constraint) {\n    constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || this.skin && Utils.contains(this.skin.constraints, constraint.data, true));\n    if (!constraint.active) return;\n    this.sortBone(constraint.target);\n    const constrained = constraint.bones;\n    const boneCount = constrained.length;\n    if (constraint.data.local) {\n      for (let i = 0; i < boneCount; i++) {\n        const child = constrained[i];\n        this.sortBone(child.parent);\n        this.sortBone(child);\n      }\n    } else {\n      for (let i = 0; i < boneCount; i++) {\n        this.sortBone(constrained[i]);\n      }\n    }\n    this._updateCache.push(constraint);\n    for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n    for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n  }\n  sortPathConstraintAttachment(skin, slotIndex, slotBone) {\n    const attachments = skin.attachments[slotIndex];\n    if (!attachments) return;\n    for (const key in attachments) {\n      this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n    }\n  }\n  sortPathConstraintAttachmentWith(attachment, slotBone) {\n    if (!(attachment instanceof PathAttachment)) return;\n    const pathBones = attachment.bones;\n    if (!pathBones) this.sortBone(slotBone);else {\n      const bones = this.bones;\n      for (let i = 0, n = pathBones.length; i < n;) {\n        let nn = pathBones[i++];\n        nn += i;\n        while (i < nn) this.sortBone(bones[pathBones[i++]]);\n      }\n    }\n  }\n  sortBone(bone) {\n    if (!bone) return;\n    if (bone.sorted) return;\n    const parent = bone.parent;\n    if (parent) this.sortBone(parent);\n    bone.sorted = true;\n    this._updateCache.push(bone);\n  }\n  sortReset(bones) {\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (!bone.active) continue;\n      if (bone.sorted) this.sortReset(bone.children);\n      bone.sorted = false;\n    }\n  }\n  /** Updates the world transform for each bone and applies all constraints.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide. */\n  updateWorldTransform() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      bone.ax = bone.x;\n      bone.ay = bone.y;\n      bone.arotation = bone.rotation;\n      bone.ascaleX = bone.scaleX;\n      bone.ascaleY = bone.scaleY;\n      bone.ashearX = bone.shearX;\n      bone.ashearY = bone.shearY;\n    }\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n  }\n  updateWorldTransformWith(parent) {\n    const rootBone = this.getRootBone();\n    const pa = parent.matrix.a;\n    const pb = parent.matrix.c;\n    const pc = parent.matrix.b;\n    const pd = parent.matrix.d;\n    rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n    rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n    const rotationY = rootBone.rotation + 90 + rootBone.shearY;\n    const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n    const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n    const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n    const sx = this.scaleX;\n    const sy = settings.yDown ? -this.scaleY : this.scaleY;\n    rootBone.matrix.a = (pa * la + pb * lc) * sx;\n    rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n    rootBone.matrix.b = (pc * la + pd * lc) * sy;\n    rootBone.matrix.d = (pc * lb + pd * ld) * sy;\n    const updateCache = this._updateCache;\n    for (let i = 0, n = updateCache.length; i < n; i++) {\n      const updatable = updateCache[i];\n      if (updatable != rootBone) updatable.update();\n    }\n  }\n  /** Sets the bones, constraints, and slots to their setup pose values. */\n  setToSetupPose() {\n    this.setBonesToSetupPose();\n    this.setSlotsToSetupPose();\n  }\n  /** Sets the bones and constraints to their setup pose values. */\n  setBonesToSetupPose() {\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const constraint = ikConstraints[i];\n      constraint.mix = constraint.data.mix;\n      constraint.softness = constraint.data.softness;\n      constraint.bendDirection = constraint.data.bendDirection;\n      constraint.compress = constraint.data.compress;\n      constraint.stretch = constraint.data.stretch;\n    }\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      const data = constraint.data;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n      constraint.mixScaleX = data.mixScaleX;\n      constraint.mixScaleY = data.mixScaleY;\n      constraint.mixShearY = data.mixShearY;\n    }\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      const data = constraint.data;\n      constraint.position = data.position;\n      constraint.spacing = data.spacing;\n      constraint.mixRotate = data.mixRotate;\n      constraint.mixX = data.mixX;\n      constraint.mixY = data.mixY;\n    }\n  }\n  /** Sets the slots and draw order to their setup pose values. */\n  setSlotsToSetupPose() {\n    const slots = this.slots;\n    Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n    for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n  }\n  /** @returns May return null. */\n  getRootBone() {\n    if (this.bones.length == 0) return null;\n    return this.bones[0];\n  }\n  /** @returns May be null. */\n  findBone(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) {\n      const bone = bones[i];\n      if (bone.data.name == boneName) return bone;\n    }\n    return null;\n  }\n  /** @returns -1 if the bone was not found. */\n  findBoneIndex(boneName) {\n    if (!boneName) throw new Error(\"boneName cannot be null.\");\n    const bones = this.bones;\n    for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n    return -1;\n  }\n  /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n   * repeatedly.\n   * @returns May be null. */\n  findSlot(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName) return slot;\n    }\n    return null;\n  }\n  /** @returns -1 if the bone was not found. */\n  findSlotIndex(slotName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n    return -1;\n  }\n  /** Sets a skin by name.\n   *\n   * See {@link #setSkin()}. */\n  setSkinByName(skinName) {\n    const skin = this.data.findSkin(skinName);\n    if (!skin) throw new Error(`Skin not found: ${skinName}`);\n    this.setSkin(skin);\n  }\n  /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n   * skin is changed, {@link #updateCache()} is called.\n   *\n   * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n   * old skin, each slot's setup mode attachment is attached from the new skin.\n   *\n   * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n   * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n   * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n   * @param newSkin May be null. */\n  setSkin(newSkin) {\n    if (newSkin == this.skin) return;\n    if (newSkin) {\n      if (this.skin) newSkin.attachAll(this, this.skin);else {\n        const slots = this.slots;\n        for (let i = 0, n = slots.length; i < n; i++) {\n          const slot = slots[i];\n          const name = slot.data.attachmentName;\n          if (name) {\n            const attachment = newSkin.getAttachment(i, name);\n            if (attachment) slot.setAttachment(attachment);\n          }\n        }\n      }\n    }\n    this.skin = newSkin;\n    this.updateCache();\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n   * name.\n   *\n   * See {@link #getAttachment()}.\n   * @returns May be null. */\n  getAttachmentByName(slotName, attachmentName) {\n    const slot = this.data.findSlot(slotName);\n    if (!slot) throw new Error(`Can't find slot with name ${slotName}`);\n    return this.getAttachment(slot.index, attachmentName);\n  }\n  /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n   * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n   *\n   * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n   * @returns May be null. */\n  getAttachment(slotIndex, attachmentName) {\n    if (!attachmentName) throw new Error(\"attachmentName cannot be null.\");\n    if (this.skin) {\n      const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n      if (attachment) return attachment;\n    }\n    if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n    return null;\n  }\n  /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n   * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n   * @param attachmentName May be null to clear the slot's attachment. */\n  setAttachment(slotName, attachmentName) {\n    if (!slotName) throw new Error(\"slotName cannot be null.\");\n    const slots = this.slots;\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.data.name == slotName) {\n        let attachment = null;\n        if (attachmentName) {\n          attachment = this.getAttachment(i, attachmentName);\n          if (!attachment) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n        }\n        slot.setAttachment(attachment);\n        return;\n      }\n    }\n    throw new Error(`Slot not found: ${slotName}`);\n  }\n  /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n  findIkConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    const ikConstraints = this.ikConstraints;\n    for (let i = 0, n = ikConstraints.length; i < n; i++) {\n      const ikConstraint = ikConstraints[i];\n      if (ikConstraint.data.name == constraintName) return ikConstraint;\n    }\n    return null;\n  }\n  /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n   * this method than to call it repeatedly.\n   * @return May be null. */\n  findTransformConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    const transformConstraints = this.transformConstraints;\n    for (let i = 0, n = transformConstraints.length; i < n; i++) {\n      const constraint = transformConstraints[i];\n      if (constraint.data.name == constraintName) return constraint;\n    }\n    return null;\n  }\n  /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n   * than to call it repeatedly.\n   * @return May be null. */\n  findPathConstraint(constraintName) {\n    if (!constraintName) throw new Error(\"constraintName cannot be null.\");\n    const pathConstraints = this.pathConstraints;\n    for (let i = 0, n = pathConstraints.length; i < n; i++) {\n      const constraint = pathConstraints[i];\n      if (constraint.data.name == constraintName) return constraint;\n    }\n    return null;\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n   * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n  getBoundsRect() {\n    const offset = new Vector2();\n    const size = new Vector2();\n    this.getBounds(offset, size);\n    return {\n      x: offset.x,\n      y: offset.y,\n      width: size.x,\n      height: size.y\n    };\n  }\n  /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n   * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n   * @param size An output value, the width and height of the AABB.\n   * @param temp Working memory to temporarily store attachments' computed world vertices. */\n  getBounds(offset, size, temp = new Array(2)) {\n    if (!offset) throw new Error(\"offset cannot be null.\");\n    if (!size) throw new Error(\"size cannot be null.\");\n    const drawOrder = this.drawOrder;\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = drawOrder[i];\n      if (!slot.bone.active) continue;\n      let verticesLength = 0;\n      let vertices = null;\n      const attachment = slot.getAttachment();\n      if (attachment instanceof RegionAttachment) {\n        verticesLength = 8;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        attachment.computeWorldVertices(slot, vertices, 0, 2);\n      } else if (attachment instanceof MeshAttachment) {\n        const mesh = attachment;\n        verticesLength = mesh.worldVerticesLength;\n        vertices = Utils.setArraySize(temp, verticesLength, 0);\n        mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n      }\n      if (vertices) {\n        for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n          const x = vertices[ii];\n          const y = vertices[ii + 1];\n          minX = Math.min(minX, x);\n          minY = Math.min(minY, y);\n          maxX = Math.max(maxX, x);\n          maxY = Math.max(maxY, y);\n        }\n      }\n    }\n    offset.set(minX, minY);\n    size.set(maxX - minX, maxY - minY);\n  }\n  get flipX() {\n    return this.scaleX == -1;\n  }\n  set flipX(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleX = value ? 1 : -1;\n  }\n  get flipY() {\n    return this.scaleY == -1;\n  }\n  set flipY(value) {\n    if (!_Skeleton.deprecatedWarning1) {\n      _Skeleton.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY\");\n    }\n    this.scaleY = value ? 1 : -1;\n  }\n};\nlet Skeleton = _Skeleton;\nSkeleton.deprecatedWarning1 = false;\nexport { Skeleton };","map":{"version":3,"names":["_Skeleton","constructor","data","_updateCache","Array","skin","scaleX","scaleY","x","y","Error","bones","i","length","boneData","bone","parent","Bone","index","children","push","slots","drawOrder","slotData","slot","Slot","ikConstraints","ikConstraintData","IkConstraint","transformConstraints","transformConstraintData","TransformConstraint","pathConstraints","pathConstraintData","PathConstraint","color","Color","updateCache","n","sorted","skinRequired","active","skinBones","ikCount","transformCount","pathCount","constraintCount","outer","ii","constraint","order","sortIkConstraint","sortTransformConstraint","sortPathConstraint","sortBone","target","isActive","Utils","contains","constraints","constrained","sortReset","child","slotIndex","slotBone","sortPathConstraintAttachment","defaultSkin","skins","attachment","getAttachment","PathAttachment","sortPathConstraintAttachmentWith","boneCount","local","attachments","key","pathBones","nn","updateWorldTransform","ax","ay","arotation","rotation","ascaleX","ascaleY","ashearX","shearX","ashearY","shearY","update","updateWorldTransformWith","rootBone","getRootBone","pa","matrix","a","pb","c","pc","b","pd","d","tx","worldX","ty","worldY","rotationY","la","MathUtils","cosDeg","lb","lc","sinDeg","ld","sx","sy","settings","yDown","updatable","setToSetupPose","setBonesToSetupPose","setSlotsToSetupPose","mix","softness","bendDirection","compress","stretch","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","position","spacing","arrayCopy","findBone","boneName","name","findBoneIndex","findSlot","slotName","findSlotIndex","setSkinByName","skinName","findSkin","setSkin","newSkin","attachAll","attachmentName","setAttachment","getAttachmentByName","findIkConstraint","constraintName","ikConstraint","findTransformConstraint","findPathConstraint","getBoundsRect","offset","Vector2","size","getBounds","width","height","temp","minX","Number","POSITIVE_INFINITY","minY","maxX","NEGATIVE_INFINITY","maxY","verticesLength","vertices","RegionAttachment","setArraySize","computeWorldVertices","MeshAttachment","mesh","worldVerticesLength","Math","min","max","set","flipX","value","deprecatedWarning1","console","warn","flipY","Skeleton"],"sources":["../../src/core/Skeleton.ts"],"sourcesContent":["import { Attachment, RegionAttachment, MeshAttachment, PathAttachment } from './attachments';\nimport { Bone } from './Bone';\nimport { Slot } from './Slot';\nimport type { Updatable } from './Updatable';\nimport type { SkeletonData } from './SkeletonData';\nimport { IkConstraint } from './IkConstraint';\nimport { TransformConstraint } from './TransformConstraint';\nimport { PathConstraint } from './PathConstraint';\nimport type { Skin } from './Skin';\nimport { Color, MathUtils, NumberArrayLike, settings, Utils, Vector2, ISkeleton } from '@pixi-spine/base';\n\n/** Stores the current pose for a skeleton.\n *\n * See [Instance objects](http://esotericsoftware.com/spine-runtime-architecture#Instance-objects) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skeleton implements ISkeleton<SkeletonData, Bone, Slot, Skin> {\n    /** The skeleton's setup pose data. */\n    data: SkeletonData;\n\n    /** The skeleton's bones, sorted parent first. The root bone is always the first bone. */\n    bones: Array<Bone>;\n\n    /** The skeleton's slots. */\n    slots: Array<Slot>;\n\n    /** The skeleton's slots in the order they should be drawn. The returned array may be modified to change the draw order. */\n    drawOrder: Array<Slot>;\n\n    /** The skeleton's IK constraints. */\n    ikConstraints: Array<IkConstraint>;\n\n    /** The skeleton's transform constraints. */\n    transformConstraints: Array<TransformConstraint>;\n\n    /** The skeleton's path constraints. */\n    pathConstraints: Array<PathConstraint>;\n\n    /** The list of bones and constraints, sorted in the order they should be updated, as computed by {@link #updateCache()}. */\n    _updateCache = new Array<Updatable>();\n\n    /** The skeleton's current skin. May be null. */\n    skin: Skin | null = null;\n\n    /** The color to tint all the skeleton's attachments. */\n    color: Color;\n\n    /** Scales the entire skeleton on the X axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleX = 1;\n\n    /** Scales the entire skeleton on the Y axis. This affects all bones, even if the bone's transform mode disallows scale\n     * inheritance. */\n    scaleY = 1;\n\n    /** Sets the skeleton X position, which is added to the root bone worldX position. */\n    x = 0;\n\n    /** Sets the skeleton Y position, which is added to the root bone worldY position. */\n    y = 0;\n\n    constructor(data: SkeletonData) {\n        if (!data) throw new Error('data cannot be null.');\n        this.data = data;\n\n        this.bones = new Array<Bone>();\n        for (let i = 0; i < data.bones.length; i++) {\n            const boneData = data.bones[i];\n            let bone: Bone;\n\n            if (!boneData.parent) bone = new Bone(boneData, this, null);\n            else {\n                const parent = this.bones[boneData.parent.index];\n\n                bone = new Bone(boneData, this, parent);\n                parent.children.push(bone);\n            }\n            this.bones.push(bone);\n        }\n\n        this.slots = new Array<Slot>();\n        this.drawOrder = new Array<Slot>();\n        for (let i = 0; i < data.slots.length; i++) {\n            const slotData = data.slots[i];\n            const bone = this.bones[slotData.boneData.index];\n            const slot = new Slot(slotData, bone);\n\n            this.slots.push(slot);\n            this.drawOrder.push(slot);\n        }\n\n        this.ikConstraints = new Array<IkConstraint>();\n        for (let i = 0; i < data.ikConstraints.length; i++) {\n            const ikConstraintData = data.ikConstraints[i];\n\n            this.ikConstraints.push(new IkConstraint(ikConstraintData, this));\n        }\n\n        this.transformConstraints = new Array<TransformConstraint>();\n        for (let i = 0; i < data.transformConstraints.length; i++) {\n            const transformConstraintData = data.transformConstraints[i];\n\n            this.transformConstraints.push(new TransformConstraint(transformConstraintData, this));\n        }\n\n        this.pathConstraints = new Array<PathConstraint>();\n        for (let i = 0; i < data.pathConstraints.length; i++) {\n            const pathConstraintData = data.pathConstraints[i];\n\n            this.pathConstraints.push(new PathConstraint(pathConstraintData, this));\n        }\n\n        this.color = new Color(1, 1, 1, 1);\n        this.updateCache();\n    }\n\n    /** Caches information about bones and constraints. Must be called if the {@link #getSkin()} is modified or if bones,\n     * constraints, or weighted path attachments are added or removed. */\n    updateCache() {\n        const updateCache = this._updateCache;\n\n        updateCache.length = 0;\n\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.sorted = bone.data.skinRequired;\n            bone.active = !bone.sorted;\n        }\n\n        if (this.skin) {\n            const skinBones = this.skin.bones;\n\n            for (let i = 0, n = this.skin.bones.length; i < n; i++) {\n                let bone: Bone | null = this.bones[skinBones[i].index];\n\n                do {\n                    bone.sorted = false;\n                    bone.active = true;\n                    bone = bone.parent;\n                } while (bone);\n            }\n        }\n\n        // IK first, lowest hierarchy depth first.\n        const ikConstraints = this.ikConstraints;\n        const transformConstraints = this.transformConstraints;\n        const pathConstraints = this.pathConstraints;\n        const ikCount = ikConstraints.length;\n        const transformCount = transformConstraints.length;\n        const pathCount = pathConstraints.length;\n        const constraintCount = ikCount + transformCount + pathCount;\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < constraintCount; i++) {\n            for (let ii = 0; ii < ikCount; ii++) {\n                const constraint = ikConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortIkConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < transformCount; ii++) {\n                const constraint = transformConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortTransformConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n            for (let ii = 0; ii < pathCount; ii++) {\n                const constraint = pathConstraints[ii];\n\n                if (constraint.data.order == i) {\n                    this.sortPathConstraint(constraint);\n                    // eslint-disable-next-line no-labels\n                    continue outer;\n                }\n            }\n        }\n\n        for (let i = 0, n = bones.length; i < n; i++) this.sortBone(bones[i]);\n    }\n\n    sortIkConstraint(constraint: IkConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const target = constraint.target;\n\n        this.sortBone(target);\n\n        const constrained = constraint.bones;\n        const parent = constrained[0];\n\n        this.sortBone(parent);\n\n        if (constrained.length == 1) {\n            this._updateCache.push(constraint);\n            this.sortReset(parent.children);\n        } else {\n            const child = constrained[constrained.length - 1];\n\n            this.sortBone(child);\n\n            this._updateCache.push(constraint);\n\n            this.sortReset(parent.children);\n            child.sorted = true;\n        }\n    }\n\n    sortPathConstraint(constraint: PathConstraint) {\n        constraint.active = constraint.target.bone.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        const slot = constraint.target;\n        const slotIndex = slot.data.index;\n        const slotBone = slot.bone;\n\n        if (this.skin) this.sortPathConstraintAttachment(this.skin, slotIndex, slotBone);\n        if (this.data.defaultSkin && this.data.defaultSkin != this.skin) this.sortPathConstraintAttachment(this.data.defaultSkin, slotIndex, slotBone);\n        for (let i = 0, n = this.data.skins.length; i < n; i++) this.sortPathConstraintAttachment(this.data.skins[i], slotIndex, slotBone);\n\n        const attachment = slot.getAttachment();\n\n        if (attachment instanceof PathAttachment) this.sortPathConstraintAttachmentWith(attachment, slotBone);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        for (let i = 0; i < boneCount; i++) this.sortBone(constrained[i]);\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortTransformConstraint(constraint: TransformConstraint) {\n        constraint.active = constraint.target.isActive() && (!constraint.data.skinRequired || (this.skin && Utils.contains(this.skin.constraints, constraint.data, true)));\n        if (!constraint.active) return;\n\n        this.sortBone(constraint.target);\n\n        const constrained = constraint.bones;\n        const boneCount = constrained.length;\n\n        if (constraint.data.local) {\n            for (let i = 0; i < boneCount; i++) {\n                const child = constrained[i];\n\n                this.sortBone(child.parent);\n                this.sortBone(child);\n            }\n        } else {\n            for (let i = 0; i < boneCount; i++) {\n                this.sortBone(constrained[i]);\n            }\n        }\n\n        this._updateCache.push(constraint);\n\n        for (let i = 0; i < boneCount; i++) this.sortReset(constrained[i].children);\n        for (let i = 0; i < boneCount; i++) constrained[i].sorted = true;\n    }\n\n    sortPathConstraintAttachment(skin: Skin, slotIndex: number, slotBone: Bone) {\n        const attachments = skin.attachments[slotIndex];\n\n        if (!attachments) return;\n        for (const key in attachments) {\n            this.sortPathConstraintAttachmentWith(attachments[key], slotBone);\n        }\n    }\n\n    sortPathConstraintAttachmentWith(attachment: Attachment, slotBone: Bone) {\n        if (!(attachment instanceof PathAttachment)) return;\n        const pathBones = (<PathAttachment>attachment).bones;\n\n        if (!pathBones) this.sortBone(slotBone);\n        else {\n            const bones = this.bones;\n\n            for (let i = 0, n = pathBones.length; i < n; ) {\n                let nn = pathBones[i++];\n\n                nn += i;\n                while (i < nn) this.sortBone(bones[pathBones[i++]]);\n            }\n        }\n    }\n\n    sortBone(bone: Bone) {\n        if (!bone) return;\n        if (bone.sorted) return;\n        const parent = bone.parent;\n\n        if (parent) this.sortBone(parent);\n        bone.sorted = true;\n        this._updateCache.push(bone);\n    }\n\n    sortReset(bones: Array<Bone>) {\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (!bone.active) continue;\n            if (bone.sorted) this.sortReset(bone.children);\n            bone.sorted = false;\n        }\n    }\n\n    /** Updates the world transform for each bone and applies all constraints.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide. */\n    updateWorldTransform() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            bone.ax = bone.x;\n            bone.ay = bone.y;\n            bone.arotation = bone.rotation;\n            bone.ascaleX = bone.scaleX;\n            bone.ascaleY = bone.scaleY;\n            bone.ashearX = bone.shearX;\n            bone.ashearY = bone.shearY;\n        }\n\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) updateCache[i].update();\n    }\n\n    updateWorldTransformWith(parent: Bone) {\n        // Apply the parent bone transform to the root bone. The root bone always inherits scale, rotation and reflection.\n        const rootBone = this.getRootBone();\n        const pa = parent.matrix.a;\n        const pb = parent.matrix.c;\n        const pc = parent.matrix.b;\n        const pd = parent.matrix.d;\n\n        rootBone.matrix.tx = pa * this.x + pb * this.y + parent.worldX;\n        rootBone.matrix.ty = pc * this.x + pd * this.y + parent.worldY;\n\n        const rotationY = rootBone.rotation + 90 + rootBone.shearY;\n        const la = MathUtils.cosDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        const lb = MathUtils.cosDeg(rotationY) * rootBone.scaleY;\n        const lc = MathUtils.sinDeg(rootBone.rotation + rootBone.shearX) * rootBone.scaleX;\n        const ld = MathUtils.sinDeg(rotationY) * rootBone.scaleY;\n\n        const sx = this.scaleX;\n        const sy = settings.yDown ? -this.scaleY : this.scaleY;\n\n        rootBone.matrix.a = (pa * la + pb * lc) * sx;\n        rootBone.matrix.c = (pa * lb + pb * ld) * sx;\n        rootBone.matrix.b = (pc * la + pd * lc) * sy;\n        rootBone.matrix.d = (pc * lb + pd * ld) * sy;\n\n        // Update everything except root bone.\n        const updateCache = this._updateCache;\n\n        for (let i = 0, n = updateCache.length; i < n; i++) {\n            const updatable = updateCache[i];\n\n            if (updatable != rootBone) updatable.update();\n        }\n    }\n\n    /** Sets the bones, constraints, and slots to their setup pose values. */\n    setToSetupPose() {\n        this.setBonesToSetupPose();\n        this.setSlotsToSetupPose();\n    }\n\n    /** Sets the bones and constraints to their setup pose values. */\n    setBonesToSetupPose() {\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) bones[i].setToSetupPose();\n\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const constraint = ikConstraints[i];\n\n            constraint.mix = constraint.data.mix;\n            constraint.softness = constraint.data.softness;\n            constraint.bendDirection = constraint.data.bendDirection;\n            constraint.compress = constraint.data.compress;\n            constraint.stretch = constraint.data.stretch;\n        }\n\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n            const data = constraint.data;\n\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n            constraint.mixScaleX = data.mixScaleX;\n            constraint.mixScaleY = data.mixScaleY;\n            constraint.mixShearY = data.mixShearY;\n        }\n\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n            const data = constraint.data;\n\n            constraint.position = data.position;\n            constraint.spacing = data.spacing;\n            constraint.mixRotate = data.mixRotate;\n            constraint.mixX = data.mixX;\n            constraint.mixY = data.mixY;\n        }\n    }\n\n    /** Sets the slots and draw order to their setup pose values. */\n    setSlotsToSetupPose() {\n        const slots = this.slots;\n\n        Utils.arrayCopy(slots, 0, this.drawOrder, 0, slots.length);\n        for (let i = 0, n = slots.length; i < n; i++) slots[i].setToSetupPose();\n    }\n\n    /** @returns May return null. */\n    getRootBone() {\n        if (this.bones.length == 0) return null;\n\n        return this.bones[0];\n    }\n\n    /** @returns May be null. */\n    findBone(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) {\n            const bone = bones[i];\n\n            if (bone.data.name == boneName) return bone;\n        }\n\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findBoneIndex(boneName: string) {\n        if (!boneName) throw new Error('boneName cannot be null.');\n        const bones = this.bones;\n\n        for (let i = 0, n = bones.length; i < n; i++) if (bones[i].data.name == boneName) return i;\n\n        return -1;\n    }\n\n    /** Finds a slot by comparing each slot's name. It is more efficient to cache the results of this method than to call it\n     * repeatedly.\n     * @returns May be null. */\n    findSlot(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) return slot;\n        }\n\n        return null;\n    }\n\n    /** @returns -1 if the bone was not found. */\n    findSlotIndex(slotName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) if (slots[i].data.name == slotName) return i;\n\n        return -1;\n    }\n\n    /** Sets a skin by name.\n     *\n     * See {@link #setSkin()}. */\n    setSkinByName(skinName: string) {\n        const skin = this.data.findSkin(skinName);\n\n        if (!skin) throw new Error(`Skin not found: ${skinName}`);\n        this.setSkin(skin);\n    }\n\n    /** Sets the skin used to look up attachments before looking in the {@link SkeletonData#defaultSkin default skin}. If the\n     * skin is changed, {@link #updateCache()} is called.\n     *\n     * Attachments from the new skin are attached if the corresponding attachment from the old skin was attached. If there was no\n     * old skin, each slot's setup mode attachment is attached from the new skin.\n     *\n     * After changing the skin, the visible attachments can be reset to those attached in the setup pose by calling\n     * {@link #setSlotsToSetupPose()}. Also, often {@link AnimationState#apply()} is called before the next time the\n     * skeleton is rendered to allow any attachment keys in the current animation(s) to hide or show attachments from the new skin.\n     * @param newSkin May be null. */\n    setSkin(newSkin: Skin) {\n        if (newSkin == this.skin) return;\n        if (newSkin) {\n            if (this.skin) newSkin.attachAll(this, this.skin);\n            else {\n                const slots = this.slots;\n\n                for (let i = 0, n = slots.length; i < n; i++) {\n                    const slot = slots[i];\n                    const name = slot.data.attachmentName;\n\n                    if (name) {\n                        const attachment = newSkin.getAttachment(i, name);\n\n                        if (attachment) slot.setAttachment(attachment);\n                    }\n                }\n            }\n        }\n        this.skin = newSkin;\n        this.updateCache();\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot name and attachment\n     * name.\n     *\n     * See {@link #getAttachment()}.\n     * @returns May be null. */\n    getAttachmentByName(slotName: string, attachmentName: string): Attachment | null {\n        const slot = this.data.findSlot(slotName);\n\n        if (!slot) throw new Error(`Can't find slot with name ${slotName}`);\n\n        return this.getAttachment(slot.index, attachmentName);\n    }\n\n    /** Finds an attachment by looking in the {@link #skin} and {@link SkeletonData#defaultSkin} using the slot index and\n     * attachment name. First the skin is checked and if the attachment was not found, the default skin is checked.\n     *\n     * See [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n     * @returns May be null. */\n    getAttachment(slotIndex: number, attachmentName: string): Attachment | null {\n        if (!attachmentName) throw new Error('attachmentName cannot be null.');\n        if (this.skin) {\n            const attachment = this.skin.getAttachment(slotIndex, attachmentName);\n\n            if (attachment) return attachment;\n        }\n        if (this.data.defaultSkin) return this.data.defaultSkin.getAttachment(slotIndex, attachmentName);\n\n        return null;\n    }\n\n    /** A convenience method to set an attachment by finding the slot with {@link #findSlot()}, finding the attachment with\n     * {@link #getAttachment()}, then setting the slot's {@link Slot#attachment}.\n     * @param attachmentName May be null to clear the slot's attachment. */\n    setAttachment(slotName: string, attachmentName: string) {\n        if (!slotName) throw new Error('slotName cannot be null.');\n        const slots = this.slots;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.data.name == slotName) {\n                let attachment: Attachment | null = null;\n\n                if (attachmentName) {\n                    attachment = this.getAttachment(i, attachmentName);\n                    if (!attachment) throw new Error(`Attachment not found: ${attachmentName}, for slot: ${slotName}`);\n                }\n                slot.setAttachment(attachment);\n\n                return;\n            }\n        }\n        throw new Error(`Slot not found: ${slotName}`);\n    }\n\n    /** Finds an IK constraint by comparing each IK constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findIkConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const ikConstraints = this.ikConstraints;\n\n        for (let i = 0, n = ikConstraints.length; i < n; i++) {\n            const ikConstraint = ikConstraints[i];\n\n            if (ikConstraint.data.name == constraintName) return ikConstraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a transform constraint by comparing each transform constraint's name. It is more efficient to cache the results of\n     * this method than to call it repeatedly.\n     * @return May be null. */\n    findTransformConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const transformConstraints = this.transformConstraints;\n\n        for (let i = 0, n = transformConstraints.length; i < n; i++) {\n            const constraint = transformConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Finds a path constraint by comparing each path constraint's name. It is more efficient to cache the results of this method\n     * than to call it repeatedly.\n     * @return May be null. */\n    findPathConstraint(constraintName: string) {\n        if (!constraintName) throw new Error('constraintName cannot be null.');\n        const pathConstraints = this.pathConstraints;\n\n        for (let i = 0, n = pathConstraints.length; i < n; i++) {\n            const constraint = pathConstraints[i];\n\n            if (constraint.data.name == constraintName) return constraint;\n        }\n\n        return null;\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose as `{ x: number, y: number, width: number, height: number }`.\n     * Note that this method will create temporary objects which can add to garbage collection pressure. Use `getBounds()` if garbage collection is a concern. */\n    getBoundsRect() {\n        const offset = new Vector2();\n        const size = new Vector2();\n\n        this.getBounds(offset, size);\n\n        return { x: offset.x, y: offset.y, width: size.x, height: size.y };\n    }\n\n    /** Returns the axis aligned bounding box (AABB) of the region and mesh attachments for the current pose.\n     * @param offset An output value, the distance from the skeleton origin to the bottom left corner of the AABB.\n     * @param size An output value, the width and height of the AABB.\n     * @param temp Working memory to temporarily store attachments' computed world vertices. */\n    getBounds(offset: Vector2, size: Vector2, temp: Array<number> = new Array<number>(2)) {\n        if (!offset) throw new Error('offset cannot be null.');\n        if (!size) throw new Error('size cannot be null.');\n        const drawOrder = this.drawOrder;\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = drawOrder[i];\n\n            if (!slot.bone.active) continue;\n            let verticesLength = 0;\n            let vertices: NumberArrayLike | null = null;\n            const attachment = slot.getAttachment();\n\n            if (attachment instanceof RegionAttachment) {\n                verticesLength = 8;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                (<RegionAttachment>attachment).computeWorldVertices(slot, vertices, 0, 2);\n            } else if (attachment instanceof MeshAttachment) {\n                const mesh = <MeshAttachment>attachment;\n\n                verticesLength = mesh.worldVerticesLength;\n                vertices = Utils.setArraySize(temp, verticesLength, 0);\n                mesh.computeWorldVertices(slot, 0, verticesLength, vertices, 0, 2);\n            }\n            if (vertices) {\n                for (let ii = 0, nn = vertices.length; ii < nn; ii += 2) {\n                    const x = vertices[ii];\n                    const y = vertices[ii + 1];\n\n                    minX = Math.min(minX, x);\n                    minY = Math.min(minY, y);\n                    maxX = Math.max(maxX, x);\n                    maxY = Math.max(maxY, y);\n                }\n            }\n        }\n        offset.set(minX, minY);\n        size.set(maxX - minX, maxY - minY);\n    }\n\n    get flipX(): boolean {\n        return this.scaleX == -1;\n    }\n\n    set flipX(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleX = value ? 1.0 : -1.0;\n    }\n\n    get flipY(): boolean {\n        return this.scaleY == -1;\n    }\n\n    set flipY(value: boolean) {\n        if (!Skeleton.deprecatedWarning1) {\n            Skeleton.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: `Skeleton.flipX/flipY` was deprecated, please use scaleX/scaleY');\n        }\n        this.scaleY = value ? 1.0 : -1.0;\n    }\n\n    private static deprecatedWarning1 = false;\n}\n"],"mappings":";;;;;;;;;;;;AAgBO,MAAMA,SAAA,GAAN,MAAoE;EA6CvEC,YAAYC,IAAoB;IAtBhC;IAAA,KAAAC,YAAA,GAAe,IAAIC,KAAiB;IAGpC;IAAoB,KAAAC,IAAA;IAOpB;AAAA;IAAS,KAAAC,MAAA;IAIT;AAAA;IAAS,KAAAC,MAAA;IAGT;IAAI,KAAAC,CAAA;IAGJ;IAAI,KAAAC,CAAA;IAGA,IAAI,CAACP,IAAA,EAAY,UAAIQ,KAAA,CAAM,sBAAsB;IACjD,KAAKR,IAAO,GAAAA,IAAA;IAEP,KAAAS,KAAA,GAAQ,IAAIP,KAAY;IAC7B,SAASQ,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIV,IAAK,CAAAS,KAAA,CAAME,MAAA,EAAQD,CAAK;MAClC,MAAAE,QAAA,GAAWZ,IAAK,CAAAS,KAAA,CAAMC,CAAC;MACzB,IAAAG,IAAA;MAEJ,IAAI,CAACD,QAAS,CAAAE,MAAA,EAAQD,IAAA,GAAO,IAAIE,IAAA,CAAKH,QAAU,QAAM,IAAI,OACrD;QACD,MAAME,MAAS,QAAKL,KAAM,CAAAG,QAAA,CAASE,MAAA,CAAOE,KAAK;QAE/CH,IAAA,GAAO,IAAIE,IAAA,CAAKH,QAAU,QAAME,MAAM;QAC/BA,MAAA,CAAAG,QAAA,CAASC,IAAA,CAAKL,IAAI;MAAA;MAExB,KAAAJ,KAAA,CAAMS,IAAA,CAAKL,IAAI;IAAA;IAGnB,KAAAM,KAAA,GAAQ,IAAIjB,KAAY;IACxB,KAAAkB,SAAA,GAAY,IAAIlB,KAAY;IACjC,SAASQ,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIV,IAAK,CAAAmB,KAAA,CAAMR,MAAA,EAAQD,CAAK;MAClC,MAAAW,QAAA,GAAWrB,IAAK,CAAAmB,KAAA,CAAMT,CAAC;MAC7B,MAAMG,IAAO,QAAKJ,KAAM,CAAAY,QAAA,CAAST,QAAA,CAASI,KAAK;MAC/C,MAAMM,IAAO,OAAIC,IAAK,CAAAF,QAAA,EAAUR,IAAI;MAE/B,KAAAM,KAAA,CAAMD,IAAA,CAAKI,IAAI;MACf,KAAAF,SAAA,CAAUF,IAAA,CAAKI,IAAI;IAAA;IAGvB,KAAAE,aAAA,GAAgB,IAAItB,KAAoB;IAC7C,SAASQ,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIV,IAAK,CAAAwB,aAAA,CAAcb,MAAA,EAAQD,CAAK;MAC1C,MAAAe,gBAAA,GAAmBzB,IAAK,CAAAwB,aAAA,CAAcd,CAAC;MAE7C,KAAKc,aAAA,CAAcN,IAAK,KAAIQ,YAAa,CAAAD,gBAAA,EAAkB,IAAI,CAAC;IAAA;IAG/D,KAAAE,oBAAA,GAAuB,IAAIzB,KAA2B;IAC3D,SAASQ,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIV,IAAK,CAAA2B,oBAAA,CAAqBhB,MAAA,EAAQD,CAAK;MACjD,MAAAkB,uBAAA,GAA0B5B,IAAK,CAAA2B,oBAAA,CAAqBjB,CAAC;MAE3D,KAAKiB,oBAAA,CAAqBT,IAAK,KAAIW,mBAAoB,CAAAD,uBAAA,EAAyB,IAAI,CAAC;IAAA;IAGpF,KAAAE,eAAA,GAAkB,IAAI5B,KAAsB;IACjD,SAASQ,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAIV,IAAK,CAAA8B,eAAA,CAAgBnB,MAAA,EAAQD,CAAK;MAC5C,MAAAqB,kBAAA,GAAqB/B,IAAK,CAAA8B,eAAA,CAAgBpB,CAAC;MAEjD,KAAKoB,eAAA,CAAgBZ,IAAK,KAAIc,cAAe,CAAAD,kBAAA,EAAoB,IAAI,CAAC;IAAA;IAG1E,KAAKE,KAAA,GAAQ,IAAIC,KAAA,CAAM,CAAG,KAAG,GAAG,CAAC;IACjC,KAAKC,WAAY;EAAA;EACrB;AAAA;EAIAA,WAAcA,CAAA;IACV,MAAMA,WAAA,GAAc,IAAK,CAAAlC,YAAA;IAEzBkC,WAAA,CAAYxB,MAAS;IAErB,MAAMF,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAA,CAAME,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACpC,MAAAG,IAAA,GAAOJ,KAAA,CAAMC,CAAC;MAEfG,IAAA,CAAAwB,MAAA,GAASxB,IAAA,CAAKb,IAAK,CAAAsC,YAAA;MACnBzB,IAAA,CAAA0B,MAAA,GAAS,CAAC1B,IAAK,CAAAwB,MAAA;IAAA;IAGxB,IAAI,KAAKlC,IAAM;MACL,MAAAqC,SAAA,GAAY,KAAKrC,IAAK,CAAAM,KAAA;MAEnB,SAAAC,CAAA,GAAI,GAAG0B,CAAI,QAAKjC,IAAA,CAAKM,KAAM,CAAAE,MAAA,EAAQD,CAAI,GAAA0B,CAAA,EAAG1B,CAAK;QACpD,IAAIG,IAAA,GAAoB,IAAK,CAAAJ,KAAA,CAAM+B,SAAU,CAAA9B,CAAC,EAAEM,KAAK;QAElD;UACCH,IAAA,CAAKwB,MAAS;UACdxB,IAAA,CAAK0B,MAAS;UACd1B,IAAA,GAAOA,IAAK,CAAAC,MAAA;QAAA,CACP,QAAAD,IAAA;MAAA;IACb;IAIJ,MAAMW,aAAA,GAAgB,IAAK,CAAAA,aAAA;IAC3B,MAAMG,oBAAA,GAAuB,IAAK,CAAAA,oBAAA;IAClC,MAAMG,eAAA,GAAkB,IAAK,CAAAA,eAAA;IAC7B,MAAMW,OAAA,GAAUjB,aAAc,CAAAb,MAAA;IAC9B,MAAM+B,cAAA,GAAiBf,oBAAqB,CAAAhB,MAAA;IAC5C,MAAMgC,SAAA,GAAYb,eAAgB,CAAAnB,MAAA;IAC5B,MAAAiC,eAAA,GAAkBH,OAAA,GAAUC,cAAiB,GAAAC,SAAA;IAGnDE,KAAA,EAAO,SAASnC,CAAI,MAAGA,CAAI,GAAAkC,eAAA,EAAiBlC,CAAK;MAC7C,SAASoC,EAAK,MAAGA,EAAK,GAAAL,OAAA,EAASK,EAAM;QAC3B,MAAAC,UAAA,GAAavB,aAAA,CAAcsB,EAAE;QAE/B,IAAAC,UAAA,CAAW/C,IAAK,CAAAgD,KAAA,IAAStC,CAAG;UAC5B,KAAKuC,gBAAA,CAAiBF,UAAU;UAEvB,SAAAF,KAAA;QAAA;MACb;MAEJ,SAASC,EAAK,MAAGA,EAAK,GAAAJ,cAAA,EAAgBI,EAAM;QAClC,MAAAC,UAAA,GAAapB,oBAAA,CAAqBmB,EAAE;QAEtC,IAAAC,UAAA,CAAW/C,IAAK,CAAAgD,KAAA,IAAStC,CAAG;UAC5B,KAAKwC,uBAAA,CAAwBH,UAAU;UAE9B,SAAAF,KAAA;QAAA;MACb;MAEJ,SAASC,EAAK,MAAGA,EAAK,GAAAH,SAAA,EAAWG,EAAM;QAC7B,MAAAC,UAAA,GAAajB,eAAA,CAAgBgB,EAAE;QAEjC,IAAAC,UAAA,CAAW/C,IAAK,CAAAgD,KAAA,IAAStC,CAAG;UAC5B,KAAKyC,kBAAA,CAAmBJ,UAAU;UAEzB,SAAAF,KAAA;QAAA;MACb;IACJ;IAGJ,SAASnC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAM,CAAAE,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAU,KAAA0C,QAAA,CAAS3C,KAAM,CAAAC,CAAC,CAAC;EAAA;EAGxEuC,iBAAiBF,UAA0B;IACvCA,UAAA,CAAWR,MAAA,GAASQ,UAAW,CAAAM,MAAA,CAAOC,QAAA,EAAe,MAACP,UAAA,CAAW/C,IAAK,CAAAsC,YAAA,IAAiB,IAAK,CAAAnC,IAAA,IAAQoD,KAAA,CAAMC,QAAS,MAAKrD,IAAA,CAAKsD,WAAa,EAAAV,UAAA,CAAW/C,IAAA,EAAM,IAAI;IAC/J,IAAI,CAAC+C,UAAW,CAAAR,MAAA,EAAQ;IAExB,MAAMc,MAAA,GAASN,UAAW,CAAAM,MAAA;IAE1B,KAAKD,QAAA,CAASC,MAAM;IAEpB,MAAMK,WAAA,GAAcX,UAAW,CAAAtC,KAAA;IACzB,MAAAK,MAAA,GAAS4C,WAAA,CAAY,CAAC;IAE5B,KAAKN,QAAA,CAAStC,MAAM;IAEhB,IAAA4C,WAAA,CAAY/C,MAAA,IAAU,CAAG;MACpB,KAAAV,YAAA,CAAaiB,IAAA,CAAK6B,UAAU;MAC5B,KAAAY,SAAA,CAAU7C,MAAA,CAAOG,QAAQ;IAAA,CAC3B;MACH,MAAM2C,KAAQ,GAAAF,WAAA,CAAYA,WAAY,CAAA/C,MAAA,GAAS,CAAC;MAEhD,KAAKyC,QAAA,CAASQ,KAAK;MAEd,KAAA3D,YAAA,CAAaiB,IAAA,CAAK6B,UAAU;MAE5B,KAAAY,SAAA,CAAU7C,MAAA,CAAOG,QAAQ;MAC9B2C,KAAA,CAAMvB,MAAS;IAAA;EACnB;EAGJc,mBAAmBJ,UAA4B;IAC3CA,UAAA,CAAWR,MAAA,GAASQ,UAAW,CAAAM,MAAA,CAAOxC,IAAA,CAAKyC,QAAS,OAAM,CAACP,UAAW,CAAA/C,IAAA,CAAKsC,YAAA,IAAiB,IAAK,CAAAnC,IAAA,IAAQoD,KAAA,CAAMC,QAAS,MAAKrD,IAAA,CAAKsD,WAAa,EAAAV,UAAA,CAAW/C,IAAA,EAAM,IAAI;IACpK,IAAI,CAAC+C,UAAW,CAAAR,MAAA,EAAQ;IAExB,MAAMjB,IAAA,GAAOyB,UAAW,CAAAM,MAAA;IAClB,MAAAQ,SAAA,GAAYvC,IAAA,CAAKtB,IAAK,CAAAgB,KAAA;IAC5B,MAAM8C,QAAA,GAAWxC,IAAK,CAAAT,IAAA;IAEtB,IAAI,IAAK,CAAAV,IAAA,EAAM,KAAK4D,4BAA6B,MAAK5D,IAAM,EAAA0D,SAAA,EAAWC,QAAQ;IAC/E,IAAI,KAAK9D,IAAK,CAAAgE,WAAA,IAAe,IAAK,CAAAhE,IAAA,CAAKgE,WAAA,IAAe,IAAK,CAAA7D,IAAA,EAAM,KAAK4D,4BAA6B,MAAK/D,IAAK,CAAAgE,WAAA,EAAaH,SAAA,EAAWC,QAAQ;IACpI,SAAApD,CAAA,GAAI,GAAG0B,CAAI,QAAKpC,IAAA,CAAKiE,KAAM,CAAAtD,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAK,KAAKqD,4BAAA,CAA6B,IAAK,CAAA/D,IAAA,CAAKiE,KAAA,CAAMvD,CAAC,GAAGmD,SAAA,EAAWC,QAAQ;IAE3H,MAAAI,UAAA,GAAa5C,IAAA,CAAK6C,aAAc;IAEtC,IAAID,UAAsB,YAAAE,cAAA,EAAqB,KAAAC,gCAAA,CAAiCH,UAAA,EAAYJ,QAAQ;IAEpG,MAAMJ,WAAA,GAAcX,UAAW,CAAAtC,KAAA;IAC/B,MAAM6D,SAAA,GAAYZ,WAAY,CAAA/C,MAAA;IAErB,SAAAD,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI4D,SAAW,EAAA5D,CAAA,IAAU,KAAA0C,QAAA,CAASM,WAAY,CAAAhD,CAAC,CAAC;IAE3D,KAAAT,YAAA,CAAaiB,IAAA,CAAK6B,UAAU;IAExB,SAAArC,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI4D,SAAW,EAAA5D,CAAA,IAAK,KAAKiD,SAAU,CAAAD,WAAA,CAAYhD,CAAC,EAAEO,QAAQ;IACjE,SAAAP,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI4D,SAAW,EAAA5D,CAAA,IAAiBgD,WAAA,CAAAhD,CAAC,EAAE2B,MAAS;EAAA;EAGhEa,wBAAwBH,UAAiC;IACrDA,UAAA,CAAWR,MAAA,GAASQ,UAAW,CAAAM,MAAA,CAAOC,QAAA,EAAe,MAACP,UAAA,CAAW/C,IAAK,CAAAsC,YAAA,IAAiB,IAAK,CAAAnC,IAAA,IAAQoD,KAAA,CAAMC,QAAS,MAAKrD,IAAA,CAAKsD,WAAa,EAAAV,UAAA,CAAW/C,IAAA,EAAM,IAAI;IAC/J,IAAI,CAAC+C,UAAW,CAAAR,MAAA,EAAQ;IAEnB,KAAAa,QAAA,CAASL,UAAA,CAAWM,MAAM;IAE/B,MAAMK,WAAA,GAAcX,UAAW,CAAAtC,KAAA;IAC/B,MAAM6D,SAAA,GAAYZ,WAAY,CAAA/C,MAAA;IAE1B,IAAAoC,UAAA,CAAW/C,IAAA,CAAKuE,KAAO;MACvB,SAAS7D,CAAI,MAAGA,CAAI,GAAA4D,SAAA,EAAW5D,CAAK;QAC1B,MAAAkD,KAAA,GAAQF,WAAA,CAAYhD,CAAC;QAEtB,KAAA0C,QAAA,CAASQ,KAAA,CAAM9C,MAAM;QAC1B,KAAKsC,QAAA,CAASQ,KAAK;MAAA;IACvB,CACG;MACH,SAASlD,CAAI,MAAGA,CAAI,GAAA4D,SAAA,EAAW5D,CAAK;QAC3B,KAAA0C,QAAA,CAASM,WAAY,CAAAhD,CAAC,CAAC;MAAA;IAChC;IAGC,KAAAT,YAAA,CAAaiB,IAAA,CAAK6B,UAAU;IAExB,SAAArC,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI4D,SAAW,EAAA5D,CAAA,IAAK,KAAKiD,SAAU,CAAAD,WAAA,CAAYhD,CAAC,EAAEO,QAAQ;IACjE,SAAAP,CAAA,GAAI,CAAG,EAAAA,CAAA,GAAI4D,SAAW,EAAA5D,CAAA,IAAiBgD,WAAA,CAAAhD,CAAC,EAAE2B,MAAS;EAAA;EAGhE0B,6BAA6B5D,IAAY,EAAA0D,SAAA,EAAmBC,QAAgB;IAClE,MAAAU,WAAA,GAAcrE,IAAK,CAAAqE,WAAA,CAAYX,SAAS;IAE9C,IAAI,CAACW,WAAA,EAAa;IAClB,WAAWC,GAAA,IAAOD,WAAa;MAC3B,KAAKH,gCAAiC,CAAAG,WAAA,CAAYC,GAAG,GAAGX,QAAQ;IAAA;EACpE;EAGJO,iCAAiCH,UAAA,EAAwBJ,QAAgB;IACrE,IAAI,EAAEI,UAAsB,YAAAE,cAAA,GAAiB;IAC7C,MAAMM,SAAA,GAA6BR,UAAY,CAAAzD,KAAA;IAE/C,IAAI,CAACiE,SAAA,EAAW,KAAKtB,QAAA,CAASU,QAAQ,OACjC;MACD,MAAMrD,KAAA,GAAQ,IAAK,CAAAA,KAAA;MAEnB,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIsC,SAAU,CAAA/D,MAAA,EAAQD,CAAA,GAAI0B,CAAK;QACvC,IAAAuC,EAAA,GAAKD,SAAA,CAAUhE,CAAG;QAEhBiE,EAAA,IAAAjE,CAAA;QACN,OAAOA,CAAI,GAAAiE,EAAA,EAAI,KAAKvB,QAAS,CAAA3C,KAAA,CAAMiE,SAAU,CAAAhE,CAAA,EAAG,CAAC,CAAC;MAAA;IACtD;EACJ;EAGJ0C,SAASvC,IAAY;IACjB,IAAI,CAACA,IAAA,EAAM;IACX,IAAIA,IAAK,CAAAwB,MAAA,EAAQ;IACjB,MAAMvB,MAAA,GAASD,IAAK,CAAAC,MAAA;IAEhB,IAAAA,MAAA,EAAQ,KAAKsC,QAAA,CAAStC,MAAM;IAChCD,IAAA,CAAKwB,MAAS;IACT,KAAApC,YAAA,CAAaiB,IAAA,CAAKL,IAAI;EAAA;EAG/B8C,UAAUlD,KAAoB;IAC1B,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAA,CAAME,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACpC,MAAAG,IAAA,GAAOJ,KAAA,CAAMC,CAAC;MAEpB,IAAI,CAACG,IAAK,CAAA0B,MAAA,EAAQ;MAClB,IAAI1B,IAAK,CAAAwB,MAAA,EAAa,KAAAsB,SAAA,CAAU9C,IAAA,CAAKI,QAAQ;MAC7CJ,IAAA,CAAKwB,MAAS;IAAA;EAClB;EACJ;AAAA;AAAA;AAAA;EAMAuC,oBAAuBA,CAAA;IACnB,MAAMnE,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAA,CAAME,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACpC,MAAAG,IAAA,GAAOJ,KAAA,CAAMC,CAAC;MAEpBG,IAAA,CAAKgE,EAAA,GAAKhE,IAAK,CAAAP,CAAA;MACfO,IAAA,CAAKiE,EAAA,GAAKjE,IAAK,CAAAN,CAAA;MACfM,IAAA,CAAKkE,SAAA,GAAYlE,IAAK,CAAAmE,QAAA;MACtBnE,IAAA,CAAKoE,OAAA,GAAUpE,IAAK,CAAAT,MAAA;MACpBS,IAAA,CAAKqE,OAAA,GAAUrE,IAAK,CAAAR,MAAA;MACpBQ,IAAA,CAAKsE,OAAA,GAAUtE,IAAK,CAAAuE,MAAA;MACpBvE,IAAA,CAAKwE,OAAA,GAAUxE,IAAK,CAAAyE,MAAA;IAAA;IAGxB,MAAMnD,WAAA,GAAc,IAAK,CAAAlC,YAAA;IAEzB,SAASS,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAID,WAAY,CAAAxB,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAiByB,WAAA,CAAAzB,CAAC,EAAE6E,MAAO;EAAA;EAG9EC,yBAAyB1E,MAAc;IAE7B,MAAA2E,QAAA,GAAW,KAAKC,WAAY;IAC5B,MAAAC,EAAA,GAAK7E,MAAA,CAAO8E,MAAO,CAAAC,CAAA;IACnB,MAAAC,EAAA,GAAKhF,MAAA,CAAO8E,MAAO,CAAAG,CAAA;IACnB,MAAAC,EAAA,GAAKlF,MAAA,CAAO8E,MAAO,CAAAK,CAAA;IACnB,MAAAC,EAAA,GAAKpF,MAAA,CAAO8E,MAAO,CAAAO,CAAA;IAEhBV,QAAA,CAAAG,MAAA,CAAOQ,EAAA,GAAKT,EAAK,QAAKrF,CAAA,GAAIwF,EAAK,QAAKvF,CAAA,GAAIO,MAAO,CAAAuF,MAAA;IAC/CZ,QAAA,CAAAG,MAAA,CAAOU,EAAA,GAAKN,EAAK,QAAK1F,CAAA,GAAI4F,EAAK,QAAK3F,CAAA,GAAIO,MAAO,CAAAyF,MAAA;IAExD,MAAMC,SAAY,GAAAf,QAAA,CAAST,QAAW,QAAKS,QAAS,CAAAH,MAAA;IAC9C,MAAAmB,EAAA,GAAKC,SAAA,CAAUC,MAAO,CAAAlB,QAAA,CAAST,QAAA,GAAWS,QAAS,CAAAL,MAAM,IAAIK,QAAS,CAAArF,MAAA;IAC5E,MAAMwG,EAAK,GAAAF,SAAA,CAAUC,MAAO,CAAAH,SAAS,IAAIf,QAAS,CAAApF,MAAA;IAC5C,MAAAwG,EAAA,GAAKH,SAAA,CAAUI,MAAO,CAAArB,QAAA,CAAST,QAAA,GAAWS,QAAS,CAAAL,MAAM,IAAIK,QAAS,CAAArF,MAAA;IAC5E,MAAM2G,EAAK,GAAAL,SAAA,CAAUI,MAAO,CAAAN,SAAS,IAAIf,QAAS,CAAApF,MAAA;IAElD,MAAM2G,EAAA,GAAK,IAAK,CAAA5G,MAAA;IAChB,MAAM6G,EAAA,GAAKC,QAAS,CAAAC,KAAA,GAAQ,CAAC,KAAK9G,MAAA,GAAS,IAAK,CAAAA,MAAA;IAEhDoF,QAAA,CAASG,MAAO,CAAAC,CAAA,IAAKF,EAAK,GAAAc,EAAA,GAAKX,EAAA,GAAKe,EAAM,IAAAG,EAAA;IAC1CvB,QAAA,CAASG,MAAO,CAAAG,CAAA,IAAKJ,EAAK,GAAAiB,EAAA,GAAKd,EAAA,GAAKiB,EAAM,IAAAC,EAAA;IAC1CvB,QAAA,CAASG,MAAO,CAAAK,CAAA,IAAKD,EAAK,GAAAS,EAAA,GAAKP,EAAA,GAAKW,EAAM,IAAAI,EAAA;IAC1CxB,QAAA,CAASG,MAAO,CAAAO,CAAA,IAAKH,EAAK,GAAAY,EAAA,GAAKV,EAAA,GAAKa,EAAM,IAAAE,EAAA;IAG1C,MAAM9E,WAAA,GAAc,IAAK,CAAAlC,YAAA;IAEzB,SAASS,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAID,WAAA,CAAYxB,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MAC1C,MAAA0G,SAAA,GAAYjF,WAAA,CAAYzB,CAAC;MAE/B,IAAI0G,SAAa,IAAA3B,QAAA,EAAU2B,SAAA,CAAU7B,MAAO;IAAA;EAChD;EACJ;EAGA8B,cAAiBA,CAAA;IACb,KAAKC,mBAAoB;IACzB,KAAKC,mBAAoB;EAAA;EAC7B;EAGAD,mBAAsBA,CAAA;IAClB,MAAM7G,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAM,CAAAE,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAWD,KAAA,CAAAC,CAAC,EAAE2G,cAAe;IAEtE,MAAM7F,aAAA,GAAgB,IAAK,CAAAA,aAAA;IAE3B,SAASd,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIZ,aAAA,CAAcb,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MAC5C,MAAAqC,UAAA,GAAavB,aAAA,CAAcd,CAAC;MAEvBqC,UAAA,CAAAyE,GAAA,GAAMzE,UAAA,CAAW/C,IAAK,CAAAwH,GAAA;MACtBzE,UAAA,CAAA0E,QAAA,GAAW1E,UAAA,CAAW/C,IAAK,CAAAyH,QAAA;MAC3B1E,UAAA,CAAA2E,aAAA,GAAgB3E,UAAA,CAAW/C,IAAK,CAAA0H,aAAA;MAChC3E,UAAA,CAAA4E,QAAA,GAAW5E,UAAA,CAAW/C,IAAK,CAAA2H,QAAA;MAC3B5E,UAAA,CAAA6E,OAAA,GAAU7E,UAAA,CAAW/C,IAAK,CAAA4H,OAAA;IAAA;IAGzC,MAAMjG,oBAAA,GAAuB,IAAK,CAAAA,oBAAA;IAElC,SAASjB,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIT,oBAAA,CAAqBhB,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACnD,MAAAqC,UAAA,GAAapB,oBAAA,CAAqBjB,CAAC;MACzC,MAAMV,IAAA,GAAO+C,UAAW,CAAA/C,IAAA;MAExB+C,UAAA,CAAW8E,SAAA,GAAY7H,IAAK,CAAA6H,SAAA;MAC5B9E,UAAA,CAAW+E,IAAA,GAAO9H,IAAK,CAAA8H,IAAA;MACvB/E,UAAA,CAAWgF,IAAA,GAAO/H,IAAK,CAAA+H,IAAA;MACvBhF,UAAA,CAAWiF,SAAA,GAAYhI,IAAK,CAAAgI,SAAA;MAC5BjF,UAAA,CAAWkF,SAAA,GAAYjI,IAAK,CAAAiI,SAAA;MAC5BlF,UAAA,CAAWmF,SAAA,GAAYlI,IAAK,CAAAkI,SAAA;IAAA;IAGhC,MAAMpG,eAAA,GAAkB,IAAK,CAAAA,eAAA;IAE7B,SAASpB,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIN,eAAA,CAAgBnB,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MAC9C,MAAAqC,UAAA,GAAajB,eAAA,CAAgBpB,CAAC;MACpC,MAAMV,IAAA,GAAO+C,UAAW,CAAA/C,IAAA;MAExB+C,UAAA,CAAWoF,QAAA,GAAWnI,IAAK,CAAAmI,QAAA;MAC3BpF,UAAA,CAAWqF,OAAA,GAAUpI,IAAK,CAAAoI,OAAA;MAC1BrF,UAAA,CAAW8E,SAAA,GAAY7H,IAAK,CAAA6H,SAAA;MAC5B9E,UAAA,CAAW+E,IAAA,GAAO9H,IAAK,CAAA8H,IAAA;MACvB/E,UAAA,CAAWgF,IAAA,GAAO/H,IAAK,CAAA+H,IAAA;IAAA;EAC3B;EACJ;EAGAR,mBAAsBA,CAAA;IAClB,MAAMpG,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnBoC,KAAA,CAAM8E,SAAA,CAAUlH,KAAO,KAAG,KAAKC,SAAW,KAAGD,KAAA,CAAMR,MAAM;IACzD,SAASD,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIjB,KAAM,CAAAR,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAWS,KAAA,CAAAT,CAAC,EAAE2G,cAAe;EAAA;EAC1E;EAGA3B,WAAcA,CAAA;IACN,SAAKjF,KAAA,CAAME,MAAU,OAAU;IAE5B,YAAKF,KAAA,CAAM,CAAC;EAAA;EACvB;EAGA6H,SAASC,QAAkB;IACvB,IAAI,CAACA,QAAA,EAAgB,UAAI/H,KAAA,CAAM,0BAA0B;IACzD,MAAMC,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAA,CAAME,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACpC,MAAAG,IAAA,GAAOJ,KAAA,CAAMC,CAAC;MAEhB,IAAAG,IAAA,CAAKb,IAAA,CAAKwI,IAAQ,IAAAD,QAAA,EAAiB,OAAA1H,IAAA;IAAA;IAGpC;EAAA;EACX;EAGA4H,cAAcF,QAAkB;IAC5B,IAAI,CAACA,QAAA,EAAgB,UAAI/H,KAAA,CAAM,0BAA0B;IACzD,MAAMC,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAASC,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAI3B,KAAM,CAAAE,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAK,IAAID,KAAM,CAAAC,CAAC,CAAE,CAAAV,IAAA,CAAKwI,IAAQ,IAAAD,QAAA,EAAiB,OAAA7H,CAAA;IAElF;EAAA;EACX;AAAA;AAAA;EAKAgI,SAASC,QAAkB;IACvB,IAAI,CAACA,QAAA,EAAgB,UAAInI,KAAA,CAAM,0BAA0B;IACzD,MAAMW,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAAST,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIjB,KAAA,CAAMR,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACpC,MAAAY,IAAA,GAAOH,KAAA,CAAMT,CAAC;MAEhB,IAAAY,IAAA,CAAKtB,IAAA,CAAKwI,IAAQ,IAAAG,QAAA,EAAiB,OAAArH,IAAA;IAAA;IAGpC;EAAA;EACX;EAGAsH,cAAcD,QAAkB;IAC5B,IAAI,CAACA,QAAA,EAAgB,UAAInI,KAAA,CAAM,0BAA0B;IACzD,MAAMW,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAAST,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIjB,KAAM,CAAAR,MAAA,EAAQD,CAAA,GAAI0B,CAAG,EAAA1B,CAAA,IAAK,IAAIS,KAAM,CAAAT,CAAC,CAAE,CAAAV,IAAA,CAAKwI,IAAQ,IAAAG,QAAA,EAAiB,OAAAjI,CAAA;IAElF;EAAA;EACX;AAAA;AAAA;EAKAmI,cAAcC,QAAkB;IAC5B,MAAM3I,IAAO,QAAKH,IAAK,CAAA+I,QAAA,CAASD,QAAQ;IAExC,IAAI,CAAC3I,IAAA,EAAY,UAAIK,KAAM,oBAAmBsI,QAAU;IACxD,KAAKE,OAAA,CAAQ7I,IAAI;EAAA;EACrB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;EAYA6I,QAAQC,OAAe;IACnB,IAAIA,OAAA,IAAW,IAAK,CAAA9I,IAAA,EAAM;IAC1B,IAAI8I,OAAS;MACT,IAAI,IAAK,CAAA9I,IAAA,EAAc8I,OAAA,CAAAC,SAAA,CAAU,IAAM,OAAK/I,IAAI,OAC3C;QACD,MAAMgB,KAAA,GAAQ,IAAK,CAAAA,KAAA;QAEnB,SAAST,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIjB,KAAA,CAAMR,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;UACpC,MAAAY,IAAA,GAAOH,KAAA,CAAMT,CAAC;UACd,MAAA8H,IAAA,GAAOlH,IAAA,CAAKtB,IAAK,CAAAmJ,cAAA;UAEvB,IAAIX,IAAM;YACN,MAAMtE,UAAa,GAAA+E,OAAA,CAAQ9E,aAAc,CAAAzD,CAAA,EAAG8H,IAAI;YAE5C,IAAAtE,UAAA,EAAY5C,IAAA,CAAK8H,aAAA,CAAclF,UAAU;UAAA;QACjD;MACJ;IACJ;IAEJ,KAAK/D,IAAO,GAAA8I,OAAA;IACZ,KAAK9G,WAAY;EAAA;EACrB;AAAA;AAAA;AAAA;AAAA;EAOAkH,oBAAoBV,QAAA,EAAkBQ,cAA2C;IAC7E,MAAM7H,IAAO,QAAKtB,IAAK,CAAA0I,QAAA,CAASC,QAAQ;IAExC,IAAI,CAACrH,IAAA,EAAY,UAAId,KAAM,8BAA6BmI,QAAU;IAElE,OAAO,IAAK,CAAAxE,aAAA,CAAc7C,IAAK,CAAAN,KAAA,EAAOmI,cAAc;EAAA;EACxD;AAAA;AAAA;AAAA;AAAA;EAOAhF,cAAcN,SAAA,EAAmBsF,cAA2C;IACxE,IAAI,CAACA,cAAA,EAAsB,UAAI3I,KAAA,CAAM,gCAAgC;IACrE,IAAI,KAAKL,IAAM;MACX,MAAM+D,UAAa,QAAK/D,IAAK,CAAAgE,aAAA,CAAcN,SAAA,EAAWsF,cAAc;MAEhE,IAAAjF,UAAA,EAAmB,OAAAA,UAAA;IAAA;IAE3B,IAAI,KAAKlE,IAAK,CAAAgE,WAAA,EAAa,OAAO,IAAK,CAAAhE,IAAA,CAAKgE,WAAY,CAAAG,aAAA,CAAcN,SAAA,EAAWsF,cAAc;IAExF;EAAA;EACX;AAAA;AAAA;EAKAC,cAAcT,QAAA,EAAkBQ,cAAwB;IACpD,IAAI,CAACR,QAAA,EAAgB,UAAInI,KAAA,CAAM,0BAA0B;IACzD,MAAMW,KAAA,GAAQ,IAAK,CAAAA,KAAA;IAEnB,SAAST,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIjB,KAAA,CAAMR,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACpC,MAAAY,IAAA,GAAOH,KAAA,CAAMT,CAAC;MAEhB,IAAAY,IAAA,CAAKtB,IAAK,CAAAwI,IAAA,IAAQG,QAAU;QAC5B,IAAIzE,UAAgC;QAEpC,IAAIiF,cAAgB;UACHjF,UAAA,QAAKC,aAAc,CAAAzD,CAAA,EAAGyI,cAAc;UACjD,IAAI,CAACjF,UAAA,EAAY,MAAM,IAAI1D,KAAA,CAAM,yBAAyB2I,cAAA,eAA6BR,QAAU;QAAA;QAErGrH,IAAA,CAAK8H,aAAA,CAAclF,UAAU;QAE7B;MAAA;IACJ;IAEE,UAAI1D,KAAM,oBAAmBmI,QAAU;EAAA;EACjD;AAAA;AAAA;EAKAW,iBAAiBC,cAAwB;IACrC,IAAI,CAACA,cAAA,EAAsB,UAAI/I,KAAA,CAAM,gCAAgC;IACrE,MAAMgB,aAAA,GAAgB,IAAK,CAAAA,aAAA;IAE3B,SAASd,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIZ,aAAA,CAAcb,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MAC5C,MAAA8I,YAAA,GAAehI,aAAA,CAAcd,CAAC;MAEhC,IAAA8I,YAAA,CAAaxJ,IAAA,CAAKwI,IAAQ,IAAAe,cAAA,EAAuB,OAAAC,YAAA;IAAA;IAGlD;EAAA;EACX;AAAA;AAAA;EAKAC,wBAAwBF,cAAwB;IAC5C,IAAI,CAACA,cAAA,EAAsB,UAAI/I,KAAA,CAAM,gCAAgC;IACrE,MAAMmB,oBAAA,GAAuB,IAAK,CAAAA,oBAAA;IAElC,SAASjB,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIT,oBAAA,CAAqBhB,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACnD,MAAAqC,UAAA,GAAapB,oBAAA,CAAqBjB,CAAC;MAErC,IAAAqC,UAAA,CAAW/C,IAAA,CAAKwI,IAAQ,IAAAe,cAAA,EAAuB,OAAAxG,UAAA;IAAA;IAGhD;EAAA;EACX;AAAA;AAAA;EAKA2G,mBAAmBH,cAAwB;IACvC,IAAI,CAACA,cAAA,EAAsB,UAAI/I,KAAA,CAAM,gCAAgC;IACrE,MAAMsB,eAAA,GAAkB,IAAK,CAAAA,eAAA;IAE7B,SAASpB,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIN,eAAA,CAAgBnB,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MAC9C,MAAAqC,UAAA,GAAajB,eAAA,CAAgBpB,CAAC;MAEhC,IAAAqC,UAAA,CAAW/C,IAAA,CAAKwI,IAAQ,IAAAe,cAAA,EAAuB,OAAAxG,UAAA;IAAA;IAGhD;EAAA;EACX;AAAA;EAIA4G,aAAgBA,CAAA;IACN,MAAAC,MAAA,GAAS,IAAIC,OAAQ;IACrB,MAAAC,IAAA,GAAO,IAAID,OAAQ;IAEpB,KAAAE,SAAA,CAAUH,MAAA,EAAQE,IAAI;IAE3B,OAAO;MAAExJ,CAAA,EAAGsJ,MAAO,CAAAtJ,CAAA;MAAGC,CAAG,EAAAqJ,MAAA,CAAOrJ,CAAG;MAAAyJ,KAAA,EAAOF,IAAK,CAAAxJ,CAAA;MAAG2J,MAAQ,EAAAH,IAAA,CAAKvJ;IAAE;EAAA;EACrE;AAAA;AAAA;AAAA;EAMAwJ,UAAUH,MAAiB,EAAAE,IAAA,EAAeI,IAAA,GAAsB,IAAIhK,KAAA,CAAc,CAAC,CAAG;IAClF,IAAI,CAAC0J,MAAA,EAAc,UAAIpJ,KAAA,CAAM,wBAAwB;IACrD,IAAI,CAACsJ,IAAA,EAAY,UAAItJ,KAAA,CAAM,sBAAsB;IACjD,MAAMY,SAAA,GAAY,IAAK,CAAAA,SAAA;IACvB,IAAI+I,IAAA,GAAOC,MAAO,CAAAC,iBAAA;IAClB,IAAIC,IAAA,GAAOF,MAAO,CAAAC,iBAAA;IAClB,IAAIE,IAAA,GAAOH,MAAO,CAAAI,iBAAA;IAClB,IAAIC,IAAA,GAAOL,MAAO,CAAAI,iBAAA;IAElB,SAAS9J,CAAA,GAAI,CAAG,EAAA0B,CAAA,GAAIhB,SAAA,CAAUT,MAAQ,EAAAD,CAAA,GAAI0B,CAAA,EAAG1B,CAAK;MACxC,MAAAY,IAAA,GAAOF,SAAA,CAAUV,CAAC;MAEpB,KAACY,IAAA,CAAKT,IAAK,CAAA0B,MAAA,EAAQ;MACvB,IAAImI,cAAiB;MACrB,IAAIC,QAAmC;MACjC,MAAAzG,UAAA,GAAa5C,IAAA,CAAK6C,aAAc;MAEtC,IAAID,UAAA,YAAsB0G,gBAAkB;QACvBF,cAAA;QACjBC,QAAA,GAAWpH,KAAM,CAAAsH,YAAA,CAAaX,IAAM,EAAAQ,cAAA,EAAgB,CAAC;QAClCxG,UAAY,CAAA4G,oBAAA,CAAqBxJ,IAAM,EAAAqJ,QAAA,EAAU,GAAG,CAAC;MAAA,CAC5E,UAAWzG,UAAA,YAAsB6G,cAAgB;QAC7C,MAAMC,IAAuB,GAAA9G,UAAA;QAE7BwG,cAAA,GAAiBM,IAAK,CAAAC,mBAAA;QACtBN,QAAA,GAAWpH,KAAM,CAAAsH,YAAA,CAAaX,IAAM,EAAAQ,cAAA,EAAgB,CAAC;QACrDM,IAAA,CAAKF,oBAAA,CAAqBxJ,IAAM,KAAGoJ,cAAgB,EAAAC,QAAA,EAAU,GAAG,CAAC;MAAA;MAErE,IAAIA,QAAU;QACD,SAAA7H,EAAA,GAAK,GAAG6B,EAAK,GAAAgG,QAAA,CAAShK,MAAA,EAAQmC,EAAK,GAAA6B,EAAA,EAAI7B,EAAA,IAAM,CAAG;UAC/C,MAAAxC,CAAA,GAAIqK,QAAA,CAAS7H,EAAE;UACf,MAAAvC,CAAA,GAAIoK,QAAS,CAAA7H,EAAA,GAAK,CAAC;UAElBqH,IAAA,GAAAe,IAAA,CAAKC,GAAI,CAAAhB,IAAA,EAAM7J,CAAC;UAChBgK,IAAA,GAAAY,IAAA,CAAKC,GAAI,CAAAb,IAAA,EAAM/J,CAAC;UAChBgK,IAAA,GAAAW,IAAA,CAAKE,GAAI,CAAAb,IAAA,EAAMjK,CAAC;UAChBmK,IAAA,GAAAS,IAAA,CAAKE,GAAI,CAAAX,IAAA,EAAMlK,CAAC;QAAA;MAC3B;IACJ;IAEGqJ,MAAA,CAAAyB,GAAA,CAAIlB,IAAA,EAAMG,IAAI;IACrBR,IAAA,CAAKuB,GAAI,CAAAd,IAAA,GAAOJ,IAAM,EAAAM,IAAA,GAAOH,IAAI;EAAA;EAGrC,IAAIgB,KAAiBA,CAAA;IACjB,OAAO,KAAKlL,MAAU;EAAA;EAG1B,IAAIkL,MAAMC,KAAgB;IAClB,KAACzL,SAAA,CAAS0L,kBAAoB;MAC9B1L,SAAA,CAAS0L,kBAAqB;MAC9BC,OAAA,CAAQC,IAAA,CAAK,4FAA4F;IAAA;IAExG,KAAAtL,MAAA,GAASmL,KAAA,GAAQ,CAAM;EAAA;EAGhC,IAAII,KAAiBA,CAAA;IACjB,OAAO,KAAKtL,MAAU;EAAA;EAG1B,IAAIsL,MAAMJ,KAAgB;IAClB,KAACzL,SAAA,CAAS0L,kBAAoB;MAC9B1L,SAAA,CAAS0L,kBAAqB;MAC9BC,OAAA,CAAQC,IAAA,CAAK,4FAA4F;IAAA;IAExG,KAAArL,MAAA,GAASkL,KAAA,GAAQ,CAAM;EAAA;AAIpC;AApsBO,IAAMK,QAAN,GAAA9L,SAAA;AAAM8L,QAAA,CAmsBMJ,kBAAqB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}