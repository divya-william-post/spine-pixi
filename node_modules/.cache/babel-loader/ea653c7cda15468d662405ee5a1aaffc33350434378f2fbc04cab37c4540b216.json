{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, Rectangle, Texture } from '@pixi/core';\nimport { TextureFilter, TextureWrap, TextureRegion, filterFromString } from './TextureRegion.mjs';\nclass RegionFields {\n  constructor() {\n    this.x = 0;\n    this.y = 0;\n    this.width = 0;\n    this.height = 0;\n    this.offsetX = 0;\n    this.offsetY = 0;\n    this.originalWidth = 0;\n    this.originalHeight = 0;\n    this.rotate = 0;\n    this.index = 0;\n  }\n}\nclass TextureAtlas {\n  constructor(atlasText, textureLoader, callback) {\n    this.pages = new Array();\n    this.regions = new Array();\n    if (atlasText) {\n      this.addSpineAtlas(atlasText, textureLoader, callback);\n    }\n  }\n  addTexture(name, texture) {\n    const pages = this.pages;\n    let page = null;\n    for (let i = 0; i < pages.length; i++) {\n      if (pages[i].baseTexture === texture.baseTexture) {\n        page = pages[i];\n        break;\n      }\n    }\n    if (page === null) {\n      page = new TextureAtlasPage();\n      page.name = \"texturePage\";\n      const baseTexture = texture.baseTexture;\n      page.width = baseTexture.realWidth;\n      page.height = baseTexture.realHeight;\n      page.baseTexture = baseTexture;\n      page.minFilter = page.magFilter = TextureFilter.Nearest;\n      page.uWrap = TextureWrap.ClampToEdge;\n      page.vWrap = TextureWrap.ClampToEdge;\n      pages.push(page);\n    }\n    const region = new TextureAtlasRegion();\n    region.name = name;\n    region.page = page;\n    region.texture = texture;\n    region.index = -1;\n    this.regions.push(region);\n    return region;\n  }\n  addTextureHash(textures, stripExtension) {\n    for (const key in textures) {\n      if (textures.hasOwnProperty(key)) {\n        this.addTexture(stripExtension && key.indexOf(\".\") !== -1 ? key.substr(0, key.lastIndexOf(\".\")) : key, textures[key]);\n      }\n    }\n  }\n  addSpineAtlas(atlasText, textureLoader, callback) {\n    return this.load(atlasText, textureLoader, callback);\n  }\n  load(atlasText, textureLoader, callback) {\n    if (textureLoader == null) {\n      throw new Error(\"textureLoader cannot be null.\");\n    }\n    const reader = new TextureAtlasReader(atlasText);\n    const entry = new Array(4);\n    let page = null;\n    const pageFields = {};\n    let region = null;\n    pageFields.size = () => {\n      page.width = parseInt(entry[1]);\n      page.height = parseInt(entry[2]);\n    };\n    pageFields.format = () => {};\n    pageFields.filter = () => {\n      page.minFilter = filterFromString(entry[1]);\n      page.magFilter = filterFromString(entry[2]);\n    };\n    pageFields.repeat = () => {\n      if (entry[1].indexOf(\"x\") != -1) page.uWrap = TextureWrap.Repeat;\n      if (entry[1].indexOf(\"y\") != -1) page.vWrap = TextureWrap.Repeat;\n    };\n    pageFields.pma = () => {\n      page.pma = entry[1] == \"true\";\n    };\n    const regionFields = {};\n    regionFields.xy = () => {\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n    };\n    regionFields.size = () => {\n      region.width = parseInt(entry[1]);\n      region.height = parseInt(entry[2]);\n    };\n    regionFields.bounds = () => {\n      region.x = parseInt(entry[1]);\n      region.y = parseInt(entry[2]);\n      region.width = parseInt(entry[3]);\n      region.height = parseInt(entry[4]);\n    };\n    regionFields.offset = () => {\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n    };\n    regionFields.orig = () => {\n      region.originalWidth = parseInt(entry[1]);\n      region.originalHeight = parseInt(entry[2]);\n    };\n    regionFields.offsets = () => {\n      region.offsetX = parseInt(entry[1]);\n      region.offsetY = parseInt(entry[2]);\n      region.originalWidth = parseInt(entry[3]);\n      region.originalHeight = parseInt(entry[4]);\n    };\n    regionFields.rotate = () => {\n      const rotateValue = entry[1];\n      let rotate = 0;\n      if (rotateValue.toLocaleLowerCase() == \"true\") {\n        rotate = 6;\n      } else if (rotateValue.toLocaleLowerCase() == \"false\") {\n        rotate = 0;\n      } else {\n        rotate = (720 - parseFloat(rotateValue)) % 360 / 45;\n      }\n      region.rotate = rotate;\n    };\n    regionFields.index = () => {\n      region.index = parseInt(entry[1]);\n    };\n    let line = reader.readLine();\n    while (line != null && line.trim().length == 0) {\n      line = reader.readLine();\n    }\n    while (true) {\n      if (line == null || line.trim().length == 0) break;\n      if (reader.readEntry(entry, line) == 0) break;\n      line = reader.readLine();\n    }\n    const iterateParser = () => {\n      while (true) {\n        if (line == null) {\n          return callback && callback(this);\n        }\n        if (line.trim().length == 0) {\n          page = null;\n          line = reader.readLine();\n        } else if (page === null) {\n          page = new TextureAtlasPage();\n          page.name = line.trim();\n          while (true) {\n            if (reader.readEntry(entry, line = reader.readLine()) == 0) break;\n            const field = pageFields[entry[0]];\n            if (field) field();\n          }\n          this.pages.push(page);\n          textureLoader(page.name, texture => {\n            if (texture === null) {\n              this.pages.splice(this.pages.indexOf(page), 1);\n              return callback && callback(null);\n            }\n            page.baseTexture = texture;\n            if (page.pma) {\n              texture.alphaMode = ALPHA_MODES.PMA;\n            }\n            if (!texture.valid) {\n              texture.setSize(page.width, page.height);\n            }\n            page.setFilters();\n            if (!page.width || !page.height) {\n              page.width = texture.realWidth;\n              page.height = texture.realHeight;\n              if (!page.width || !page.height) {\n                console.log(`ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`);\n              }\n            }\n            iterateParser();\n          });\n          break;\n        } else {\n          region = new RegionFields();\n          const atlasRegion = new TextureAtlasRegion();\n          atlasRegion.name = line;\n          atlasRegion.page = page;\n          let names = null;\n          let values = null;\n          while (true) {\n            const count = reader.readEntry(entry, line = reader.readLine());\n            if (count == 0) break;\n            const field = regionFields[entry[0]];\n            if (field) {\n              field();\n            } else {\n              if (names == null) {\n                names = [];\n                values = [];\n              }\n              names.push(entry[0]);\n              const entryValues = [];\n              for (let i = 0; i < count; i++) {\n                entryValues.push(parseInt(entry[i + 1]));\n              }\n              values.push(entryValues);\n            }\n          }\n          if (region.originalWidth == 0 && region.originalHeight == 0) {\n            region.originalWidth = region.width;\n            region.originalHeight = region.height;\n          }\n          const resolution = page.baseTexture.resolution;\n          region.x /= resolution;\n          region.y /= resolution;\n          region.width /= resolution;\n          region.height /= resolution;\n          region.originalWidth /= resolution;\n          region.originalHeight /= resolution;\n          region.offsetX /= resolution;\n          region.offsetY /= resolution;\n          const swapWH = region.rotate % 4 !== 0;\n          const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\n          const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\n          const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\n          atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\n          atlasRegion.index = region.index;\n          atlasRegion.texture.updateUvs();\n          this.regions.push(atlasRegion);\n        }\n      }\n    };\n    iterateParser();\n  }\n  findRegion(name) {\n    for (let i = 0; i < this.regions.length; i++) {\n      if (this.regions[i].name == name) {\n        return this.regions[i];\n      }\n    }\n    return null;\n  }\n  dispose() {\n    for (let i = 0; i < this.pages.length; i++) {\n      this.pages[i].baseTexture.dispose();\n    }\n  }\n}\nclass TextureAtlasReader {\n  constructor(text) {\n    this.index = 0;\n    this.lines = text.split(/\\r\\n|\\r|\\n/);\n  }\n  readLine() {\n    if (this.index >= this.lines.length) {\n      return null;\n    }\n    return this.lines[this.index++];\n  }\n  readEntry(entry, line) {\n    if (line == null) return 0;\n    line = line.trim();\n    if (line.length == 0) return 0;\n    const colon = line.indexOf(\":\");\n    if (colon == -1) return 0;\n    entry[0] = line.substr(0, colon).trim();\n    for (let i = 1, lastMatch = colon + 1;; i++) {\n      const comma = line.indexOf(\",\", lastMatch);\n      if (comma == -1) {\n        entry[i] = line.substr(lastMatch).trim();\n        return i;\n      }\n      entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n      lastMatch = comma + 1;\n      if (i == 4) return 4;\n    }\n  }\n}\nclass TextureAtlasPage {\n  constructor() {\n    this.minFilter = TextureFilter.Nearest;\n    this.magFilter = TextureFilter.Nearest;\n    this.uWrap = TextureWrap.ClampToEdge;\n    this.vWrap = TextureWrap.ClampToEdge;\n  }\n  setFilters() {\n    const tex = this.baseTexture;\n    const filter = this.minFilter;\n    if (filter == TextureFilter.Linear) {\n      tex.scaleMode = SCALE_MODES.LINEAR;\n    } else if (this.minFilter == TextureFilter.Nearest) {\n      tex.scaleMode = SCALE_MODES.NEAREST;\n    } else {\n      tex.mipmap = MIPMAP_MODES.POW2;\n      if (filter == TextureFilter.MipMapNearestNearest) {\n        tex.scaleMode = SCALE_MODES.NEAREST;\n      } else {\n        tex.scaleMode = SCALE_MODES.LINEAR;\n      }\n    }\n  }\n}\nclass TextureAtlasRegion extends TextureRegion {}\nexport { TextureAtlas, TextureAtlasPage, TextureAtlasRegion };","map":{"version":3,"names":["RegionFields","constructor","x","y","width","height","offsetX","offsetY","originalWidth","originalHeight","rotate","index","TextureAtlas","atlasText","textureLoader","callback","pages","Array","regions","addSpineAtlas","addTexture","name","texture","page","i","length","baseTexture","TextureAtlasPage","realWidth","realHeight","minFilter","magFilter","TextureFilter","Nearest","uWrap","TextureWrap","ClampToEdge","vWrap","push","region","TextureAtlasRegion","addTextureHash","textures","stripExtension","key","hasOwnProperty","indexOf","substr","lastIndexOf","load","Error","reader","TextureAtlasReader","entry","pageFields","size","parseInt","format","filter","filterFromString","repeat","Repeat","pma","regionFields","xy","bounds","offset","orig","offsets","rotateValue","toLocaleLowerCase","parseFloat","line","readLine","trim","readEntry","iterateParser","field","splice","alphaMode","ALPHA_MODES","PMA","valid","setSize","setFilters","console","log","atlasRegion","names","values","count","entryValues","resolution","swapWH","frame","Rectangle","Texture","updateUvs","findRegion","dispose","text","lines","split","colon","lastMatch","comma","tex","Linear","scaleMode","SCALE_MODES","LINEAR","NEAREST","mipmap","MIPMAP_MODES","POW2","MipMapNearestNearest","TextureRegion"],"sources":["../../src/core/TextureAtlas.ts"],"sourcesContent":["import { Texture, SCALE_MODES, MIPMAP_MODES, ALPHA_MODES, Rectangle } from '@pixi/core';\nimport { TextureRegion, TextureWrap, TextureFilter, filterFromString } from './TextureRegion';\nimport type { Map, Disposable } from './Utils';\nimport type { BaseTexture } from '@pixi/core';\n\nclass RegionFields {\n    x = 0;\n    y = 0;\n    width = 0;\n    height = 0;\n    offsetX = 0;\n    offsetY = 0;\n    originalWidth = 0;\n    originalHeight = 0;\n    rotate = 0;\n    index = 0;\n}\n/**\n * @public\n */\nexport class TextureAtlas implements Disposable {\n    pages = new Array<TextureAtlasPage>();\n    regions = new Array<TextureAtlasRegion>();\n\n    constructor(atlasText?: string, textureLoader?: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback?: (obj: TextureAtlas) => any) {\n        if (atlasText) {\n            this.addSpineAtlas(atlasText, textureLoader, callback);\n        }\n    }\n\n    addTexture(name: string, texture: Texture) {\n        const pages = this.pages;\n        let page: TextureAtlasPage = null;\n\n        for (let i = 0; i < pages.length; i++) {\n            if (pages[i].baseTexture === texture.baseTexture) {\n                page = pages[i];\n                break;\n            }\n        }\n        if (page === null) {\n            page = new TextureAtlasPage();\n            page.name = 'texturePage';\n            const baseTexture = texture.baseTexture;\n\n            page.width = baseTexture.realWidth;\n            page.height = baseTexture.realHeight;\n            page.baseTexture = baseTexture;\n            // those fields are not relevant in Pixi\n            page.minFilter = page.magFilter = TextureFilter.Nearest;\n            page.uWrap = TextureWrap.ClampToEdge;\n            page.vWrap = TextureWrap.ClampToEdge;\n            pages.push(page);\n        }\n        const region = new TextureAtlasRegion();\n\n        region.name = name;\n        region.page = page;\n        region.texture = texture;\n        region.index = -1;\n        this.regions.push(region);\n\n        return region;\n    }\n\n    addTextureHash(textures: Map<Texture>, stripExtension: boolean) {\n        for (const key in textures) {\n            if (textures.hasOwnProperty(key)) {\n                this.addTexture(stripExtension && key.indexOf('.') !== -1 ? key.substr(0, key.lastIndexOf('.')) : key, textures[key]);\n            }\n        }\n    }\n\n    public addSpineAtlas(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        return this.load(atlasText, textureLoader, callback);\n    }\n\n    private load(atlasText: string, textureLoader: (path: string, loaderFunction: (tex: BaseTexture) => any) => any, callback: (obj: TextureAtlas) => any) {\n        if (textureLoader == null) {\n            throw new Error('textureLoader cannot be null.');\n        }\n\n        const reader = new TextureAtlasReader(atlasText);\n        const entry = new Array<string>(4);\n        let page: TextureAtlasPage = null;\n        const pageFields: Map<Function> = {};\n        let region: RegionFields = null;\n\n        pageFields.size = () => {\n            page.width = parseInt(entry[1]);\n            page.height = parseInt(entry[2]);\n        };\n        pageFields.format = () => {\n            // page.format = Format[tuple[0]]; we don't need format in WebGL\n        };\n        pageFields.filter = () => {\n            page.minFilter = filterFromString(entry[1]);\n            page.magFilter = filterFromString(entry[2]);\n        };\n        pageFields.repeat = () => {\n            if (entry[1].indexOf('x') != -1) page.uWrap = TextureWrap.Repeat;\n            if (entry[1].indexOf('y') != -1) page.vWrap = TextureWrap.Repeat;\n        };\n        pageFields.pma = () => {\n            page.pma = entry[1] == 'true';\n        };\n\n        const regionFields: Map<Function> = {};\n\n        regionFields.xy = () => {\n            // Deprecated, use bounds.\n            region.x = parseInt(entry[1]);\n            region.y = parseInt(entry[2]);\n        };\n        regionFields.size = () => {\n            // Deprecated, use bounds.\n            region.width = parseInt(entry[1]);\n            region.height = parseInt(entry[2]);\n        };\n        regionFields.bounds = () => {\n            region.x = parseInt(entry[1]);\n            region.y = parseInt(entry[2]);\n            region.width = parseInt(entry[3]);\n            region.height = parseInt(entry[4]);\n        };\n        regionFields.offset = () => {\n            // Deprecated, use offsets.\n            region.offsetX = parseInt(entry[1]);\n            region.offsetY = parseInt(entry[2]);\n        };\n        regionFields.orig = () => {\n            // Deprecated, use offsets.\n            region.originalWidth = parseInt(entry[1]);\n            region.originalHeight = parseInt(entry[2]);\n        };\n        regionFields.offsets = () => {\n            region.offsetX = parseInt(entry[1]);\n            region.offsetY = parseInt(entry[2]);\n            region.originalWidth = parseInt(entry[3]);\n            region.originalHeight = parseInt(entry[4]);\n        };\n        regionFields.rotate = () => {\n            const rotateValue = entry[1];\n            let rotate = 0;\n\n            if (rotateValue.toLocaleLowerCase() == 'true') {\n                rotate = 6;\n            } else if (rotateValue.toLocaleLowerCase() == 'false') {\n                rotate = 0;\n            } else {\n                rotate = ((720 - parseFloat(rotateValue)) % 360) / 45;\n            }\n            region.rotate = rotate;\n        };\n        regionFields.index = () => {\n            region.index = parseInt(entry[1]);\n        };\n\n        let line = reader.readLine();\n        // Ignore empty lines before first entry.\n\n        while (line != null && line.trim().length == 0) {\n            line = reader.readLine();\n        }\n        // Header entries.\n        while (true) {\n            if (line == null || line.trim().length == 0) break;\n            if (reader.readEntry(entry, line) == 0) break; // Silently ignore all header fields.\n            line = reader.readLine();\n        }\n\n        const iterateParser = () => {\n            while (true) {\n                if (line == null) {\n                    return callback && callback(this);\n                }\n                if (line.trim().length == 0) {\n                    page = null;\n                    line = reader.readLine();\n                } else if (page === null) {\n                    page = new TextureAtlasPage();\n                    page.name = line.trim();\n\n                    while (true) {\n                        if (reader.readEntry(entry, (line = reader.readLine())) == 0) break;\n                        const field: Function = pageFields[entry[0]];\n\n                        if (field) field();\n                    }\n                    this.pages.push(page);\n\n                    textureLoader(page.name, (texture: BaseTexture) => {\n                        if (texture === null) {\n                            this.pages.splice(this.pages.indexOf(page), 1);\n\n                            return callback && callback(null);\n                        }\n                        page.baseTexture = texture;\n                        // TODO: set scaleMode and mipmapMode from spine\n                        if (page.pma) {\n                            texture.alphaMode = ALPHA_MODES.PMA;\n                        }\n                        if (!texture.valid) {\n                            texture.setSize(page.width, page.height);\n                        }\n                        page.setFilters();\n\n                        if (!page.width || !page.height) {\n                            page.width = texture.realWidth;\n                            page.height = texture.realHeight;\n                            if (!page.width || !page.height) {\n                                console.log(\n                                    `ERROR spine atlas page ${page.name}: meshes wont work if you dont specify size in atlas (http://www.html5gamedevs.com/topic/18888-pixi-spines-and-meshes/?p=107121)`\n                                );\n                            }\n                        }\n                        iterateParser();\n                    });\n                    break;\n                } else {\n                    region = new RegionFields();\n                    const atlasRegion = new TextureAtlasRegion();\n\n                    atlasRegion.name = line;\n                    atlasRegion.page = page;\n                    let names: string[] = null;\n                    let values: number[][] = null;\n\n                    while (true) {\n                        const count = reader.readEntry(entry, (line = reader.readLine()));\n\n                        if (count == 0) break;\n                        const field: Function = regionFields[entry[0]];\n\n                        if (field) {\n                            field();\n                        } else {\n                            if (names == null) {\n                                names = [];\n                                values = [];\n                            }\n                            names.push(entry[0]);\n                            const entryValues: number[] = [];\n\n                            for (let i = 0; i < count; i++) {\n                                entryValues.push(parseInt(entry[i + 1]));\n                            }\n                            values.push(entryValues);\n                        }\n                    }\n                    if (region.originalWidth == 0 && region.originalHeight == 0) {\n                        region.originalWidth = region.width;\n                        region.originalHeight = region.height;\n                    }\n\n                    const resolution = page.baseTexture.resolution;\n\n                    region.x /= resolution;\n                    region.y /= resolution;\n                    region.width /= resolution;\n                    region.height /= resolution;\n                    region.originalWidth /= resolution;\n                    region.originalHeight /= resolution;\n                    region.offsetX /= resolution;\n                    region.offsetY /= resolution;\n\n                    const swapWH = region.rotate % 4 !== 0;\n                    const frame = new Rectangle(region.x, region.y, swapWH ? region.height : region.width, swapWH ? region.width : region.height);\n\n                    const orig = new Rectangle(0, 0, region.originalWidth, region.originalHeight);\n                    const trim = new Rectangle(region.offsetX, region.originalHeight - region.height - region.offsetY, region.width, region.height);\n\n                    atlasRegion.texture = new Texture(atlasRegion.page.baseTexture, frame, orig, trim, region.rotate);\n                    atlasRegion.index = region.index;\n                    atlasRegion.texture.updateUvs();\n\n                    this.regions.push(atlasRegion);\n                }\n            }\n        };\n\n        iterateParser();\n    }\n\n    findRegion(name: string): TextureAtlasRegion {\n        for (let i = 0; i < this.regions.length; i++) {\n            if (this.regions[i].name == name) {\n                return this.regions[i];\n            }\n        }\n\n        return null;\n    }\n\n    dispose() {\n        for (let i = 0; i < this.pages.length; i++) {\n            this.pages[i].baseTexture.dispose();\n        }\n    }\n}\n\n/**\n * @public\n */\nclass TextureAtlasReader {\n    lines: Array<string>;\n    index = 0;\n\n    constructor(text: string) {\n        this.lines = text.split(/\\r\\n|\\r|\\n/);\n    }\n\n    readLine(): string {\n        if (this.index >= this.lines.length) {\n            return null;\n        }\n\n        return this.lines[this.index++];\n    }\n\n    readEntry(entry: string[], line: string): number {\n        if (line == null) return 0;\n        line = line.trim();\n        if (line.length == 0) return 0;\n\n        const colon = line.indexOf(':');\n\n        if (colon == -1) return 0;\n        entry[0] = line.substr(0, colon).trim();\n        for (let i = 1, lastMatch = colon + 1; ; i++) {\n            const comma = line.indexOf(',', lastMatch);\n\n            if (comma == -1) {\n                entry[i] = line.substr(lastMatch).trim();\n\n                return i;\n            }\n            entry[i] = line.substr(lastMatch, comma - lastMatch).trim();\n            lastMatch = comma + 1;\n            if (i == 4) return 4;\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TextureAtlasPage {\n    name: string;\n    minFilter: TextureFilter = TextureFilter.Nearest;\n    magFilter: TextureFilter = TextureFilter.Nearest;\n    uWrap: TextureWrap = TextureWrap.ClampToEdge;\n    vWrap: TextureWrap = TextureWrap.ClampToEdge;\n    baseTexture: BaseTexture;\n    width: number;\n    height: number;\n    pma: boolean;\n\n    public setFilters() {\n        const tex = this.baseTexture;\n        const filter = this.minFilter;\n\n        if (filter == TextureFilter.Linear) {\n            tex.scaleMode = SCALE_MODES.LINEAR;\n        } else if (this.minFilter == TextureFilter.Nearest) {\n            tex.scaleMode = SCALE_MODES.NEAREST;\n        } else {\n            tex.mipmap = MIPMAP_MODES.POW2;\n            if (filter == TextureFilter.MipMapNearestNearest) {\n                tex.scaleMode = SCALE_MODES.NEAREST;\n            } else {\n                tex.scaleMode = SCALE_MODES.LINEAR;\n            }\n        }\n    }\n}\n\n/**\n * @public\n */\nexport class TextureAtlasRegion extends TextureRegion {\n    page: TextureAtlasPage;\n    name: string;\n    index: number;\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}