{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { AttachmentType } from './core/AttachmentType.mjs';\nimport { TextureRegion } from './core/TextureRegion.mjs';\nimport { MathUtils } from './core/Utils.mjs';\nimport { utils, Transform, DRAW_MODES, Polygon } from '@pixi/core';\nimport { Container } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { SimpleMesh } from '@pixi/mesh-extras';\nimport { Graphics } from '@pixi/graphics';\nimport { settings } from './settings.mjs';\nconst tempRgb = [0, 0, 0];\nclass SpineSprite extends Sprite {\n  constructor() {\n    super(...arguments);\n    this.region = null;\n    this.attachment = null;\n  }\n}\nclass SpineMesh extends SimpleMesh {\n  constructor(texture, vertices, uvs, indices, drawMode) {\n    super(texture, vertices, uvs, indices, drawMode);\n    this.region = null;\n    this.attachment = null;\n  }\n}\nconst _SpineBase = class extends Container {\n  constructor(spineData) {\n    super();\n    if (!spineData) {\n      throw new Error(\"The spineData param is required.\");\n    }\n    if (typeof spineData === \"string\") {\n      throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n    }\n    this.spineData = spineData;\n    this.createSkeleton(spineData);\n    this.slotContainers = [];\n    this.tempClipContainers = [];\n    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n      const slot = this.skeleton.slots[i];\n      const attachment = slot.getAttachment();\n      const slotContainer = this.newContainer();\n      this.slotContainers.push(slotContainer);\n      this.addChild(slotContainer);\n      this.tempClipContainers.push(null);\n      if (!attachment) {\n        continue;\n      }\n      if (attachment.type === AttachmentType.Region) {\n        const spriteName = attachment.name;\n        const sprite = this.createSprite(slot, attachment, spriteName);\n        slot.currentSprite = sprite;\n        slot.currentSpriteName = spriteName;\n        slotContainer.addChild(sprite);\n      } else if (attachment.type === AttachmentType.Mesh) {\n        const mesh = this.createMesh(slot, attachment);\n        slot.currentMesh = mesh;\n        slot.currentMeshId = attachment.id;\n        slot.currentMeshName = attachment.name;\n        slotContainer.addChild(mesh);\n      } else if (attachment.type === AttachmentType.Clipping) {\n        this.createGraphics(slot, attachment);\n        slotContainer.addChild(slot.clippingContainer);\n        slotContainer.addChild(slot.currentGraphics);\n      }\n    }\n    this.tintRgb = new Float32Array([1, 1, 1]);\n    this.autoUpdate = true;\n    this.visible = true;\n  }\n  get debug() {\n    return this._debug;\n  }\n  set debug(value) {\n    if (value == this._debug) {\n      return;\n    }\n    this._debug?.unregisterSpine(this);\n    value?.registerSpine(this);\n    this._debug = value;\n  }\n  /**\n   * If this flag is set to true, the spine animation will be automatically updated every\n   * time the object id drawn. The down side of this approach is that the delta time is\n   * automatically calculated and you could miss out on cool effects like slow motion,\n   * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n   * autoUpdate enabled but are harder to achieve.\n   *\n   * @member {boolean}\n   * @memberof spine.Spine#\n   * @default true\n   */\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value !== this._autoUpdate) {\n      this._autoUpdate = value;\n      this.updateTransform = value ? _SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\n    }\n  }\n  /**\n   * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n   *\n   * @member {number}\n   * @memberof spine.Spine#\n   * @default 0xFFFFFF\n   */\n  get tint() {\n    return utils.rgb2hex(this.tintRgb);\n  }\n  set tint(value) {\n    this.tintRgb = utils.hex2rgb(value, this.tintRgb);\n  }\n  /**\n   * Limit value for the update dt with Spine.globalDelayLimit\n   * that can be overridden with localDelayLimit\n   * @return {number} - Maximum processed dt value for the update\n   */\n  get delayLimit() {\n    const limit = typeof this.localDelayLimit !== \"undefined\" ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\n    return limit || Number.MAX_VALUE;\n  }\n  /**\n   * Update the spine skeleton and its animations by delta time (dt)\n   *\n   * @param dt {number} Delta time. Time by which the animation should be updated\n   */\n  update(dt) {\n    const delayLimit = this.delayLimit;\n    if (dt > delayLimit) dt = delayLimit;\n    this.state.update(dt);\n    this.state.apply(this.skeleton);\n    if (!this.skeleton) {\n      return;\n    }\n    this.skeleton.updateWorldTransform();\n    const slots = this.skeleton.slots;\n    const globalClr = this.color;\n    let light = null;\n    let dark = null;\n    if (globalClr) {\n      light = globalClr.light;\n      dark = globalClr.dark;\n    } else {\n      light = this.tintRgb;\n    }\n    for (let i = 0, n = slots.length; i < n; i++) {\n      const slot = slots[i];\n      const attachment = slot.getAttachment();\n      const slotContainer = this.slotContainers[i];\n      if (!attachment) {\n        slotContainer.visible = false;\n        continue;\n      }\n      let spriteColor = null;\n      if (attachment.sequence) {\n        attachment.sequence.apply(slot, attachment);\n      }\n      let region = attachment.region;\n      const attColor = attachment.color;\n      switch (attachment != null && attachment.type) {\n        case AttachmentType.Region:\n          const transform = slotContainer.transform;\n          transform.setFromMatrix(slot.bone.matrix);\n          region = attachment.region;\n          if (slot.currentMesh) {\n            slot.currentMesh.visible = false;\n            slot.currentMesh = null;\n            slot.currentMeshId = void 0;\n            slot.currentMeshName = void 0;\n          }\n          if (!region) {\n            if (slot.currentSprite) {\n              slot.currentSprite.renderable = false;\n            }\n            break;\n          }\n          if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\n            const spriteName = attachment.name;\n            if (slot.currentSprite) {\n              slot.currentSprite.visible = false;\n            }\n            slot.sprites = slot.sprites || {};\n            if (slot.sprites[spriteName] !== void 0) {\n              slot.sprites[spriteName].visible = true;\n            } else {\n              const sprite = this.createSprite(slot, attachment, spriteName);\n              slotContainer.addChild(sprite);\n            }\n            slot.currentSprite = slot.sprites[spriteName];\n            slot.currentSpriteName = spriteName;\n          }\n          slot.currentSprite.renderable = true;\n          if (!slot.hackRegion) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n          }\n          if (slot.currentSprite.color) {\n            spriteColor = slot.currentSprite.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentSprite.tint = utils.rgb2hex(tempRgb);\n          }\n          slot.currentSprite.blendMode = slot.blendMode;\n          break;\n        case AttachmentType.Mesh:\n          if (slot.currentSprite) {\n            slot.currentSprite.visible = false;\n            slot.currentSprite = null;\n            slot.currentSpriteName = void 0;\n            const transform2 = new Transform();\n            transform2._parentID = -1;\n            transform2._worldID = slotContainer.transform._worldID;\n            slotContainer.transform = transform2;\n          }\n          if (!region) {\n            if (slot.currentMesh) {\n              slot.currentMesh.renderable = false;\n            }\n            break;\n          }\n          const id = attachment.id;\n          if (slot.currentMeshId === void 0 || slot.currentMeshId !== id) {\n            const meshId = id;\n            if (slot.currentMesh) {\n              slot.currentMesh.visible = false;\n            }\n            slot.meshes = slot.meshes || {};\n            if (slot.meshes[meshId] !== void 0) {\n              slot.meshes[meshId].visible = true;\n            } else {\n              const mesh = this.createMesh(slot, attachment);\n              slotContainer.addChild(mesh);\n            }\n            slot.currentMesh = slot.meshes[meshId];\n            slot.currentMeshName = attachment.name;\n            slot.currentMeshId = meshId;\n          }\n          slot.currentMesh.renderable = true;\n          attachment.computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n          if (slot.currentMesh.color) {\n            spriteColor = slot.currentMesh.color;\n          } else {\n            tempRgb[0] = light[0] * slot.color.r * attColor.r;\n            tempRgb[1] = light[1] * slot.color.g * attColor.g;\n            tempRgb[2] = light[2] * slot.color.b * attColor.b;\n            slot.currentMesh.tint = utils.rgb2hex(tempRgb);\n          }\n          slot.currentMesh.blendMode = slot.blendMode;\n          if (!slot.hackRegion) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n          }\n          break;\n        case AttachmentType.Clipping:\n          if (!slot.currentGraphics) {\n            this.createGraphics(slot, attachment);\n            slotContainer.addChild(slot.clippingContainer);\n            slotContainer.addChild(slot.currentGraphics);\n          }\n          this.updateGraphics(slot, attachment);\n          slotContainer.alpha = 1;\n          slotContainer.visible = true;\n          continue;\n        default:\n          slotContainer.visible = false;\n          continue;\n      }\n      slotContainer.visible = true;\n      if (spriteColor) {\n        let r0 = slot.color.r * attColor.r;\n        let g0 = slot.color.g * attColor.g;\n        let b0 = slot.color.b * attColor.b;\n        spriteColor.setLight(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n        if (slot.darkColor) {\n          r0 = slot.darkColor.r;\n          g0 = slot.darkColor.g;\n          b0 = slot.darkColor.b;\n        } else {\n          r0 = 0;\n          g0 = 0;\n          b0 = 0;\n        }\n        spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n      }\n      slotContainer.alpha = slot.color.a;\n    }\n    const drawOrder = this.skeleton.drawOrder;\n    let clippingAttachment = null;\n    let clippingContainer = null;\n    for (let i = 0, n = drawOrder.length; i < n; i++) {\n      const slot = slots[drawOrder[i].data.index];\n      const slotContainer = this.slotContainers[drawOrder[i].data.index];\n      if (!clippingContainer) {\n        if (slotContainer.parent !== null && slotContainer.parent !== this) {\n          slotContainer.parent.removeChild(slotContainer);\n          slotContainer.parent = this;\n        }\n      }\n      if (slot.currentGraphics && slot.getAttachment()) {\n        clippingContainer = slot.clippingContainer;\n        clippingAttachment = slot.getAttachment();\n        clippingContainer.children.length = 0;\n        this.children[i] = slotContainer;\n        if (clippingAttachment.endSlot === slot.data) {\n          clippingAttachment.endSlot = null;\n        }\n      } else if (clippingContainer) {\n        let c = this.tempClipContainers[i];\n        if (!c) {\n          c = this.tempClipContainers[i] = this.newContainer();\n          c.visible = false;\n        }\n        this.children[i] = c;\n        slotContainer.parent = null;\n        clippingContainer.addChild(slotContainer);\n        if (clippingAttachment.endSlot == slot.data) {\n          clippingContainer.renderable = true;\n          clippingContainer = null;\n          clippingAttachment = null;\n        }\n      } else {\n        this.children[i] = slotContainer;\n      }\n    }\n    this._debug?.renderDebug(this);\n  }\n  setSpriteRegion(attachment, sprite, region) {\n    if (sprite.attachment === attachment && sprite.region === region) {\n      return;\n    }\n    sprite.region = region;\n    sprite.attachment = attachment;\n    sprite.texture = region.texture;\n    sprite.rotation = attachment.rotation * MathUtils.degRad;\n    sprite.position.x = attachment.x;\n    sprite.position.y = attachment.y;\n    sprite.alpha = attachment.color.a;\n    if (!region.size) {\n      sprite.scale.x = attachment.scaleX * attachment.width / region.originalWidth;\n      sprite.scale.y = -attachment.scaleY * attachment.height / region.originalHeight;\n    } else {\n      sprite.scale.x = region.size.width / region.originalWidth;\n      sprite.scale.y = -region.size.height / region.originalHeight;\n    }\n  }\n  setMeshRegion(attachment, mesh, region) {\n    if (mesh.attachment === attachment && mesh.region === region) {\n      return;\n    }\n    mesh.region = region;\n    mesh.attachment = attachment;\n    mesh.texture = region.texture;\n    region.texture.updateUvs();\n    mesh.uvBuffer.update(attachment.regionUVs);\n  }\n  /**\n   * When autoupdate is set to yes this function is used as pixi's updateTransform function\n   *\n   * @private\n   */\n  autoUpdateTransform() {\n    if (settings.GLOBAL_AUTO_UPDATE) {\n      this.lastTime = this.lastTime || Date.now();\n      const timeDelta = (Date.now() - this.lastTime) * 1e-3;\n      this.lastTime = Date.now();\n      this.update(timeDelta);\n    } else {\n      this.lastTime = 0;\n    }\n    Container.prototype.updateTransform.call(this);\n  }\n  /**\n   * Create a new sprite to be used with core.RegionAttachment\n   *\n   * @param slot {spine.Slot} The slot to which the attachment is parented\n   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n   * @private\n   */\n  createSprite(slot, attachment, defName) {\n    let region = attachment.region;\n    if (slot.hackAttachment === attachment) {\n      region = slot.hackRegion;\n    }\n    const texture = region ? region.texture : null;\n    const sprite = this.newSprite(texture);\n    sprite.anchor.set(0.5);\n    if (region) {\n      this.setSpriteRegion(attachment, sprite, attachment.region);\n    }\n    slot.sprites = slot.sprites || {};\n    slot.sprites[defName] = sprite;\n    return sprite;\n  }\n  /**\n   * Creates a Strip from the spine data\n   * @param slot {spine.Slot} The slot to which the attachment is parented\n   * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n   * @private\n   */\n  createMesh(slot, attachment) {\n    let region = attachment.region;\n    if (slot.hackAttachment === attachment) {\n      region = slot.hackRegion;\n      slot.hackAttachment = null;\n      slot.hackRegion = null;\n    }\n    const strip = this.newMesh(region ? region.texture : null, new Float32Array(attachment.regionUVs.length), attachment.regionUVs, new Uint16Array(attachment.triangles), DRAW_MODES.TRIANGLES);\n    if (typeof strip._canvasPadding !== \"undefined\") {\n      strip._canvasPadding = 1.5;\n    }\n    strip.alpha = attachment.color.a;\n    strip.region = attachment.region;\n    if (region) {\n      this.setMeshRegion(attachment, strip, region);\n    }\n    slot.meshes = slot.meshes || {};\n    slot.meshes[attachment.id] = strip;\n    return strip;\n  }\n  // @ts-ignore\n  createGraphics(slot, clip) {\n    const graphics = this.newGraphics();\n    const poly = new Polygon([]);\n    graphics.clear();\n    graphics.beginFill(16777215, 1);\n    graphics.drawPolygon(poly);\n    graphics.renderable = false;\n    slot.currentGraphics = graphics;\n    slot.clippingContainer = this.newContainer();\n    slot.clippingContainer.mask = slot.currentGraphics;\n    return graphics;\n  }\n  updateGraphics(slot, clip) {\n    const geom = slot.currentGraphics.geometry;\n    const vertices = geom.graphicsData[0].shape.points;\n    const n = clip.worldVerticesLength;\n    vertices.length = n;\n    clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n    geom.invalidate();\n  }\n  /**\n   * Changes texture in attachment in specific slot.\n   *\n   * PIXI runtime feature, it was made to satisfy our users.\n   *\n   * @param slotIndex {number}\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n   * @returns {boolean} Success flag\n   */\n  hackTextureBySlotIndex(slotIndex, texture = null, size = null) {\n    const slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n      return false;\n    }\n    const attachment = slot.getAttachment();\n    let region = attachment.region;\n    if (texture) {\n      region = new TextureRegion();\n      region.texture = texture;\n      region.size = size;\n      slot.hackRegion = region;\n      slot.hackAttachment = attachment;\n    } else {\n      slot.hackRegion = null;\n      slot.hackAttachment = null;\n    }\n    if (slot.currentSprite) {\n      this.setSpriteRegion(attachment, slot.currentSprite, region);\n    } else if (slot.currentMesh) {\n      this.setMeshRegion(attachment, slot.currentMesh, region);\n    }\n    return true;\n  }\n  /**\n   * Changes texture in attachment in specific slot.\n   *\n   * PIXI runtime feature, it was made to satisfy our users.\n   *\n   * @param slotName {string}\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n   * @returns {boolean} Success flag\n   */\n  hackTextureBySlotName(slotName, texture = null, size = null) {\n    const index = this.skeleton.findSlotIndex(slotName);\n    if (index == -1) {\n      return false;\n    }\n    return this.hackTextureBySlotIndex(index, texture, size);\n  }\n  /**\n   * Changes texture of an attachment\n   *\n   * PIXI runtime feature, it was made to satisfy our users.\n   *\n   * @param slotName {string}\n   * @param attachmentName {string}\n   * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n   * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n   * @returns {boolean} Success flag\n   */\n  hackTextureAttachment(slotName, attachmentName, texture, size = null) {\n    const slotIndex = this.skeleton.findSlotIndex(slotName);\n    const attachment = this.skeleton.getAttachmentByName(slotName, attachmentName);\n    attachment.region.texture = texture;\n    const slot = this.skeleton.slots[slotIndex];\n    if (!slot) {\n      return false;\n    }\n    const currentAttachment = slot.getAttachment();\n    if (attachmentName === currentAttachment.name) {\n      let region = attachment.region;\n      if (texture) {\n        region = new TextureRegion();\n        region.texture = texture;\n        region.size = size;\n        slot.hackRegion = region;\n        slot.hackAttachment = currentAttachment;\n      } else {\n        slot.hackRegion = null;\n        slot.hackAttachment = null;\n      }\n      if (slot.currentSprite && slot.currentSprite.region != region) {\n        this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\n        slot.currentSprite.region = region;\n      } else if (slot.currentMesh && slot.currentMesh.region != region) {\n        this.setMeshRegion(currentAttachment, slot.currentMesh, region);\n      }\n      return true;\n    }\n    return false;\n  }\n  // those methods can be overriden to spawn different classes\n  newContainer() {\n    return new Container();\n  }\n  newSprite(tex) {\n    return new SpineSprite(tex);\n  }\n  newGraphics() {\n    return new Graphics();\n  }\n  newMesh(texture, vertices, uvs, indices, drawMode) {\n    return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n  }\n  transformHack() {\n    return 1;\n  }\n  /**\n   * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\n   * @param nameSuffix\n   * @param group\n   * @param outGroup\n   */\n  hackAttachmentGroups(nameSuffix, group, outGroup) {\n    if (!nameSuffix) {\n      return void 0;\n    }\n    const list_d = [];\n    const list_n = [];\n    for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\n      const slot = this.skeleton.slots[i];\n      const name = slot.currentSpriteName || slot.currentMeshName || \"\";\n      const target = slot.currentSprite || slot.currentMesh;\n      if (name.endsWith(nameSuffix)) {\n        target.parentGroup = group;\n        list_n.push(target);\n      } else if (outGroup && target) {\n        target.parentGroup = outGroup;\n        list_d.push(target);\n      }\n    }\n    return [list_d, list_n];\n  }\n  destroy(options) {\n    this.debug = null;\n    for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n      const slot = this.skeleton.slots[i];\n      for (const name in slot.meshes) {\n        slot.meshes[name].destroy(options);\n      }\n      slot.meshes = null;\n      for (const name in slot.sprites) {\n        slot.sprites[name].destroy(options);\n      }\n      slot.sprites = null;\n    }\n    for (let i = 0, n = this.slotContainers.length; i < n; i++) {\n      this.slotContainers[i].destroy(options);\n    }\n    this.spineData = null;\n    this.skeleton = null;\n    this.slotContainers = null;\n    this.stateData = null;\n    this.state = null;\n    this.tempClipContainers = null;\n    super.destroy(options);\n  }\n};\nlet SpineBase = _SpineBase;\nSpineBase.clippingPolygon = [];\nObject.defineProperty(SpineBase.prototype, \"visible\", {\n  get() {\n    return this._visible;\n  },\n  set(value) {\n    if (value !== this._visible) {\n      this._visible = value;\n      if (value) {\n        this.lastTime = 0;\n      }\n    }\n  }\n});\nexport { SpineBase, SpineMesh, SpineSprite };","map":{"version":3,"names":["tempRgb","SpineSprite","Sprite","constructor","arguments","region","attachment","SpineMesh","SimpleMesh","texture","vertices","uvs","indices","drawMode","_SpineBase","Container","spineData","Error","createSkeleton","slotContainers","tempClipContainers","i","n","skeleton","slots","length","slot","getAttachment","slotContainer","newContainer","push","addChild","type","AttachmentType","Region","spriteName","name","sprite","createSprite","currentSprite","currentSpriteName","Mesh","mesh","createMesh","currentMesh","currentMeshId","id","currentMeshName","Clipping","createGraphics","clippingContainer","currentGraphics","tintRgb","Float32Array","autoUpdate","visible","debug","_debug","value","unregisterSpine","registerSpine","_autoUpdate","updateTransform","prototype","autoUpdateTransform","tint","utils","rgb2hex","hex2rgb","delayLimit","limit","localDelayLimit","settings","GLOBAL_DELAY_LIMIT","Number","MAX_VALUE","update","dt","state","apply","updateWorldTransform","globalClr","color","light","dark","spriteColor","sequence","attColor","transform","setFromMatrix","bone","matrix","renderable","sprites","hackRegion","setSpriteRegion","r","g","b","blendMode","transform2","Transform","_parentID","_worldID","meshId","meshes","computeWorldVerticesOld","setMeshRegion","updateGraphics","alpha","r0","g0","b0","setLight","darkColor","setDark","a","drawOrder","clippingAttachment","data","index","parent","removeChild","children","endSlot","c","renderDebug","rotation","MathUtils","degRad","position","x","y","size","scale","scaleX","width","originalWidth","scaleY","height","originalHeight","updateUvs","uvBuffer","regionUVs","GLOBAL_AUTO_UPDATE","lastTime","Date","now","timeDelta","call","defName","hackAttachment","newSprite","anchor","set","strip","newMesh","Uint16Array","triangles","DRAW_MODES","TRIANGLES","_canvasPadding","clip","graphics","newGraphics","poly","Polygon","clear","beginFill","drawPolygon","mask","geom","geometry","graphicsData","shape","points","worldVerticesLength","computeWorldVertices","invalidate","hackTextureBySlotIndex","slotIndex","TextureRegion","hackTextureBySlotName","slotName","findSlotIndex","hackTextureAttachment","attachmentName","getAttachmentByName","currentAttachment","tex","Graphics","transformHack","hackAttachmentGroups","nameSuffix","group","outGroup","list_d","list_n","len","target","endsWith","parentGroup","destroy","options","stateData","SpineBase","clippingPolygon","Object","defineProperty","get","_visible"],"sources":["../src/SpineBase.ts"],"sourcesContent":["import { AttachmentType } from './core/AttachmentType';\nimport { TextureRegion } from './core/TextureRegion';\nimport { MathUtils } from './core/Utils';\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\nimport type { IAttachment, IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, ISlot, IVertexAttachment } from './core/ISkeleton';\nimport { DRAW_MODES, Rectangle, Polygon, Transform, Texture, utils } from '@pixi/core';\nimport { Container, DisplayObject } from '@pixi/display';\nimport { Sprite } from '@pixi/sprite';\nimport { SimpleMesh } from '@pixi/mesh-extras';\nimport { Graphics } from '@pixi/graphics';\nimport { settings } from './settings';\nimport type { ISpineDebugRenderer } from './SpineDebugRenderer';\n\nconst tempRgb = [0, 0, 0];\n\n/**\n * @public\n */\nexport interface ISpineDisplayObject extends DisplayObject {\n    region?: TextureRegion;\n    attachment?: IAttachment;\n}\n\n/**\n * @public\n */\nexport class SpineSprite extends Sprite implements ISpineDisplayObject {\n    region?: TextureRegion = null;\n    attachment?: IAttachment = null;\n}\n\n/**\n * @public\n */\nexport class SpineMesh extends SimpleMesh implements ISpineDisplayObject {\n    region?: TextureRegion = null;\n    attachment?: IAttachment = null;\n\n    constructor(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n        super(texture, vertices, uvs, indices, drawMode);\n    }\n}\n\n/**\n * A class that enables the you to import and run your spine animations in pixi.\n * The Spine animation data needs to be loaded using either the Loader or a SpineLoader before it can be used by this class\n * See example 12 (http://www.goodboydigital.com/pixijs/examples/12/) to see a working example and check out the source\n *\n * ```js\n * let spineAnimation = new spine(spineData);\n * ```\n *\n * @public\n * @class\n * @extends Container\n * @memberof spine\n * @param spineData {object} The spine data loaded from a spine atlas.\n */\nexport abstract class SpineBase<\n        Skeleton extends ISkeleton,\n        SkeletonData extends ISkeletonData,\n        AnimationState extends IAnimationState,\n        AnimationStateData extends IAnimationStateData\n    >\n    extends Container\n    implements GlobalMixins.Spine\n{\n    tintRgb: ArrayLike<number>;\n    spineData: SkeletonData;\n    skeleton: Skeleton;\n    stateData: AnimationStateData;\n    state: AnimationState;\n    slotContainers: Array<Container>;\n    tempClipContainers: Array<Container>;\n    localDelayLimit: number;\n    private _autoUpdate: boolean;\n    protected _visible: boolean;\n    private _debug: ISpineDebugRenderer;\n    public get debug(): ISpineDebugRenderer {\n        return this._debug;\n    }\n    public set debug(value: ISpineDebugRenderer) {\n        if (value == this._debug) {\n            // soft equality allows null == undefined\n            return;\n        }\n        this._debug?.unregisterSpine(this);\n        value?.registerSpine(this);\n        this._debug = value;\n    }\n\n    abstract createSkeleton(spineData: ISkeletonData);\n\n    constructor(spineData: SkeletonData) {\n        super();\n\n        if (!spineData) {\n            throw new Error('The spineData param is required.');\n        }\n\n        if (typeof spineData === 'string') {\n            throw new Error('spineData param cant be string. Please use spine.Spine.fromAtlas(\"YOUR_RESOURCE_NAME\") from now on.');\n        }\n\n        /**\n         * The spineData object\n         *\n         * @member {object}\n         */\n        this.spineData = spineData;\n\n        /**\n         * A spine Skeleton object\n         *\n         * @member {object}\n         */\n        this.createSkeleton(spineData);\n\n        /**\n         * An array of containers\n         *\n         * @member {Container[]}\n         */\n        this.slotContainers = [];\n\n        this.tempClipContainers = [];\n\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            const slot = this.skeleton.slots[i];\n            const attachment: any = slot.getAttachment();\n            const slotContainer = this.newContainer();\n\n            this.slotContainers.push(slotContainer);\n            this.addChild(slotContainer);\n            this.tempClipContainers.push(null);\n\n            if (!attachment) {\n                continue;\n            }\n            if (attachment.type === AttachmentType.Region) {\n                const spriteName = attachment.name;\n                const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\n\n                slot.currentSprite = sprite;\n                slot.currentSpriteName = spriteName;\n                slotContainer.addChild(sprite);\n            } else if (attachment.type === AttachmentType.Mesh) {\n                const mesh = this.createMesh(slot, attachment);\n\n                slot.currentMesh = mesh;\n                slot.currentMeshId = attachment.id;\n                slot.currentMeshName = attachment.name;\n                slotContainer.addChild(mesh);\n            } else if (attachment.type === AttachmentType.Clipping) {\n                this.createGraphics(slot, attachment);\n                slotContainer.addChild(slot.clippingContainer);\n                slotContainer.addChild(slot.currentGraphics);\n            }\n        }\n\n        /**\n         * The tint applied to all spine slots. This is a [r,g,b] value. A value of [1,1,1] will remove any tint effect.\n         *\n         * @member {number}\n         * @memberof spine.Spine#\n         */\n        this.tintRgb = new Float32Array([1, 1, 1]);\n\n        this.autoUpdate = true;\n        this.visible = true;\n    }\n\n    /**\n     * If this flag is set to true, the spine animation will be automatically updated every\n     * time the object id drawn. The down side of this approach is that the delta time is\n     * automatically calculated and you could miss out on cool effects like slow motion,\n     * pause, skip ahead and the sorts. Most of these effects can be achieved even with\n     * autoUpdate enabled but are harder to achieve.\n     *\n     * @member {boolean}\n     * @memberof spine.Spine#\n     * @default true\n     */\n    get autoUpdate(): boolean {\n        return this._autoUpdate;\n    }\n\n    set autoUpdate(value: boolean) {\n        if (value !== this._autoUpdate) {\n            this._autoUpdate = value;\n            this.updateTransform = value ? SpineBase.prototype.autoUpdateTransform : Container.prototype.updateTransform;\n        }\n    }\n\n    /**\n     * The tint applied to the spine object. This is a hex value. A value of 0xFFFFFF will remove any tint effect.\n     *\n     * @member {number}\n     * @memberof spine.Spine#\n     * @default 0xFFFFFF\n     */\n    get tint(): number {\n        return utils.rgb2hex(this.tintRgb as any);\n    }\n\n    set tint(value: number) {\n        this.tintRgb = utils.hex2rgb(value, this.tintRgb as any);\n    }\n\n    /**\n     * Limit value for the update dt with Spine.globalDelayLimit\n     * that can be overridden with localDelayLimit\n     * @return {number} - Maximum processed dt value for the update\n     */\n    get delayLimit(): number {\n        const limit = typeof this.localDelayLimit !== 'undefined' ? this.localDelayLimit : settings.GLOBAL_DELAY_LIMIT;\n\n        // If limit is 0, this means there is no limit for the delay\n        return limit || Number.MAX_VALUE;\n    }\n\n    /**\n     * Update the spine skeleton and its animations by delta time (dt)\n     *\n     * @param dt {number} Delta time. Time by which the animation should be updated\n     */\n    update(dt: number) {\n        // Limit delta value to avoid animation jumps\n        const delayLimit = this.delayLimit;\n\n        if (dt > delayLimit) dt = delayLimit;\n\n        this.state.update(dt);\n        this.state.apply(this.skeleton);\n\n        // check we haven't been destroyed via a spine event callback in state update\n        if (!this.skeleton) {\n            return;\n        }\n\n        this.skeleton.updateWorldTransform();\n\n        const slots = this.skeleton.slots;\n\n        // in case pixi has double tint\n        const globalClr = (this as any).color;\n        let light: ArrayLike<number> = null;\n        let dark: ArrayLike<number> = null;\n\n        if (globalClr) {\n            light = globalClr.light;\n            dark = globalClr.dark;\n        } else {\n            light = this.tintRgb;\n        }\n\n        // let thack = false;\n\n        for (let i = 0, n = slots.length; i < n; i++) {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n            const slotContainer = this.slotContainers[i];\n\n            if (!attachment) {\n                slotContainer.visible = false;\n                continue;\n            }\n\n            let spriteColor: any = null;\n\n            if (attachment.sequence) {\n                attachment.sequence.apply(slot, attachment as any);\n            }\n            let region = (attachment as IRegionAttachment).region;\n\n            const attColor = (attachment as any).color;\n\n            switch (attachment != null && attachment.type) {\n                case AttachmentType.Region:\n                    const transform = slotContainer.transform;\n\n                    transform.setFromMatrix(slot.bone.matrix);\n\n                    region = (attachment as IRegionAttachment).region;\n                    if (slot.currentMesh) {\n                        slot.currentMesh.visible = false;\n                        slot.currentMesh = null;\n                        slot.currentMeshId = undefined;\n                        slot.currentMeshName = undefined;\n                    }\n                    if (!region) {\n                        if (slot.currentSprite) {\n                            slot.currentSprite.renderable = false;\n                        }\n                        break;\n                    }\n                    if (!slot.currentSpriteName || slot.currentSpriteName !== attachment.name) {\n                        const spriteName = attachment.name;\n\n                        if (slot.currentSprite) {\n                            slot.currentSprite.visible = false;\n                        }\n                        slot.sprites = slot.sprites || {};\n                        if (slot.sprites[spriteName] !== undefined) {\n                            slot.sprites[spriteName].visible = true;\n                        } else {\n                            const sprite = this.createSprite(slot, attachment as IRegionAttachment, spriteName);\n\n                            slotContainer.addChild(sprite);\n                        }\n                        slot.currentSprite = slot.sprites[spriteName];\n                        slot.currentSpriteName = spriteName;\n\n                        // force sprite update when attachment name is same.\n                        // issues https://github.com/pixijs/pixi-spine/issues/318\n                    }\n                    slot.currentSprite.renderable = true;\n                    if (!slot.hackRegion) {\n                        this.setSpriteRegion(attachment as IRegionAttachment, slot.currentSprite, region);\n                    }\n                    if (slot.currentSprite.color) {\n                        // YAY! double - tint!\n                        spriteColor = slot.currentSprite.color;\n                    } else {\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\n                        slot.currentSprite.tint = utils.rgb2hex(tempRgb);\n                    }\n                    slot.currentSprite.blendMode = slot.blendMode;\n                    break;\n\n                case AttachmentType.Mesh:\n                    if (slot.currentSprite) {\n                        // TODO: refactor this thing, switch it on and off for container\n                        slot.currentSprite.visible = false;\n                        slot.currentSprite = null;\n                        slot.currentSpriteName = undefined;\n\n                        // TODO: refactor this shit\n                        const transform = new Transform();\n\n                        (transform as any)._parentID = -1;\n                        (transform as any)._worldID = (slotContainer.transform as any)._worldID;\n                        slotContainer.transform = transform;\n                    }\n                    if (!region) {\n                        if (slot.currentMesh) {\n                            slot.currentMesh.renderable = false;\n                        }\n                        break;\n                    }\n\n                    const id = (attachment as IVertexAttachment).id;\n\n                    if (slot.currentMeshId === undefined || slot.currentMeshId !== id) {\n                        const meshId = id;\n\n                        if (slot.currentMesh) {\n                            slot.currentMesh.visible = false;\n                        }\n\n                        slot.meshes = slot.meshes || {};\n\n                        if (slot.meshes[meshId] !== undefined) {\n                            slot.meshes[meshId].visible = true;\n                        } else {\n                            const mesh = this.createMesh(slot, attachment as IMeshAttachment);\n\n                            slotContainer.addChild(mesh);\n                        }\n\n                        slot.currentMesh = slot.meshes[meshId];\n                        slot.currentMeshName = attachment.name;\n                        slot.currentMeshId = meshId;\n                    }\n                    slot.currentMesh.renderable = true;\n                    (attachment as IVertexAttachment).computeWorldVerticesOld(slot, slot.currentMesh.vertices);\n                    if (slot.currentMesh.color) {\n                        // pixi-heaven\n                        spriteColor = slot.currentMesh.color;\n                    } else {\n                        tempRgb[0] = light[0] * slot.color.r * attColor.r;\n                        tempRgb[1] = light[1] * slot.color.g * attColor.g;\n                        tempRgb[2] = light[2] * slot.color.b * attColor.b;\n                        slot.currentMesh.tint = utils.rgb2hex(tempRgb);\n                    }\n                    slot.currentMesh.blendMode = slot.blendMode;\n                    if (!slot.hackRegion) {\n                        this.setMeshRegion(attachment as IMeshAttachment, slot.currentMesh, region);\n                    }\n                    break;\n                case AttachmentType.Clipping:\n                    if (!slot.currentGraphics) {\n                        this.createGraphics(slot, attachment as IClippingAttachment);\n                        slotContainer.addChild(slot.clippingContainer);\n                        slotContainer.addChild(slot.currentGraphics);\n                    }\n                    this.updateGraphics(slot, attachment as IClippingAttachment);\n                    slotContainer.alpha = 1.0;\n                    slotContainer.visible = true;\n                    continue;\n                default:\n                    slotContainer.visible = false;\n                    continue;\n            }\n            slotContainer.visible = true;\n\n            // pixi has double tint\n            if (spriteColor) {\n                let r0 = slot.color.r * attColor.r;\n                let g0 = slot.color.g * attColor.g;\n                let b0 = slot.color.b * attColor.b;\n\n                // YAY! double-tint!\n                spriteColor.setLight(light[0] * r0 + dark[0] * (1.0 - r0), light[1] * g0 + dark[1] * (1.0 - g0), light[2] * b0 + dark[2] * (1.0 - b0));\n                if (slot.darkColor) {\n                    r0 = slot.darkColor.r;\n                    g0 = slot.darkColor.g;\n                    b0 = slot.darkColor.b;\n                } else {\n                    r0 = 0.0;\n                    g0 = 0.0;\n                    b0 = 0.0;\n                }\n                spriteColor.setDark(light[0] * r0 + dark[0] * (1 - r0), light[1] * g0 + dark[1] * (1 - g0), light[2] * b0 + dark[2] * (1 - b0));\n            }\n\n            slotContainer.alpha = slot.color.a;\n        }\n\n        // == this is clipping implementation ===\n        // TODO: remove parent hacks when pixi masks allow it\n        const drawOrder = this.skeleton.drawOrder;\n        let clippingAttachment: IClippingAttachment = null;\n        let clippingContainer: Container = null;\n\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\n            const slot = slots[drawOrder[i].data.index];\n            const slotContainer = this.slotContainers[drawOrder[i].data.index];\n\n            if (!clippingContainer) {\n                // Adding null check as it is possible for slotContainer.parent to be null in the event of a spine being disposed off in its loop callback\n                if (slotContainer.parent !== null && slotContainer.parent !== this) {\n                    slotContainer.parent.removeChild(slotContainer);\n                    // silend add hack\n                    (slotContainer as any).parent = this;\n                }\n            }\n            if (slot.currentGraphics && slot.getAttachment()) {\n                clippingContainer = slot.clippingContainer;\n                clippingAttachment = slot.getAttachment() as IClippingAttachment;\n                clippingContainer.children.length = 0;\n                this.children[i] = slotContainer;\n\n                if (clippingAttachment.endSlot === slot.data) {\n                    clippingAttachment.endSlot = null;\n                }\n            } else if (clippingContainer) {\n                let c = this.tempClipContainers[i];\n\n                if (!c) {\n                    c = this.tempClipContainers[i] = this.newContainer();\n                    c.visible = false;\n                }\n                this.children[i] = c;\n\n                // silent remove hack\n                (slotContainer as any).parent = null;\n                clippingContainer.addChild(slotContainer);\n                if (clippingAttachment.endSlot == slot.data) {\n                    clippingContainer.renderable = true;\n                    clippingContainer = null;\n                    clippingAttachment = null;\n                }\n            } else {\n                this.children[i] = slotContainer;\n            }\n        }\n\n        // if you can debug, then debug!\n        this._debug?.renderDebug(this);\n    }\n\n    private setSpriteRegion(attachment: IRegionAttachment, sprite: SpineSprite, region: TextureRegion) {\n        // prevent setters calling when attachment and region is same\n        if (sprite.attachment === attachment && sprite.region === region) {\n            return;\n        }\n\n        sprite.region = region;\n        sprite.attachment = attachment;\n\n        sprite.texture = region.texture;\n        sprite.rotation = attachment.rotation * MathUtils.degRad;\n        sprite.position.x = attachment.x;\n        sprite.position.y = attachment.y;\n        sprite.alpha = attachment.color.a;\n\n        if (!region.size) {\n            sprite.scale.x = (attachment.scaleX * attachment.width) / region.originalWidth;\n            sprite.scale.y = (-attachment.scaleY * attachment.height) / region.originalHeight;\n        } else {\n            // hacked!\n            sprite.scale.x = region.size.width / region.originalWidth;\n            sprite.scale.y = -region.size.height / region.originalHeight;\n        }\n    }\n\n    private setMeshRegion(attachment: IMeshAttachment, mesh: SpineMesh, region: TextureRegion) {\n        if (mesh.attachment === attachment && mesh.region === region) {\n            return;\n        }\n\n        mesh.region = region;\n        mesh.attachment = attachment;\n        mesh.texture = region.texture;\n        region.texture.updateUvs();\n        mesh.uvBuffer.update(attachment.regionUVs);\n    }\n\n    protected lastTime: number;\n\n    /**\n     * When autoupdate is set to yes this function is used as pixi's updateTransform function\n     *\n     * @private\n     */\n    autoUpdateTransform() {\n        if (settings.GLOBAL_AUTO_UPDATE) {\n            this.lastTime = this.lastTime || Date.now();\n            const timeDelta = (Date.now() - this.lastTime) * 0.001;\n\n            this.lastTime = Date.now();\n            this.update(timeDelta);\n        } else {\n            this.lastTime = 0;\n        }\n\n        Container.prototype.updateTransform.call(this);\n    }\n\n    /**\n     * Create a new sprite to be used with core.RegionAttachment\n     *\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createSprite(slot: ISlot, attachment: IRegionAttachment, defName: string) {\n        let region = attachment.region;\n\n        if (slot.hackAttachment === attachment) {\n            region = slot.hackRegion;\n        }\n        const texture = region ? region.texture : null;\n        const sprite = this.newSprite(texture);\n\n        sprite.anchor.set(0.5);\n        if (region) {\n            this.setSpriteRegion(attachment, sprite, attachment.region);\n        }\n\n        slot.sprites = slot.sprites || {};\n        slot.sprites[defName] = sprite;\n\n        return sprite;\n    }\n\n    /**\n     * Creates a Strip from the spine data\n     * @param slot {spine.Slot} The slot to which the attachment is parented\n     * @param attachment {spine.RegionAttachment} The attachment that the sprite will represent\n     * @private\n     */\n    createMesh(slot: ISlot, attachment: IMeshAttachment) {\n        let region = attachment.region;\n\n        if (slot.hackAttachment === attachment) {\n            region = slot.hackRegion;\n            slot.hackAttachment = null;\n            slot.hackRegion = null;\n        }\n        const strip = this.newMesh(\n            region ? region.texture : null,\n            new Float32Array(attachment.regionUVs.length),\n            attachment.regionUVs,\n            new Uint16Array(attachment.triangles),\n            DRAW_MODES.TRIANGLES\n        );\n\n        if (typeof (strip as any)._canvasPadding !== 'undefined') {\n            (strip as any)._canvasPadding = 1.5;\n        }\n\n        strip.alpha = attachment.color.a;\n\n        strip.region = attachment.region;\n        if (region) {\n            this.setMeshRegion(attachment, strip, region);\n        }\n\n        slot.meshes = slot.meshes || {};\n        slot.meshes[attachment.id] = strip;\n\n        return strip;\n    }\n\n    static clippingPolygon: Array<number> = [];\n\n    // @ts-ignore\n    createGraphics(slot: ISlot, clip: IClippingAttachment) {\n        const graphics = this.newGraphics();\n        const poly = new Polygon([]);\n\n        graphics.clear();\n        graphics.beginFill(0xffffff, 1);\n        graphics.drawPolygon(poly as any);\n        graphics.renderable = false;\n        slot.currentGraphics = graphics;\n        slot.clippingContainer = this.newContainer();\n        slot.clippingContainer.mask = slot.currentGraphics;\n\n        return graphics;\n    }\n\n    updateGraphics(slot: ISlot, clip: IClippingAttachment) {\n        const geom = slot.currentGraphics.geometry;\n        const vertices = (geom.graphicsData[0].shape as Polygon).points;\n        const n = clip.worldVerticesLength;\n\n        vertices.length = n;\n        clip.computeWorldVertices(slot, 0, n, vertices, 0, 2);\n        geom.invalidate();\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotIndex {number}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotIndex(slotIndex: number, texture: Texture = null, size: Rectangle = null) {\n        const slot = this.skeleton.slots[slotIndex];\n\n        if (!slot) {\n            return false;\n        }\n        const attachment: any = slot.getAttachment();\n        let region: TextureRegion = attachment.region;\n\n        if (texture) {\n            region = new TextureRegion();\n            region.texture = texture;\n            region.size = size;\n            slot.hackRegion = region;\n            slot.hackAttachment = attachment;\n        } else {\n            slot.hackRegion = null;\n            slot.hackAttachment = null;\n        }\n        if (slot.currentSprite) {\n            this.setSpriteRegion(attachment, slot.currentSprite, region);\n        } else if (slot.currentMesh) {\n            this.setMeshRegion(attachment, slot.currentMesh, region);\n        }\n\n        return true;\n    }\n\n    /**\n     * Changes texture in attachment in specific slot.\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureBySlotName(slotName: string, texture: Texture = null, size: Rectangle = null) {\n        const index = this.skeleton.findSlotIndex(slotName);\n\n        if (index == -1) {\n            return false;\n        }\n\n        return this.hackTextureBySlotIndex(index, texture, size);\n    }\n\n    /**\n     * Changes texture of an attachment\n     *\n     * PIXI runtime feature, it was made to satisfy our users.\n     *\n     * @param slotName {string}\n     * @param attachmentName {string}\n     * @param [texture = null] {PIXI.Texture} If null, take default (original) texture\n     * @param [size = null] {PIXI.Point} sometimes we need new size for region attachment, you can pass 'texture.orig' there\n     * @returns {boolean} Success flag\n     */\n    hackTextureAttachment(slotName: string, attachmentName: string, texture, size: Rectangle = null) {\n        // changes the texture of an attachment at the skeleton level\n        const slotIndex = this.skeleton.findSlotIndex(slotName);\n        const attachment: any = this.skeleton.getAttachmentByName(slotName, attachmentName);\n\n        attachment.region.texture = texture;\n\n        const slot = this.skeleton.slots[slotIndex];\n\n        if (!slot) {\n            return false;\n        }\n\n        // gets the currently active attachment in this slot\n        const currentAttachment: any = slot.getAttachment();\n\n        if (attachmentName === currentAttachment.name) {\n            // if the attachment we are changing is currently active, change the the live texture\n            let region: TextureRegion = attachment.region;\n\n            if (texture) {\n                region = new TextureRegion();\n                region.texture = texture;\n                region.size = size;\n                slot.hackRegion = region;\n                slot.hackAttachment = currentAttachment;\n            } else {\n                slot.hackRegion = null;\n                slot.hackAttachment = null;\n            }\n            if (slot.currentSprite && slot.currentSprite.region != region) {\n                this.setSpriteRegion(currentAttachment, slot.currentSprite, region);\n                slot.currentSprite.region = region;\n            } else if (slot.currentMesh && slot.currentMesh.region != region) {\n                this.setMeshRegion(currentAttachment, slot.currentMesh, region);\n            }\n\n            return true;\n        }\n\n        return false;\n    }\n\n    // those methods can be overriden to spawn different classes\n    newContainer() {\n        return new Container();\n    }\n\n    newSprite(tex: Texture) {\n        return new SpineSprite(tex);\n    }\n\n    newGraphics() {\n        return new Graphics();\n    }\n\n    newMesh(texture: Texture, vertices?: Float32Array, uvs?: Float32Array, indices?: Uint16Array, drawMode?: number) {\n        return new SpineMesh(texture, vertices, uvs, indices, drawMode);\n    }\n\n    transformHack() {\n        return 1;\n    }\n\n    /**\n     * Hack for pixi-display and pixi-lights. Every attachment name ending with a suffix will be added to different layer\n     * @param nameSuffix\n     * @param group\n     * @param outGroup\n     */\n    hackAttachmentGroups(nameSuffix: string, group: any, outGroup: any) {\n        if (!nameSuffix) {\n            return undefined;\n        }\n        const list_d = [];\n        const list_n = [];\n\n        for (let i = 0, len = this.skeleton.slots.length; i < len; i++) {\n            const slot = this.skeleton.slots[i];\n            const name = slot.currentSpriteName || slot.currentMeshName || '';\n            const target = slot.currentSprite || slot.currentMesh;\n\n            if (name.endsWith(nameSuffix)) {\n                target.parentGroup = group;\n                list_n.push(target);\n            } else if (outGroup && target) {\n                target.parentGroup = outGroup;\n                list_d.push(target);\n            }\n        }\n\n        return [list_d, list_n];\n    }\n\n    destroy(options?: any): void {\n        this.debug = null; // setter will do the cleanup\n\n        for (let i = 0, n = this.skeleton.slots.length; i < n; i++) {\n            const slot = this.skeleton.slots[i];\n\n            for (const name in slot.meshes) {\n                slot.meshes[name].destroy(options);\n            }\n            slot.meshes = null;\n\n            for (const name in slot.sprites) {\n                slot.sprites[name].destroy(options);\n            }\n            slot.sprites = null;\n        }\n\n        for (let i = 0, n = this.slotContainers.length; i < n; i++) {\n            this.slotContainers[i].destroy(options);\n        }\n        this.spineData = null;\n        this.skeleton = null;\n        this.slotContainers = null;\n        this.stateData = null;\n        this.state = null;\n        this.tempClipContainers = null;\n\n        super.destroy(options);\n    }\n}\n\n/**\n * The visibility of the spine object. If false the object will not be drawn,\n * the updateTransform function will not be called, and the spine will not be automatically updated.\n *\n * @member {boolean}\n * @memberof spine.Spine#\n * @default true\n */\nObject.defineProperty(SpineBase.prototype, 'visible', {\n    get() {\n        return this._visible;\n    },\n    set(value: boolean) {\n        if (value !== this._visible) {\n            this._visible = value;\n            if (value) {\n                this.lastTime = 0;\n            }\n        }\n    },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}