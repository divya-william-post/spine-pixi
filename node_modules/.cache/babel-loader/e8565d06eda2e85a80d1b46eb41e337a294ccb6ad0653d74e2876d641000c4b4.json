{"ast":null,"code":"var __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nclass BatchableSpineSlot {\n  constructor() {\n    __publicField(this, \"indexStart\");\n    __publicField(this, \"textureId\");\n    __publicField(this, \"texture\");\n    __publicField(this, \"location\");\n    __publicField(this, \"batcher\");\n    __publicField(this, \"batch\");\n    __publicField(this, \"renderable\");\n    __publicField(this, \"vertices\");\n    __publicField(this, \"indices\");\n    __publicField(this, \"uvs\");\n    __publicField(this, \"indexSize\");\n    __publicField(this, \"vertexSize\");\n    __publicField(this, \"roundPixels\");\n    __publicField(this, \"data\");\n    __publicField(this, \"blendMode\");\n  }\n  setData(renderable, data, texture, blendMode, roundPixels) {\n    this.renderable = renderable;\n    this.data = data;\n    if (data.clipped) {\n      const clippedData = data.clippedData;\n      this.indexSize = clippedData.indicesCount;\n      this.vertexSize = clippedData.vertexCount;\n      this.vertices = clippedData.vertices;\n      this.indices = clippedData.indices;\n      this.uvs = clippedData.uvs;\n    } else {\n      this.indexSize = data.indices.length;\n      this.vertexSize = data.vertices.length / 2;\n      this.vertices = data.vertices;\n      this.indices = data.indices;\n      this.uvs = data.uvs;\n    }\n    this.texture = texture;\n    this.roundPixels = roundPixels;\n    this.blendMode = blendMode;\n  }\n  packIndex(indexBuffer, index, indicesOffset) {\n    const indices = this.indices;\n    for (let i = 0; i < indices.length; i++) {\n      indexBuffer[index++] = indices[i] + indicesOffset;\n    }\n  }\n  packAttributes(float32View, uint32View, index, textureId) {\n    const {\n      uvs,\n      vertices,\n      vertexSize\n    } = this;\n    const slotColor = this.data.color;\n    const parentColor = this.renderable.groupColor;\n    const parentAlpha = this.renderable.groupAlpha;\n    let abgr;\n    const mixedA = slotColor.a * parentAlpha * 255;\n    if (parentColor !== 16777215) {\n      const parentB = parentColor >> 16 & 255;\n      const parentG = parentColor >> 8 & 255;\n      const parentR = parentColor & 255;\n      const mixedR = slotColor.r * parentR * 255;\n      const mixedG = slotColor.g * parentG * 255;\n      const mixedB = slotColor.b * parentB * 255;\n      abgr = mixedA << 24 | mixedB << 16 | mixedG << 8 | mixedR;\n    } else {\n      abgr = mixedA << 24 | slotColor.b * 255 << 16 | slotColor.g * 255 << 8 | slotColor.r * 255;\n    }\n    const matrix = this.renderable.groupTransform;\n    const a = matrix.a;\n    const b = matrix.b;\n    const c = matrix.c;\n    const d = matrix.d;\n    const tx = matrix.tx;\n    const ty = matrix.ty;\n    const textureIdAndRound = textureId << 16 | this.roundPixels & 65535;\n    for (let i = 0; i < vertexSize; i++) {\n      const x = vertices[i * 2];\n      const y = vertices[i * 2 + 1];\n      float32View[index++] = a * x + c * y + tx;\n      float32View[index++] = b * x + d * y + ty;\n      float32View[index++] = uvs[i * 2];\n      float32View[index++] = uvs[i * 2 + 1];\n      uint32View[index++] = abgr;\n      uint32View[index++] = textureIdAndRound;\n    }\n  }\n}\nexport { BatchableSpineSlot };","map":{"version":3,"names":["BatchableSpineSlot","constructor","__publicField","setData","renderable","data","texture","blendMode","roundPixels","clipped","clippedData","indexSize","indicesCount","vertexSize","vertexCount","vertices","indices","uvs","length","packIndex","indexBuffer","index","indicesOffset","i","packAttributes","float32View","uint32View","textureId","slotColor","color","parentColor","groupColor","parentAlpha","groupAlpha","abgr","mixedA","a","parentB","parentG","parentR","mixedR","r","mixedG","g","mixedB","b","matrix","groupTransform","c","d","tx","ty","textureIdAndRound","x","y"],"sources":["../src/BatchableSpineSlot.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { AttachmentCacheData, Spine } from './Spine';\n\nimport type { Batch, BatchableObject, Batcher, BLEND_MODES, IndexBufferArray, Texture } from 'pixi.js';\n\nexport class BatchableSpineSlot implements BatchableObject\n{\n    indexStart: number;\n    textureId: number;\n    texture: Texture;\n    location: number;\n    batcher: Batcher;\n    batch: Batch;\n    renderable: Spine;\n\n    vertices: Float32Array;\n    indices: number[] | Uint16Array;\n    uvs: Float32Array;\n\n    indexSize: number;\n    vertexSize: number;\n\n    roundPixels: 0 | 1;\n    data: AttachmentCacheData;\n    blendMode: BLEND_MODES;\n\n    setData(\n        renderable:Spine,\n        data:AttachmentCacheData,\n        texture:Texture,\n        blendMode:BLEND_MODES,\n        roundPixels: 0 | 1)\n    {\n        this.renderable = renderable;\n        this.data = data;\n\n        if (data.clipped)\n        {\n            const clippedData = data.clippedData;\n\n            this.indexSize = clippedData.indicesCount;\n            this.vertexSize = clippedData.vertexCount;\n            this.vertices = clippedData.vertices;\n            this.indices = clippedData.indices;\n            this.uvs = clippedData.uvs;\n        }\n        else\n        {\n            this.indexSize = data.indices.length;\n            this.vertexSize = data.vertices.length / 2;\n            this.vertices = data.vertices;\n            this.indices = data.indices;\n            this.uvs = data.uvs;\n        }\n\n        this.texture = texture;\n        this.roundPixels = roundPixels;\n\n        this.blendMode = blendMode;\n    }\n\n    packIndex(indexBuffer: IndexBufferArray, index: number, indicesOffset: number)\n    {\n        const indices = this.indices;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indexBuffer[index++] = indices[i] + indicesOffset;\n        }\n    }\n\n    packAttributes(\n        float32View: Float32Array,\n        uint32View: Uint32Array,\n        index: number,\n        textureId: number\n    )\n    {\n        const { uvs, vertices, vertexSize } = this;\n\n        const slotColor = this.data.color;\n\n        const parentColor:number = this.renderable.groupColor;\n        const parentAlpha:number = this.renderable.groupAlpha;\n\n        let abgr:number;\n\n        const mixedA = (slotColor.a * parentAlpha) * 255;\n\n        if (parentColor !== 0xFFFFFF)\n        {\n            const parentB = (parentColor >> 16) & 0xFF;\n            const parentG = (parentColor >> 8) & 0xFF;\n            const parentR = parentColor & 0xFF;\n\n            const mixedR = (slotColor.r * parentR) * 255;\n            const mixedG = (slotColor.g * parentG) * 255;\n            const mixedB = (slotColor.b * parentB) * 255;\n\n            abgr = ((mixedA) << 24) | (mixedB << 16) | (mixedG << 8) | mixedR;\n        }\n        else\n        {\n            abgr = ((mixedA) << 24) | ((slotColor.b * 255) << 16) | ((slotColor.g * 255) << 8) | (slotColor.r * 255);\n        }\n\n        const matrix = this.renderable.groupTransform;\n\n        const a = matrix.a;\n        const b = matrix.b;\n        const c = matrix.c;\n        const d = matrix.d;\n        const tx = matrix.tx;\n        const ty = matrix.ty;\n\n        const textureIdAndRound = (textureId << 16) | (this.roundPixels & 0xFFFF);\n\n        for (let i = 0; i < vertexSize; i++)\n        {\n            const x = vertices[i * 2];\n            const y = vertices[(i * 2) + 1];\n\n            float32View[index++] = (a * x) + (c * y) + tx;\n            float32View[index++] = (b * x) + (d * y) + ty;\n\n            // uv\n            float32View[index++] = uvs[i * 2];\n            float32View[index++] = uvs[(i * 2) + 1];\n\n            // color\n            uint32View[index++] = abgr;\n\n            // texture id\n            uint32View[index++] = textureIdAndRound;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}