{"ast":null,"code":"import \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Container, Bounds, Ticker, DEG_TO_RAD, Cache, Assets } from 'pixi.js';\nimport { Vector2, Color, Skeleton, SkeletonClipping, SkeletonData, AnimationState, AnimationStateData, MeshAttachment, RegionAttachment, ClippingAttachment, SkeletonBounds, AtlasAttachmentLoader, SkeletonBinary, SkeletonJson } from '@esotericsoftware/spine-core';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst vectorAux = new Vector2();\nconst lightColor = new Color();\nconst darkColor = new Color();\nSkeleton.yDown = true;\nconst clipper = new SkeletonClipping();\nclass Spine extends Container {\n  constructor(options) {\n    if (options instanceof SkeletonData) {\n      options = {\n        skeletonData: options\n      };\n    }\n    super();\n    // Pixi properties\n    __publicField(this, \"batched\", true);\n    __publicField(this, \"buildId\", 0);\n    __publicField(this, \"renderPipeId\", \"spine\");\n    __publicField(this, \"_didSpineUpdate\", false);\n    __publicField(this, \"_boundsDirty\", true);\n    __publicField(this, \"_roundPixels\");\n    __publicField(this, \"_bounds\", new Bounds());\n    // Spine properties\n    __publicField(this, \"skeleton\");\n    __publicField(this, \"state\");\n    __publicField(this, \"skeletonBounds\");\n    __publicField(this, \"_debug\");\n    __publicField(this, \"_slotsObject\", /* @__PURE__ */Object.create(null));\n    __publicField(this, \"spineAttachmentsDirty\");\n    __publicField(this, \"_lastAttachments\");\n    __publicField(this, \"_stateChanged\");\n    __publicField(this, \"attachmentCacheData\", {});\n    __publicField(this, \"autoUpdateWarned\", false);\n    __publicField(this, \"_autoUpdate\", true);\n    const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;\n    this.skeleton = new Skeleton(skeletonData);\n    this.state = new AnimationState(new AnimationStateData(skeletonData));\n    this.autoUpdate = options?.autoUpdate ?? true;\n    this._updateState(0);\n  }\n  getSlotFromRef(slotRef) {\n    let slot;\n    if (typeof slotRef === \"number\") slot = this.skeleton.slots[slotRef];else if (typeof slotRef === \"string\") slot = this.skeleton.findSlot(slotRef);else slot = slotRef;\n    if (!slot) throw new Error(`No slot found with the given slot reference: ${slotRef}`);\n    return slot;\n  }\n  get debug() {\n    return this._debug;\n  }\n  set debug(value) {\n    if (this._debug) {\n      this._debug.unregisterSpine(this);\n    }\n    if (value) {\n      value.registerSpine(this);\n    }\n    this._debug = value;\n  }\n  get autoUpdate() {\n    return this._autoUpdate;\n  }\n  set autoUpdate(value) {\n    if (value) {\n      Ticker.shared.add(this.internalUpdate, this);\n      this.autoUpdateWarned = false;\n    } else {\n      Ticker.shared.remove(this.internalUpdate, this);\n    }\n    this._autoUpdate = value;\n  }\n  update(dt) {\n    if (this.autoUpdate && !this.autoUpdateWarned) {\n      console.warn(\n      // eslint-disable-next-line max-len\n      \"You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want.\");\n      this.autoUpdateWarned = true;\n    }\n    this.internalUpdate(0, dt);\n  }\n  internalUpdate(_deltaFrame, deltaSeconds) {\n    this._updateState(deltaSeconds ?? Ticker.shared.deltaMS / 1e3);\n  }\n  get bounds() {\n    if (this._boundsDirty) {\n      this.updateBounds();\n    }\n    return this._bounds;\n  }\n  setBonePosition(bone, position) {\n    const boneAux = bone;\n    if (typeof bone === \"string\") {\n      bone = this.skeleton.findBone(bone);\n    }\n    if (!bone) throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);\n    vectorAux.set(position.x, position.y);\n    if (bone.parent) {\n      const aux = bone.parent.worldToLocal(vectorAux);\n      bone.x = aux.x;\n      bone.y = -aux.y;\n    } else {\n      bone.x = vectorAux.x;\n      bone.y = vectorAux.y;\n    }\n  }\n  getBonePosition(bone, outPos) {\n    const boneAux = bone;\n    if (typeof bone === \"string\") {\n      bone = this.skeleton.findBone(bone);\n    }\n    if (!bone) {\n      console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);\n      return outPos;\n    }\n    if (!outPos) {\n      outPos = {\n        x: 0,\n        y: 0\n      };\n    }\n    outPos.x = bone.worldX;\n    outPos.y = bone.worldY;\n    return outPos;\n  }\n  /**\n   * Will update the state based on the specified time, this will not apply the state to the skeleton\n   * as this is differed until the `applyState` method is called.\n   *\n   * @param time the time at which to set the state\n   * @internal\n   */\n  _updateState(time) {\n    this.state.update(time);\n    this._stateChanged = true;\n    this._boundsDirty = true;\n    this.onViewUpdate();\n  }\n  /**\n   * Applies the state to this spine instance.\n   * - updates the state to the skeleton\n   * - updates its world transform (spine world transform)\n   * - validates the attachments - to flag if the attachments have changed this state\n   * - transforms the attachments - to update the vertices of the attachments based on the new positions\n   * - update the slot attachments - to update the position, rotation, scale, and visibility of the attached containers\n   * @internal\n   */\n  _applyState() {\n    if (!this._stateChanged) return;\n    this._stateChanged = false;\n    const {\n      skeleton\n    } = this;\n    this.state.apply(skeleton);\n    skeleton.updateWorldTransform();\n    this.validateAttachments();\n    this.transformAttachments();\n    this.updateSlotObjects();\n  }\n  validateAttachments() {\n    const currentDrawOrder = this.skeleton.drawOrder;\n    const lastAttachments = this._lastAttachments || (this._lastAttachments = []);\n    let index = 0;\n    let spineAttachmentsDirty = false;\n    for (let i = 0; i < currentDrawOrder.length; i++) {\n      const slot = currentDrawOrder[i];\n      const attachment = slot.getAttachment();\n      if (attachment) {\n        if (attachment !== lastAttachments[index]) {\n          spineAttachmentsDirty = true;\n          lastAttachments[index] = attachment;\n        }\n        index++;\n      }\n    }\n    if (index !== lastAttachments.length) {\n      spineAttachmentsDirty = true;\n      lastAttachments.length = index;\n    }\n    this.spineAttachmentsDirty = spineAttachmentsDirty;\n  }\n  transformAttachments() {\n    const currentDrawOrder = this.skeleton.drawOrder;\n    for (let i = 0; i < currentDrawOrder.length; i++) {\n      const slot = currentDrawOrder[i];\n      const attachment = slot.getAttachment();\n      if (attachment) {\n        if (attachment instanceof MeshAttachment || attachment instanceof RegionAttachment) {\n          const cacheData = this._getCachedData(slot, attachment);\n          if (attachment instanceof RegionAttachment) {\n            attachment.computeWorldVertices(slot, cacheData.vertices, 0, 2);\n          } else {\n            attachment.computeWorldVertices(slot, 0, attachment.worldVerticesLength, cacheData.vertices, 0, 2);\n          }\n          cacheData.clipped = false;\n          if (clipper.isClipping()) {\n            this.updateClippingData(cacheData);\n          }\n        } else if (attachment instanceof ClippingAttachment) {\n          clipper.clipStart(slot, attachment);\n        } else {\n          clipper.clipEndWithSlot(slot);\n        }\n      }\n    }\n    clipper.clipEnd();\n  }\n  updateClippingData(cacheData) {\n    cacheData.clipped = true;\n    clipper.clipTriangles(cacheData.vertices, cacheData.vertices.length, cacheData.indices, cacheData.indices.length, cacheData.uvs, lightColor, darkColor, false);\n    const {\n      clippedVertices,\n      clippedTriangles\n    } = clipper;\n    const verticesCount = clippedVertices.length / 8;\n    const indicesCount = clippedTriangles.length;\n    if (!cacheData.clippedData) {\n      cacheData.clippedData = {\n        vertices: new Float32Array(verticesCount * 2),\n        uvs: new Float32Array(verticesCount * 2),\n        vertexCount: verticesCount,\n        indices: new Uint16Array(indicesCount),\n        indicesCount\n      };\n      this.spineAttachmentsDirty = true;\n    }\n    const clippedData = cacheData.clippedData;\n    const sizeChange = clippedData.vertexCount !== verticesCount || indicesCount !== clippedData.indicesCount;\n    if (sizeChange) {\n      this.spineAttachmentsDirty = true;\n      if (clippedData.vertexCount < verticesCount) {\n        clippedData.vertices = new Float32Array(verticesCount * 2);\n        clippedData.uvs = new Float32Array(verticesCount * 2);\n      }\n      if (clippedData.indices.length < indicesCount) {\n        clippedData.indices = new Uint16Array(indicesCount);\n      }\n    }\n    const {\n      vertices,\n      uvs,\n      indices\n    } = clippedData;\n    for (let i = 0; i < verticesCount; i++) {\n      vertices[i * 2] = clippedVertices[i * 8];\n      vertices[i * 2 + 1] = clippedVertices[i * 8 + 1];\n      uvs[i * 2] = clippedVertices[i * 8 + 6];\n      uvs[i * 2 + 1] = clippedVertices[i * 8 + 7];\n    }\n    clippedData.vertexCount = verticesCount;\n    for (let i = 0; i < indices.length; i++) {\n      indices[i] = clippedTriangles[i];\n    }\n    clippedData.indicesCount = indicesCount;\n  }\n  /**\n   * ensure that attached containers map correctly to their slots\n   * along with their position, rotation, scale, and visibility.\n   */\n  updateSlotObjects() {\n    for (const i in this._slotsObject) {\n      const slotAttachment = this._slotsObject[i];\n      if (!slotAttachment) continue;\n      this.updateSlotObject(slotAttachment);\n    }\n  }\n  updateSlotObject(slotAttachment) {\n    const {\n      slot,\n      container\n    } = slotAttachment;\n    container.visible = this.skeleton.drawOrder.includes(slot);\n    if (container.visible) {\n      const bone = slot.bone;\n      container.position.set(bone.worldX, bone.worldY);\n      container.scale.x = bone.getWorldScaleX();\n      container.scale.y = bone.getWorldScaleY();\n      container.rotation = bone.getWorldRotationX() * DEG_TO_RAD;\n    }\n  }\n  /** @internal */\n  _getCachedData(slot, attachment) {\n    const key = `${slot.data.index}-${attachment.name}`;\n    return this.attachmentCacheData[key] || this.initCachedData(slot, attachment);\n  }\n  initCachedData(slot, attachment) {\n    const key = `${slot.data.index}-${attachment.name}`;\n    let vertices;\n    if (attachment instanceof RegionAttachment) {\n      vertices = new Float32Array(8);\n      this.attachmentCacheData[key] = {\n        id: key,\n        vertices,\n        clipped: false,\n        indices: [0, 1, 2, 0, 2, 3],\n        uvs: attachment.uvs,\n        color: slot.color\n      };\n    } else {\n      vertices = new Float32Array(attachment.worldVerticesLength);\n      this.attachmentCacheData[key] = {\n        id: key,\n        vertices,\n        clipped: false,\n        indices: attachment.triangles,\n        uvs: attachment.uvs,\n        color: slot.color\n      };\n    }\n    return this.attachmentCacheData[key];\n  }\n  onViewUpdate() {\n    this._didChangeId += 1 << 12;\n    this._boundsDirty = true;\n    if (this.didViewUpdate) return;\n    this.didViewUpdate = true;\n    const renderGroup = this.renderGroup || this.parentRenderGroup;\n    if (renderGroup) {\n      renderGroup.onChildViewUpdate(this);\n    }\n    this.debug?.renderDebug(this);\n  }\n  /**\n   * Attaches a PixiJS container to a specified slot. This will map the world transform of the slots bone\n   * to the attached container. A container can only be attached to one slot at a time.\n   *\n   * @param container - The container to attach to the slot\n   * @param slotRef - The slot id or  slot to attach to\n   */\n  addSlotObject(slot, container) {\n    slot = this.getSlotFromRef(slot);\n    for (const i in this._slotsObject) {\n      if (this._slotsObject[i]?.container === container) {\n        this.removeSlotObject(this._slotsObject[i].slot);\n      }\n    }\n    this.removeSlotObject(slot);\n    container.includeInBuild = false;\n    this.addChild(container);\n    this._slotsObject[slot.data.name] = {\n      container,\n      slot\n    };\n    this.updateSlotObject(this._slotsObject[slot.data.name]);\n  }\n  /**\n   * Removes a PixiJS container from the slot it is attached to.\n   *\n   * @param container - The container to detach from the slot\n   * @param slotOrContainer - The container, slot id or slot to detach from\n   */\n  removeSlotObject(slotOrContainer) {\n    let containerToRemove;\n    if (slotOrContainer instanceof Container) {\n      for (const i in this._slotsObject) {\n        if (this._slotsObject[i]?.container === slotOrContainer) {\n          this._slotsObject[i] = null;\n          containerToRemove = slotOrContainer;\n          break;\n        }\n      }\n    } else {\n      const slot = this.getSlotFromRef(slotOrContainer);\n      containerToRemove = this._slotsObject[slot.data.name]?.container;\n      this._slotsObject[slot.data.name] = null;\n    }\n    if (containerToRemove) {\n      this.removeChild(containerToRemove);\n      containerToRemove.includeInBuild = true;\n    }\n  }\n  /**\n   * Returns a container attached to a slot, or undefined if no container is attached.\n   *\n   * @param slotRef - The slot id or slot to get the attachment from\n   * @returns - The container attached to the slot\n   */\n  getSlotObject(slot) {\n    slot = this.getSlotFromRef(slot);\n    return this._slotsObject[slot.data.name].container;\n  }\n  updateBounds() {\n    this._boundsDirty = false;\n    this.skeletonBounds || (this.skeletonBounds = new SkeletonBounds());\n    const skeletonBounds = this.skeletonBounds;\n    skeletonBounds.update(this.skeleton, true);\n    if (skeletonBounds.minX === Infinity) {\n      this._applyState();\n      const drawOrder = this.skeleton.drawOrder;\n      const bounds = this._bounds;\n      bounds.clear();\n      for (let i = 0; i < drawOrder.length; i++) {\n        const slot = drawOrder[i];\n        const attachment = slot.getAttachment();\n        if (attachment && (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment)) {\n          const cacheData = this._getCachedData(slot, attachment);\n          bounds.addVertexData(cacheData.vertices, 0, cacheData.vertices.length);\n        }\n      }\n    } else {\n      this._bounds.minX = skeletonBounds.minX;\n      this._bounds.minY = skeletonBounds.minY;\n      this._bounds.maxX = skeletonBounds.maxX;\n      this._bounds.maxY = skeletonBounds.maxY;\n    }\n  }\n  addBounds(bounds) {\n    bounds.addBounds(this.bounds);\n  }\n  containsPoint(point) {\n    const bounds = this.bounds;\n    if (point.x >= bounds.minX && point.x <= bounds.maxX) {\n      if (point.y >= bounds.minY && point.y <= bounds.maxY) {\n        return true;\n      }\n    }\n    return false;\n  }\n  /**\n   * Destroys this sprite renderable and optionally its texture.\n   * @param options - Options parameter. A boolean will act as if all options\n   *  have been set to that value\n   * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n   * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n   */\n  destroy(options = false) {\n    super.destroy(options);\n    Ticker.shared.remove(this.internalUpdate, this);\n    this.state.clearListeners();\n    this.debug = void 0;\n    this.skeleton = null;\n    this.state = null;\n    this._slotsObject = null;\n    this._lastAttachments = null;\n    this.attachmentCacheData = null;\n  }\n  /** Whether or not to round the x/y position of the sprite. */\n  get roundPixels() {\n    return !!this._roundPixels;\n  }\n  set roundPixels(value) {\n    this._roundPixels = value ? 1 : 0;\n  }\n  static from({\n    skeleton,\n    atlas,\n    scale = 1\n  }) {\n    const cacheKey = `${skeleton}-${atlas}`;\n    if (Cache.has(cacheKey)) {\n      return new Spine(Cache.get(cacheKey));\n    }\n    const skeletonAsset = Assets.get(skeleton);\n    const atlasAsset = Assets.get(atlas);\n    const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);\n    const parser = skeletonAsset instanceof Uint8Array ? new SkeletonBinary(attachmentLoader) : new SkeletonJson(attachmentLoader);\n    parser.scale = scale;\n    const skeletonData = parser.readSkeletonData(skeletonAsset);\n    Cache.set(cacheKey, skeletonData);\n    return new Spine({\n      skeletonData\n    });\n  }\n}\nexport { Spine };","map":{"version":3,"names":["vectorAux","Vector2","lightColor","Color","darkColor","Skeleton","yDown","clipper","SkeletonClipping","Spine","Container","constructor","options","SkeletonData","skeletonData","__publicField","Bounds","Object","create","skeleton","state","AnimationState","AnimationStateData","autoUpdate","_updateState","getSlotFromRef","slotRef","slot","slots","findSlot","Error","debug","_debug","value","unregisterSpine","registerSpine","_autoUpdate","Ticker","shared","add","internalUpdate","autoUpdateWarned","remove","update","dt","console","warn","_deltaFrame","deltaSeconds","deltaMS","bounds","_boundsDirty","updateBounds","_bounds","setBonePosition","bone","position","boneAux","findBone","String","set","x","y","parent","aux","worldToLocal","getBonePosition","outPos","error","worldX","worldY","time","_stateChanged","onViewUpdate","_applyState","apply","updateWorldTransform","validateAttachments","transformAttachments","updateSlotObjects","currentDrawOrder","drawOrder","lastAttachments","_lastAttachments","index","spineAttachmentsDirty","i","length","attachment","getAttachment","MeshAttachment","RegionAttachment","cacheData","_getCachedData","computeWorldVertices","vertices","worldVerticesLength","clipped","isClipping","updateClippingData","ClippingAttachment","clipStart","clipEndWithSlot","clipEnd","clipTriangles","indices","uvs","clippedVertices","clippedTriangles","verticesCount","indicesCount","clippedData","Float32Array","vertexCount","Uint16Array","sizeChange","_slotsObject","slotAttachment","updateSlotObject","container","visible","includes","scale","getWorldScaleX","getWorldScaleY","rotation","getWorldRotationX","DEG_TO_RAD","key","data","name","attachmentCacheData","initCachedData","id","color","triangles","_didChangeId","didViewUpdate","renderGroup","parentRenderGroup","onChildViewUpdate","renderDebug","addSlotObject","removeSlotObject","includeInBuild","addChild","slotOrContainer","containerToRemove","removeChild","getSlotObject","skeletonBounds","SkeletonBounds","minX","Infinity","clear","addVertexData","minY","maxX","maxY","addBounds","containsPoint","point","destroy","clearListeners","roundPixels","_roundPixels","from","atlas","cacheKey","Cache","has","get","skeletonAsset","Assets","atlasAsset","attachmentLoader","AtlasAttachmentLoader","parser","Uint8Array","SkeletonBinary","SkeletonJson","readSkeletonData"],"sources":["../src/Spine.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport {\n    Assets,\n    Bounds,\n    Cache,\n    Container,\n    ContainerOptions,\n    DEG_TO_RAD,\n    DestroyOptions,\n    PointData,\n    Ticker,\n    View,\n} from 'pixi.js';\nimport { ISpineDebugRenderer } from './SpineDebugRenderer';\nimport {\n    AnimationState,\n    AnimationStateData,\n    AtlasAttachmentLoader,\n    Attachment,\n    Bone,\n    ClippingAttachment,\n    Color,\n    MeshAttachment,\n    RegionAttachment,\n    Skeleton,\n    SkeletonBinary,\n    SkeletonBounds,\n    SkeletonClipping,\n    SkeletonData,\n    SkeletonJson,\n    Slot,\n    type TextureAtlas,\n    TrackEntry,\n    Vector2,\n} from '@esotericsoftware/spine-core';\n\nexport type SpineFromOptions = {\n    skeleton: string;\n    atlas: string;\n    scale?: number;\n};\n\nconst vectorAux = new Vector2();\nconst lightColor = new Color();\nconst darkColor = new Color();\n\nSkeleton.yDown = true;\n\nconst clipper = new SkeletonClipping();\n\nexport interface SpineOptions extends ContainerOptions\n{\n    skeletonData: SkeletonData;\n    autoUpdate?: boolean;\n}\n\nexport interface SpineEvents\n{\n    complete: [trackEntry: TrackEntry];\n    dispose: [trackEntry: TrackEntry];\n    end: [trackEntry: TrackEntry];\n    event: [trackEntry: TrackEntry, event: Event];\n    interrupt: [trackEntry: TrackEntry];\n    start: [trackEntry: TrackEntry];\n}\n\nexport interface AttachmentCacheData\n{\n    id: string;\n    clipped: boolean;\n    vertices: Float32Array;\n    uvs: Float32Array;\n    indices: number[];\n    color: { r: number; g: number; b: number; a: number };\n    clippedData?: {\n        vertices: Float32Array;\n        uvs: Float32Array;\n        indices: Uint16Array;\n        vertexCount: number;\n        indicesCount: number;\n    };\n}\n\nexport class Spine extends Container implements View\n{\n    // Pixi properties\n    public batched = true;\n    public buildId = 0;\n    public override readonly renderPipeId = 'spine';\n    public _didSpineUpdate = false;\n    public _boundsDirty = true;\n    public _roundPixels: 0 | 1;\n    private _bounds: Bounds = new Bounds();\n\n    // Spine properties\n    public skeleton: Skeleton;\n    public state: AnimationState;\n    public skeletonBounds: SkeletonBounds;\n    private _debug?: ISpineDebugRenderer | undefined = undefined;\n\n    readonly _slotsObject: Record<string, {slot:Slot, container:Container}> = Object.create(null);\n\n    private getSlotFromRef(slotRef: number | string | Slot): Slot\n    {\n        let slot: Slot | null;\n\n        if (typeof slotRef === 'number') slot = this.skeleton.slots[slotRef];\n        else if (typeof slotRef === 'string') slot = this.skeleton.findSlot(slotRef);\n        else slot = slotRef;\n\n        if (!slot) throw new Error(`No slot found with the given slot reference: ${slotRef}`);\n\n        return slot;\n    }\n\n    public spineAttachmentsDirty: boolean;\n    private _lastAttachments: Attachment[];\n\n    private _stateChanged: boolean;\n    private attachmentCacheData: Record<string, AttachmentCacheData> = {};\n\n    public get debug(): ISpineDebugRenderer | undefined\n    {\n        return this._debug;\n    }\n\n    public set debug(value: ISpineDebugRenderer | undefined)\n    {\n        if (this._debug)\n        {\n            this._debug.unregisterSpine(this);\n        }\n        if (value)\n        {\n            value.registerSpine(this);\n        }\n        this._debug = value;\n    }\n\n    private autoUpdateWarned = false;\n    private _autoUpdate = true;\n\n    public get autoUpdate(): boolean\n    {\n        return this._autoUpdate;\n    }\n\n    public set autoUpdate(value: boolean)\n    {\n        if (value)\n        {\n            Ticker.shared.add(this.internalUpdate, this);\n            this.autoUpdateWarned = false;\n        }\n        else\n        {\n            Ticker.shared.remove(this.internalUpdate, this);\n        }\n\n        this._autoUpdate = value;\n    }\n\n    constructor(options: SpineOptions | SkeletonData)\n    {\n        if (options instanceof SkeletonData)\n        {\n            options = {\n                skeletonData: options,\n            };\n        }\n\n        super();\n\n        const skeletonData = options instanceof SkeletonData ? options : options.skeletonData;\n\n        this.skeleton = new Skeleton(skeletonData);\n        this.state = new AnimationState(new AnimationStateData(skeletonData));\n        this.autoUpdate = options?.autoUpdate ?? true;\n\n        this._updateState(0);\n    }\n\n    public update(dt: number): void\n    {\n        if (this.autoUpdate && !this.autoUpdateWarned)\n        {\n            console.warn(\n                // eslint-disable-next-line max-len\n                'You are calling update on a Spine instance that has autoUpdate set to true. This is probably not what you want.',\n            );\n            this.autoUpdateWarned = true;\n        }\n\n        this.internalUpdate(0, dt);\n    }\n\n    protected internalUpdate(_deltaFrame: any, deltaSeconds?: number): void\n    {\n        // Because reasons, pixi uses deltaFrames at 60fps.\n        // We ignore the default deltaFrames and use the deltaSeconds from pixi ticker.\n        this._updateState(deltaSeconds ?? Ticker.shared.deltaMS / 1000);\n    }\n\n    get bounds()\n    {\n        if (this._boundsDirty)\n        {\n            this.updateBounds();\n        }\n\n        return this._bounds;\n    }\n\n    public setBonePosition(bone: string | Bone, position: PointData): void\n    {\n        const boneAux = bone;\n\n        if (typeof bone === 'string')\n        {\n            bone = this.skeleton.findBone(bone) as Bone;\n        }\n\n        if (!bone) throw Error(`Cant set bone position, bone ${String(boneAux)} not found`);\n        vectorAux.set(position.x, position.y);\n\n        if (bone.parent)\n        {\n            const aux = bone.parent.worldToLocal(vectorAux);\n\n            bone.x = aux.x;\n            bone.y = -aux.y;\n        }\n        else\n        {\n            bone.x = vectorAux.x;\n            bone.y = vectorAux.y;\n        }\n    }\n\n    public getBonePosition(bone: string | Bone, outPos?: PointData): PointData | undefined\n    {\n        const boneAux = bone;\n\n        if (typeof bone === 'string')\n        {\n            bone = this.skeleton.findBone(bone) as Bone;\n        }\n\n        if (!bone)\n        {\n            console.error(`Cant set bone position! Bone ${String(boneAux)} not found`);\n\n            return outPos;\n        }\n\n        if (!outPos)\n        {\n            outPos = { x: 0, y: 0 };\n        }\n\n        outPos.x = bone.worldX;\n        outPos.y = bone.worldY;\n\n        return outPos;\n    }\n\n    /**\n     * Will update the state based on the specified time, this will not apply the state to the skeleton\n     * as this is differed until the `applyState` method is called.\n     *\n     * @param time the time at which to set the state\n     * @internal\n     */\n    _updateState(time: number)\n    {\n        this.state.update(time);\n\n        this._stateChanged = true;\n\n        this._boundsDirty = true;\n\n        this.onViewUpdate();\n    }\n\n    /**\n     * Applies the state to this spine instance.\n     * - updates the state to the skeleton\n     * - updates its world transform (spine world transform)\n     * - validates the attachments - to flag if the attachments have changed this state\n     * - transforms the attachments - to update the vertices of the attachments based on the new positions\n     * - update the slot attachments - to update the position, rotation, scale, and visibility of the attached containers\n     * @internal\n     */\n    _applyState()\n    {\n        if (!this._stateChanged) return;\n        this._stateChanged = false;\n\n        const { skeleton } = this;\n\n        this.state.apply(skeleton);\n\n        skeleton.updateWorldTransform();\n\n        this.validateAttachments();\n\n        this.transformAttachments();\n\n        this.updateSlotObjects();\n    }\n\n    private validateAttachments()\n    {\n        const currentDrawOrder = this.skeleton.drawOrder;\n\n        const lastAttachments = (this._lastAttachments ||= []);\n\n        let index = 0;\n\n        let spineAttachmentsDirty = false;\n\n        for (let i = 0; i < currentDrawOrder.length; i++)\n        {\n            const slot = currentDrawOrder[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment)\n            {\n                if (attachment !== lastAttachments[index])\n                {\n                    spineAttachmentsDirty = true;\n                    lastAttachments[index] = attachment;\n                }\n\n                index++;\n            }\n        }\n\n        if (index !== lastAttachments.length)\n        {\n            spineAttachmentsDirty = true;\n            lastAttachments.length = index;\n        }\n\n        this.spineAttachmentsDirty = spineAttachmentsDirty;\n    }\n\n    private transformAttachments()\n    {\n        const currentDrawOrder = this.skeleton.drawOrder;\n\n        for (let i = 0; i < currentDrawOrder.length; i++)\n        {\n            const slot = currentDrawOrder[i];\n\n            const attachment = slot.getAttachment();\n\n            if (attachment)\n            {\n                if (attachment instanceof MeshAttachment || attachment instanceof RegionAttachment)\n                {\n                    const cacheData = this._getCachedData(slot, attachment);\n\n                    if (attachment instanceof RegionAttachment)\n                    {\n                        attachment.computeWorldVertices(slot, cacheData.vertices, 0, 2);\n                    }\n                    else\n                    {\n                        attachment.computeWorldVertices(\n                            slot,\n                            0,\n                            attachment.worldVerticesLength,\n                            cacheData.vertices,\n                            0,\n                            2,\n                        );\n                    }\n\n                    cacheData.clipped = false;\n\n                    if (clipper.isClipping())\n                    {\n                        this.updateClippingData(cacheData);\n                    }\n                }\n                else if (attachment instanceof ClippingAttachment)\n                {\n                    clipper.clipStart(slot, attachment);\n                }\n                else\n                {\n                    clipper.clipEndWithSlot(slot);\n                }\n            }\n        }\n\n        clipper.clipEnd();\n    }\n\n    private updateClippingData(cacheData: AttachmentCacheData)\n    {\n        cacheData.clipped = true;\n\n        clipper.clipTriangles(\n            cacheData.vertices,\n            cacheData.vertices.length,\n            cacheData.indices,\n            cacheData.indices.length,\n            cacheData.uvs,\n            lightColor,\n            darkColor,\n            false,\n        );\n\n        const { clippedVertices, clippedTriangles } = clipper;\n\n        const verticesCount = clippedVertices.length / 8;\n        const indicesCount = clippedTriangles.length;\n\n        if (!cacheData.clippedData)\n        {\n            cacheData.clippedData = {\n                vertices: new Float32Array(verticesCount * 2),\n                uvs: new Float32Array(verticesCount * 2),\n                vertexCount: verticesCount,\n                indices: new Uint16Array(indicesCount),\n                indicesCount,\n            };\n\n            this.spineAttachmentsDirty = true;\n        }\n\n        const clippedData = cacheData.clippedData;\n\n        const sizeChange = clippedData.vertexCount !== verticesCount || indicesCount !== clippedData.indicesCount;\n\n        if (sizeChange)\n        {\n            this.spineAttachmentsDirty = true;\n\n            if (clippedData.vertexCount < verticesCount)\n            {\n                // buffer reuse!\n                clippedData.vertices = new Float32Array(verticesCount * 2);\n                clippedData.uvs = new Float32Array(verticesCount * 2);\n            }\n\n            if (clippedData.indices.length < indicesCount)\n            {\n                clippedData.indices = new Uint16Array(indicesCount);\n            }\n        }\n\n        const { vertices, uvs, indices } = clippedData;\n\n        for (let i = 0; i < verticesCount; i++)\n        {\n            vertices[i * 2] = clippedVertices[i * 8];\n            vertices[(i * 2) + 1] = clippedVertices[(i * 8) + 1];\n\n            uvs[i * 2] = clippedVertices[(i * 8) + 6];\n            uvs[(i * 2) + 1] = clippedVertices[(i * 8) + 7];\n        }\n\n        clippedData.vertexCount = verticesCount;\n\n        for (let i = 0; i < indices.length; i++)\n        {\n            indices[i] = clippedTriangles[i];\n        }\n\n        clippedData.indicesCount = indicesCount;\n    }\n\n    /**\n     * ensure that attached containers map correctly to their slots\n     * along with their position, rotation, scale, and visibility.\n     */\n    private updateSlotObjects()\n    {\n        for (const i in this._slotsObject)\n        {\n            const slotAttachment = this._slotsObject[i];\n\n            if (!slotAttachment) continue;\n\n            this.updateSlotObject(slotAttachment);\n        }\n    }\n\n    private updateSlotObject(slotAttachment: {slot:Slot, container:Container})\n    {\n        const { slot, container } = slotAttachment;\n\n        container.visible = this.skeleton.drawOrder.includes(slot);\n\n        if (container.visible)\n        {\n            const bone = slot.bone;\n\n            container.position.set(bone.worldX, bone.worldY);\n\n            container.scale.x = bone.getWorldScaleX();\n            container.scale.y = bone.getWorldScaleY();\n\n            container.rotation = bone.getWorldRotationX() * DEG_TO_RAD;\n        }\n    }\n\n    /** @internal */\n    _getCachedData(slot: Slot, attachment: RegionAttachment | MeshAttachment): AttachmentCacheData\n    {\n        const key = `${slot.data.index}-${attachment.name}`;\n\n        return this.attachmentCacheData[key] || this.initCachedData(slot, attachment);\n    }\n\n    private initCachedData(slot: Slot, attachment: RegionAttachment | MeshAttachment): AttachmentCacheData\n    {\n        const key = `${slot.data.index}-${attachment.name}`;\n\n        let vertices: Float32Array;\n\n        if (attachment instanceof RegionAttachment)\n        {\n            vertices = new Float32Array(8);\n\n            this.attachmentCacheData[key] = {\n                id: key,\n                vertices,\n                clipped: false,\n                indices: [0, 1, 2, 0, 2, 3],\n                uvs: attachment.uvs as Float32Array,\n                color: slot.color,\n            };\n        }\n        else\n        {\n            vertices = new Float32Array(attachment.worldVerticesLength);\n\n            this.attachmentCacheData[key] = {\n                id: key,\n                vertices,\n                clipped: false,\n                indices: attachment.triangles,\n                uvs: attachment.uvs as Float32Array,\n                color: slot.color,\n            };\n        }\n\n        return this.attachmentCacheData[key];\n    }\n\n    onViewUpdate()\n    {\n        // increment from the 12th bit!\n        this._didChangeId += 1 << 12;\n\n        this._boundsDirty = true;\n\n        if (this.didViewUpdate) return;\n        this.didViewUpdate = true;\n\n        const renderGroup = this.renderGroup || this.parentRenderGroup;\n\n        if (renderGroup)\n        {\n            renderGroup.onChildViewUpdate(this);\n        }\n\n        this.debug?.renderDebug(this);\n    }\n\n    /**\n     * Attaches a PixiJS container to a specified slot. This will map the world transform of the slots bone\n     * to the attached container. A container can only be attached to one slot at a time.\n     *\n     * @param container - The container to attach to the slot\n     * @param slotRef - The slot id or  slot to attach to\n     */\n    addSlotObject(slot: number | string | Slot, container: Container)\n    {\n        slot = this.getSlotFromRef(slot);\n\n        // need to check in on the container too...\n        for (const i in this._slotsObject)\n        {\n            if (this._slotsObject[i]?.container === container)\n            {\n                this.removeSlotObject(this._slotsObject[i].slot);\n            }\n        }\n\n        this.removeSlotObject(slot);\n\n        container.includeInBuild = false;\n\n        // TODO only add once??\n        this.addChild(container);\n\n        this._slotsObject[slot.data.name] = {\n            container,\n            slot\n        };\n\n        this.updateSlotObject(this._slotsObject[slot.data.name]);\n    }\n\n    /**\n     * Removes a PixiJS container from the slot it is attached to.\n     *\n     * @param container - The container to detach from the slot\n     * @param slotOrContainer - The container, slot id or slot to detach from\n     */\n    removeSlotObject(slotOrContainer: number | string | Slot | Container)\n    {\n        let containerToRemove: Container | undefined;\n\n        if (slotOrContainer instanceof Container)\n        {\n            for (const i in this._slotsObject)\n            {\n                if (this._slotsObject[i]?.container === slotOrContainer)\n                {\n                    this._slotsObject[i] = null;\n\n                    containerToRemove = slotOrContainer;\n                    break;\n                }\n            }\n        }\n        else\n        {\n            const slot = this.getSlotFromRef(slotOrContainer);\n\n            containerToRemove = this._slotsObject[slot.data.name]?.container;\n            this._slotsObject[slot.data.name] = null;\n        }\n\n        if (containerToRemove)\n        {\n            this.removeChild(containerToRemove);\n\n            containerToRemove.includeInBuild = true;\n        }\n    }\n\n    /**\n     * Returns a container attached to a slot, or undefined if no container is attached.\n     *\n     * @param slotRef - The slot id or slot to get the attachment from\n     * @returns - The container attached to the slot\n     */\n    getSlotObject(slot: number | string | Slot)\n    {\n        slot = this.getSlotFromRef(slot);\n\n        return this._slotsObject[slot.data.name].container;\n    }\n\n    updateBounds()\n    {\n        this._boundsDirty = false;\n\n        this.skeletonBounds ||= new SkeletonBounds();\n\n        const skeletonBounds = this.skeletonBounds;\n\n        skeletonBounds.update(this.skeleton, true);\n\n        if (skeletonBounds.minX === Infinity)\n        {\n            this._applyState();\n\n            const drawOrder = this.skeleton.drawOrder;\n            const bounds = this._bounds;\n\n            bounds.clear();\n\n            for (let i = 0; i < drawOrder.length; i++)\n            {\n                const slot = drawOrder[i];\n\n                const attachment = slot.getAttachment();\n\n                if (attachment && (attachment instanceof RegionAttachment || attachment instanceof MeshAttachment))\n                {\n                    const cacheData = this._getCachedData(slot, attachment);\n\n                    bounds.addVertexData(cacheData.vertices, 0, cacheData.vertices.length);\n                }\n            }\n        }\n        else\n        {\n            this._bounds.minX = skeletonBounds.minX;\n            this._bounds.minY = skeletonBounds.minY;\n            this._bounds.maxX = skeletonBounds.maxX;\n            this._bounds.maxY = skeletonBounds.maxY;\n        }\n    }\n\n    addBounds(bounds: Bounds)\n    {\n        bounds.addBounds(this.bounds);\n    }\n\n    public containsPoint(point: PointData)\n    {\n        const bounds = this.bounds;\n\n        if (point.x >= bounds.minX && point.x <= bounds.maxX)\n        {\n            if (point.y >= bounds.minY && point.y <= bounds.maxY)\n            {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Destroys this sprite renderable and optionally its texture.\n     * @param options - Options parameter. A boolean will act as if all options\n     *  have been set to that value\n     * @param {boolean} [options.texture=false] - Should it destroy the current texture of the renderable as well\n     * @param {boolean} [options.textureSource=false] - Should it destroy the textureSource of the renderable as well\n     */\n    public override destroy(options: DestroyOptions = false)\n    {\n        super.destroy(options);\n\n        Ticker.shared.remove(this.internalUpdate, this);\n        this.state.clearListeners();\n        this.debug = undefined;\n        this.skeleton = null as any;\n        this.state = null as any;\n        (this._slotsObject as any) = null;\n        this._lastAttachments = null;\n        this.attachmentCacheData = null as any;\n    }\n\n    /** Whether or not to round the x/y position of the sprite. */\n    get roundPixels()\n    {\n        return !!this._roundPixels;\n    }\n\n    set roundPixels(value: boolean)\n    {\n        this._roundPixels = value ? 1 : 0;\n    }\n\n    static from({ skeleton, atlas, scale = 1 }: SpineFromOptions)\n    {\n        const cacheKey = `${skeleton}-${atlas}`;\n\n        if (Cache.has(cacheKey))\n        {\n            return new Spine(Cache.get<SkeletonData>(cacheKey));\n        }\n\n        const skeletonAsset = Assets.get<any | Uint8Array>(skeleton);\n\n        const atlasAsset = Assets.get<TextureAtlas>(atlas);\n        const attachmentLoader = new AtlasAttachmentLoader(atlasAsset);\n        // eslint-disable-next-line max-len\n        const parser\n            = skeletonAsset instanceof Uint8Array\n                ? new SkeletonBinary(attachmentLoader)\n                : new SkeletonJson(attachmentLoader);\n\n        // TODO scale?\n        parser.scale = scale;\n        const skeletonData = parser.readSkeletonData(skeletonAsset);\n\n        Cache.set(cacheKey, skeletonData);\n\n        return new Spine({\n            skeletonData,\n        });\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}