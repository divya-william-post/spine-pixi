{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { Container } from '@pixi/display';\nimport { Graphics } from '@pixi/graphics';\nimport { AttachmentType } from './core/AttachmentType.mjs';\nimport { SkeletonBoundsBase } from './core/SkeletonBoundsBase.mjs';\nclass SpineDebugRenderer {\n  constructor() {\n    this.registeredSpines = /* @__PURE__ */new Map();\n    this.drawDebug = true;\n    this.drawMeshHull = true;\n    this.drawMeshTriangles = true;\n    this.drawBones = true;\n    this.drawPaths = true;\n    this.drawBoundingBoxes = true;\n    this.drawClipping = true;\n    this.drawRegionAttachments = true;\n    this.lineWidth = 1;\n    this.regionAttachmentsColor = 30975;\n    this.meshHullColor = 30975;\n    this.meshTrianglesColor = 16763904;\n    this.clippingPolygonColor = 16711935;\n    this.boundingBoxesRectColor = 65280;\n    this.boundingBoxesPolygonColor = 65280;\n    this.boundingBoxesCircleColor = 65280;\n    this.pathsCurveColor = 16711680;\n    this.pathsLineColor = 16711935;\n    this.skeletonXYColor = 16711680;\n    this.bonesColor = 61132;\n  }\n  /**\n   * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\n   */\n  registerSpine(spine) {\n    if (this.registeredSpines.has(spine)) {\n      console.warn(\"SpineDebugRenderer.registerSpine() - this spine is already registered!\", spine);\n    }\n    const debugDisplayObjects = {\n      parentDebugContainer: new Container(),\n      bones: new Container(),\n      skeletonXY: new Graphics(),\n      regionAttachmentsShape: new Graphics(),\n      meshTrianglesLine: new Graphics(),\n      meshHullLine: new Graphics(),\n      clippingPolygon: new Graphics(),\n      boundingBoxesRect: new Graphics(),\n      boundingBoxesCircle: new Graphics(),\n      boundingBoxesPolygon: new Graphics(),\n      pathsCurve: new Graphics(),\n      pathsLine: new Graphics()\n    };\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n    debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n    spine.addChild(debugDisplayObjects.parentDebugContainer);\n    this.registeredSpines.set(spine, debugDisplayObjects);\n  }\n  renderDebug(spine) {\n    if (!this.registeredSpines.has(spine)) {\n      this.registerSpine(spine);\n    }\n    const debugDisplayObjects = this.registeredSpines.get(spine);\n    debugDisplayObjects.skeletonXY.clear();\n    debugDisplayObjects.regionAttachmentsShape.clear();\n    debugDisplayObjects.meshTrianglesLine.clear();\n    debugDisplayObjects.meshHullLine.clear();\n    debugDisplayObjects.clippingPolygon.clear();\n    debugDisplayObjects.boundingBoxesRect.clear();\n    debugDisplayObjects.boundingBoxesCircle.clear();\n    debugDisplayObjects.boundingBoxesPolygon.clear();\n    debugDisplayObjects.pathsCurve.clear();\n    debugDisplayObjects.pathsLine.clear();\n    for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\n      debugDisplayObjects.bones.children[len - 1].destroy({\n        children: true,\n        texture: true,\n        baseTexture: true\n      });\n    }\n    const scale = spine.scale.x || spine.scale.y || 1;\n    const lineWidth = this.lineWidth / scale;\n    if (this.drawBones) {\n      this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n    }\n    if (this.drawPaths) {\n      this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawBoundingBoxes) {\n      this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawClipping) {\n      this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawMeshHull || this.drawMeshTriangles) {\n      this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n    }\n    if (this.drawRegionAttachments) {\n      this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n    }\n  }\n  drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale) {\n    const skeleton = spine.skeleton;\n    const skeletonX = skeleton.x;\n    const skeletonY = skeleton.y;\n    const bones = skeleton.bones;\n    debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\n    for (let i = 0, len = bones.length; i < len; i++) {\n      const bone = bones[i];\n      const boneLen = bone.data.length;\n      const starX = skeletonX + bone.matrix.tx;\n      const starY = skeletonY + bone.matrix.ty;\n      const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;\n      const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\n      if (bone.data.name === \"root\" || bone.data.parent === null) {\n        continue;\n      }\n      const w = Math.abs(starX - endX);\n      const h = Math.abs(starY - endY);\n      const a2 = Math.pow(w, 2);\n      const b = h;\n      const b2 = Math.pow(h, 2);\n      const c = Math.sqrt(a2 + b2);\n      const c2 = Math.pow(c, 2);\n      const rad = Math.PI / 180;\n      const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0;\n      if (c === 0) {\n        continue;\n      }\n      const gp = new Graphics();\n      debugDisplayObjects.bones.addChild(gp);\n      const refRation = c / 50 / scale;\n      gp.beginFill(this.bonesColor, 1);\n      gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\n      gp.endFill();\n      gp.x = starX;\n      gp.y = starY;\n      gp.pivot.y = c;\n      let rotation = 0;\n      if (starX < endX && starY < endY) {\n        rotation = -B + 180 * rad;\n      } else if (starX > endX && starY < endY) {\n        rotation = 180 * rad + B;\n      } else if (starX > endX && starY > endY) {\n        rotation = -B;\n      } else if (starX < endX && starY > endY) {\n        rotation = B;\n      } else if (starY === endY && starX < endX) {\n        rotation = 90 * rad;\n      } else if (starY === endY && starX > endX) {\n        rotation = -90 * rad;\n      } else if (starX === endX && starY < endY) {\n        rotation = 180 * rad;\n      } else if (starX === endX && starY > endY) {\n        rotation = 0;\n      }\n      gp.rotation = rotation;\n      gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\n      gp.beginFill(0, 0.6);\n      gp.drawCircle(0, c, refRation * 1.2);\n      gp.endFill();\n    }\n    const startDotSize = lineWidth * 3;\n    debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\n    debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\n    debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\n    debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\n  }\n  drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Region) {\n        continue;\n      }\n      const regionAttachment = attachment;\n      const vertices = new Float32Array(8);\n      if (regionAttachment.updateOffset) regionAttachment.updateOffset();\n      regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n      debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\n    }\n  }\n  drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\n    debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Mesh) {\n        continue;\n      }\n      const meshAttachment = attachment;\n      const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n      const triangles = meshAttachment.triangles;\n      let hullLength = meshAttachment.hullLength;\n      meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n      if (this.drawMeshTriangles) {\n        for (let i2 = 0, len2 = triangles.length; i2 < len2; i2 += 3) {\n          const v1 = triangles[i2] * 2;\n          const v2 = triangles[i2 + 1] * 2;\n          const v3 = triangles[i2 + 2] * 2;\n          debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\n          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\n          debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\n        }\n      }\n      if (this.drawMeshHull && hullLength > 0) {\n        hullLength = (hullLength >> 1) * 2;\n        let lastX = vertices[hullLength - 2];\n        let lastY = vertices[hullLength - 1];\n        for (let i2 = 0, len2 = hullLength; i2 < len2; i2 += 2) {\n          const x = vertices[i2];\n          const y = vertices[i2 + 1];\n          debugDisplayObjects.meshHullLine.moveTo(x, y);\n          debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\n          lastX = x;\n          lastY = y;\n        }\n      }\n    }\n  }\n  drawClippingFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Clipping) {\n        continue;\n      }\n      const clippingAttachment = attachment;\n      const nn = clippingAttachment.worldVerticesLength;\n      const world = new Float32Array(nn);\n      clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n      debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\n    }\n  }\n  drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth) {\n    debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n    const bounds = new SkeletonBoundsBase();\n    bounds.update(spine.skeleton, true);\n    debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n    const polygons = bounds.polygons;\n    const drawPolygon = (polygonVertices, _offset, count) => {\n      debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\n      debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\n      if (count < 3) {\n        throw new Error(\"Polygon must contain at least 3 vertices\");\n      }\n      const paths = [];\n      const dotSize = lineWidth * 2;\n      for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\n        const x1 = polygonVertices[i];\n        const y1 = polygonVertices[i + 1];\n        debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\n        debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n        debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n        debugDisplayObjects.boundingBoxesCircle.endFill();\n        paths.push(x1, y1);\n      }\n      debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\n      debugDisplayObjects.boundingBoxesPolygon.endFill();\n    };\n    for (let i = 0, len = polygons.length; i < len; i++) {\n      const polygon = polygons[i];\n      drawPolygon(polygon, 0, polygon.length);\n    }\n  }\n  drawPathsFunc(spine, debugDisplayObjects, lineWidth) {\n    const skeleton = spine.skeleton;\n    const slots = skeleton.slots;\n    debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\n    debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\n    for (let i = 0, len = slots.length; i < len; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) {\n        continue;\n      }\n      const attachment = slot.getAttachment();\n      if (attachment == null || attachment.type !== AttachmentType.Path) {\n        continue;\n      }\n      const pathAttachment = attachment;\n      let nn = pathAttachment.worldVerticesLength;\n      const world = new Float32Array(nn);\n      pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n      let x1 = world[2];\n      let y1 = world[3];\n      let x2 = 0;\n      let y2 = 0;\n      if (pathAttachment.closed) {\n        const cx1 = world[0];\n        const cy1 = world[1];\n        const cx2 = world[nn - 2];\n        const cy2 = world[nn - 1];\n        x2 = world[nn - 4];\n        y2 = world[nn - 3];\n        debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        debugDisplayObjects.pathsLine.moveTo(x1, y1);\n        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n        debugDisplayObjects.pathsLine.moveTo(x2, y2);\n        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n      }\n      nn -= 4;\n      for (let ii = 4; ii < nn; ii += 6) {\n        const cx1 = world[ii];\n        const cy1 = world[ii + 1];\n        const cx2 = world[ii + 2];\n        const cy2 = world[ii + 3];\n        x2 = world[ii + 4];\n        y2 = world[ii + 5];\n        debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n        debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n        debugDisplayObjects.pathsLine.moveTo(x1, y1);\n        debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n        debugDisplayObjects.pathsLine.moveTo(x2, y2);\n        debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n        x1 = x2;\n        y1 = y2;\n      }\n    }\n  }\n  unregisterSpine(spine) {\n    if (!this.registeredSpines.has(spine)) {\n      console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\n    }\n    const debugDisplayObjects = this.registeredSpines.get(spine);\n    debugDisplayObjects.parentDebugContainer.destroy({\n      baseTexture: true,\n      children: true,\n      texture: true\n    });\n    this.registeredSpines.delete(spine);\n  }\n}\nexport { SpineDebugRenderer };","map":{"version":3,"names":["SpineDebugRenderer","constructor","registeredSpines","Map","drawDebug","drawMeshHull","drawMeshTriangles","drawBones","drawPaths","drawBoundingBoxes","drawClipping","drawRegionAttachments","lineWidth","regionAttachmentsColor","meshHullColor","meshTrianglesColor","clippingPolygonColor","boundingBoxesRectColor","boundingBoxesPolygonColor","boundingBoxesCircleColor","pathsCurveColor","pathsLineColor","skeletonXYColor","bonesColor","registerSpine","spine","has","console","warn","debugDisplayObjects","parentDebugContainer","Container","bones","skeletonXY","Graphics","regionAttachmentsShape","meshTrianglesLine","meshHullLine","clippingPolygon","boundingBoxesRect","boundingBoxesCircle","boundingBoxesPolygon","pathsCurve","pathsLine","addChild","set","renderDebug","get","clear","len","children","length","destroy","texture","baseTexture","scale","x","y","drawBonesFunc","drawPathsFunc","drawBoundingBoxesFunc","drawClippingFunc","drawMeshHullAndMeshTriangles","drawRegionAttachmentsFunc","skeleton","skeletonX","skeletonY","lineStyle","i","bone","boneLen","data","starX","matrix","tx","starY","ty","endX","a","endY","b","name","parent","w","Math","abs","h","a2","pow","b2","c","sqrt","c2","rad","PI","B","acos","gp","refRation","beginFill","drawPolygon","endFill","pivot","rotation","drawCircle","startDotSize","moveTo","lineTo","slots","slot","attachment","getAttachment","type","AttachmentType","Region","regionAttachment","vertices","Float32Array","updateOffset","computeWorldVertices","Array","from","slice","active","Mesh","meshAttachment","worldVerticesLength","triangles","hullLength","i2","len2","v1","v2","v3","lastX","lastY","Clipping","clippingAttachment","nn","world","bounds","SkeletonBoundsBase","update","drawRect","minX","minY","getWidth","getHeight","polygons","polygonVertices","_offset","count","Error","paths","dotSize","x1","y1","push","polygon","Path","pathAttachment","x2","y2","closed","cx1","cy1","cx2","cy2","bezierCurveTo","ii","unregisterSpine","delete"],"sources":["../src/SpineDebugRenderer.ts"],"sourcesContent":["import { Container } from '@pixi/display';\nimport { Graphics } from '@pixi/graphics';\nimport type { IAnimationState, IAnimationStateData } from './core/IAnimation';\nimport type { IClippingAttachment, IMeshAttachment, IRegionAttachment, ISkeleton, ISkeletonData, IVertexAttachment } from './core/ISkeleton';\nimport type { SpineBase } from './SpineBase';\nimport { AttachmentType } from './core/AttachmentType';\nimport { SkeletonBoundsBase } from './core/SkeletonBoundsBase';\n\n/**\n * Make a class that extends from this interface to create your own debug renderer.\n * @public\n */\nexport interface ISpineDebugRenderer {\n    /**\n     * This will be called every frame, after the spine has been updated.\n     */\n    renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n\n    /**\n     *  This is called when the `spine.debug` object is set to null or when the spine is destroyed.\n     */\n    unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n\n    /**\n     * This is called when the `spine.debug` object is set to a new instance of a debug renderer.\n     */\n    registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void;\n}\n\ntype DebugDisplayObjects = {\n    bones: Container;\n    skeletonXY: Graphics;\n    regionAttachmentsShape: Graphics;\n    meshTrianglesLine: Graphics;\n    meshHullLine: Graphics;\n    clippingPolygon: Graphics;\n    boundingBoxesRect: Graphics;\n    boundingBoxesCircle: Graphics;\n    boundingBoxesPolygon: Graphics;\n    pathsCurve: Graphics;\n    pathsLine: Graphics;\n    parentDebugContainer: Container;\n};\n\n/**\n * This is a debug renderer that uses PixiJS Graphics under the hood.\n * @public\n */\nexport class SpineDebugRenderer implements ISpineDebugRenderer {\n    private registeredSpines: Map<SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, DebugDisplayObjects> = new Map();\n\n    public drawDebug = true;\n    public drawMeshHull = true;\n    public drawMeshTriangles = true;\n    public drawBones = true;\n    public drawPaths = true;\n    public drawBoundingBoxes = true;\n    public drawClipping = true;\n    public drawRegionAttachments = true;\n\n    public lineWidth = 1;\n    public regionAttachmentsColor = 0x0078ff;\n    public meshHullColor = 0x0078ff;\n    public meshTrianglesColor = 0xffcc00;\n    public clippingPolygonColor = 0xff00ff;\n    public boundingBoxesRectColor = 0x00ff00;\n    public boundingBoxesPolygonColor = 0x00ff00;\n    public boundingBoxesCircleColor = 0x00ff00;\n    public pathsCurveColor = 0xff0000;\n    public pathsLineColor = 0xff00ff;\n    public skeletonXYColor = 0xff0000;\n    public bonesColor = 0x00eecc;\n\n    /**\n     * The debug is attached by force to each spine object. So we need to create it inside the spine when we get the first update\n     */\n    public registerSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>) {\n        if (this.registeredSpines.has(spine)) {\n            console.warn('SpineDebugRenderer.registerSpine() - this spine is already registered!', spine);\n        }\n        const debugDisplayObjects = {\n            parentDebugContainer: new Container(),\n            bones: new Container(),\n            skeletonXY: new Graphics(),\n            regionAttachmentsShape: new Graphics(),\n            meshTrianglesLine: new Graphics(),\n            meshHullLine: new Graphics(),\n            clippingPolygon: new Graphics(),\n            boundingBoxesRect: new Graphics(),\n            boundingBoxesCircle: new Graphics(),\n            boundingBoxesPolygon: new Graphics(),\n            pathsCurve: new Graphics(),\n            pathsLine: new Graphics(),\n        };\n\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.bones);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.skeletonXY);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.regionAttachmentsShape);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshTrianglesLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.meshHullLine);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.clippingPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesRect);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesCircle);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.boundingBoxesPolygon);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsCurve);\n        debugDisplayObjects.parentDebugContainer.addChild(debugDisplayObjects.pathsLine);\n\n        spine.addChild(debugDisplayObjects.parentDebugContainer);\n\n        this.registeredSpines.set(spine, debugDisplayObjects);\n    }\n    public renderDebug(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\n        if (!this.registeredSpines.has(spine)) {\n            // This should never happen. Spines are registered when you assign spine.debug\n            this.registerSpine(spine);\n        }\n\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        debugDisplayObjects.skeletonXY.clear();\n        debugDisplayObjects.regionAttachmentsShape.clear();\n        debugDisplayObjects.meshTrianglesLine.clear();\n        debugDisplayObjects.meshHullLine.clear();\n        debugDisplayObjects.clippingPolygon.clear();\n        debugDisplayObjects.boundingBoxesRect.clear();\n        debugDisplayObjects.boundingBoxesCircle.clear();\n        debugDisplayObjects.boundingBoxesPolygon.clear();\n        debugDisplayObjects.pathsCurve.clear();\n        debugDisplayObjects.pathsLine.clear();\n\n        for (let len = debugDisplayObjects.bones.children.length; len > 0; len--) {\n            debugDisplayObjects.bones.children[len - 1].destroy({ children: true, texture: true, baseTexture: true });\n        }\n\n        const scale = spine.scale.x || spine.scale.y || 1;\n        const lineWidth = this.lineWidth / scale;\n\n        if (this.drawBones) {\n            this.drawBonesFunc(spine, debugDisplayObjects, lineWidth, scale);\n        }\n\n        if (this.drawPaths) {\n            this.drawPathsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawBoundingBoxes) {\n            this.drawBoundingBoxesFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawClipping) {\n            this.drawClippingFunc(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawMeshHull || this.drawMeshTriangles) {\n            this.drawMeshHullAndMeshTriangles(spine, debugDisplayObjects, lineWidth);\n        }\n\n        if (this.drawRegionAttachments) {\n            this.drawRegionAttachmentsFunc(spine, debugDisplayObjects, lineWidth);\n        }\n    }\n\n    private drawBonesFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number,\n        scale: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const skeletonX = skeleton.x;\n        const skeletonY = skeleton.y;\n        const bones = skeleton.bones;\n\n        debugDisplayObjects.skeletonXY.lineStyle(lineWidth, this.skeletonXYColor, 1);\n\n        for (let i = 0, len = bones.length; i < len; i++) {\n            const bone = bones[i];\n            const boneLen = bone.data.length;\n            const starX = skeletonX + bone.matrix.tx;\n            const starY = skeletonY + bone.matrix.ty;\n            const endX = skeletonX + boneLen * bone.matrix.a + bone.matrix.tx;\n            const endY = skeletonY + boneLen * bone.matrix.b + bone.matrix.ty;\n\n            if (bone.data.name === 'root' || bone.data.parent === null) {\n                continue;\n            }\n\n            // Triangle calculation formula\n            // area: A=sqrt((a+b+c)*(-a+b+c)*(a-b+c)*(a+b-c))/4\n            // alpha: alpha=acos((pow(b, 2)+pow(c, 2)-pow(a, 2))/(2*b*c))\n            // beta: beta=acos((pow(a, 2)+pow(c, 2)-pow(b, 2))/(2*a*c))\n            // gamma: gamma=acos((pow(a, 2)+pow(b, 2)-pow(c, 2))/(2*a*b))\n\n            const w = Math.abs(starX - endX);\n            const h = Math.abs(starY - endY);\n            // a = w, // side length a\n            const a2 = Math.pow(w, 2); // square root of side length a\n            const b = h; // side length b\n            const b2 = Math.pow(h, 2); // square root of side length b\n            const c = Math.sqrt(a2 + b2); // side length c\n            const c2 = Math.pow(c, 2); // square root of side length c\n            const rad = Math.PI / 180;\n            // A = Math.acos([a2 + c2 - b2] / [2 * a * c]) || 0, // Angle A\n            // C = Math.acos([a2 + b2 - c2] / [2 * a * b]) || 0, // C angle\n            const B = Math.acos((c2 + b2 - a2) / (2 * b * c)) || 0; // angle of corner B\n\n            if (c === 0) {\n                continue;\n            }\n\n            const gp = new Graphics();\n\n            debugDisplayObjects.bones.addChild(gp);\n\n            // draw bone\n            const refRation = c / 50 / scale;\n\n            gp.beginFill(this.bonesColor, 1);\n            gp.drawPolygon(0, 0, 0 - refRation, c - refRation * 3, 0, c - refRation, 0 + refRation, c - refRation * 3);\n            gp.endFill();\n            gp.x = starX;\n            gp.y = starY;\n            gp.pivot.y = c;\n\n            // Calculate bone rotation angle\n            let rotation = 0;\n\n            if (starX < endX && starY < endY) {\n                // bottom right\n                rotation = -B + 180 * rad;\n            } else if (starX > endX && starY < endY) {\n                // bottom left\n                rotation = 180 * rad + B;\n            } else if (starX > endX && starY > endY) {\n                // top left\n                rotation = -B;\n            } else if (starX < endX && starY > endY) {\n                // bottom left\n                rotation = B;\n            } else if (starY === endY && starX < endX) {\n                // To the right\n                rotation = 90 * rad;\n            } else if (starY === endY && starX > endX) {\n                // go left\n                rotation = -90 * rad;\n            } else if (starX === endX && starY < endY) {\n                // down\n                rotation = 180 * rad;\n            } else if (starX === endX && starY > endY) {\n                // up\n                rotation = 0;\n            }\n            gp.rotation = rotation;\n\n            // Draw the starting rotation point of the bone\n            gp.lineStyle(lineWidth + refRation / 2.4, this.bonesColor, 1);\n            gp.beginFill(0x000000, 0.6);\n            gp.drawCircle(0, c, refRation * 1.2);\n            gp.endFill();\n        }\n\n        // Draw the skeleton starting point \"X\" form\n        const startDotSize = lineWidth * 3;\n\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX - startDotSize, skeletonY - startDotSize);\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX + startDotSize, skeletonY + startDotSize);\n        debugDisplayObjects.skeletonXY.moveTo(skeletonX + startDotSize, skeletonY - startDotSize);\n        debugDisplayObjects.skeletonXY.lineTo(skeletonX - startDotSize, skeletonY + startDotSize);\n    }\n\n    private drawRegionAttachmentsFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.regionAttachmentsShape.lineStyle(lineWidth, this.regionAttachmentsColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Region) {\n                continue;\n            }\n\n            const regionAttachment = attachment as IRegionAttachment & {\n                computeWorldVertices: (slot: unknown, worldVertices: unknown, offset: unknown, stride: unknown) => void;\n                updateOffset?: () => void;\n            };\n\n            const vertices = new Float32Array(8);\n\n            if (regionAttachment.updateOffset) regionAttachment.updateOffset(); // We don't need this on all versions\n\n            regionAttachment.computeWorldVertices(slot, vertices, 0, 2);\n            debugDisplayObjects.regionAttachmentsShape.drawPolygon(Array.from(vertices.slice(0, 8)));\n        }\n    }\n\n    private drawMeshHullAndMeshTriangles(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.meshHullLine.lineStyle(lineWidth, this.meshHullColor, 1);\n        debugDisplayObjects.meshTrianglesLine.lineStyle(lineWidth, this.meshTrianglesColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Mesh) {\n                continue;\n            }\n\n            const meshAttachment: IMeshAttachment = attachment as IMeshAttachment;\n\n            const vertices = new Float32Array(meshAttachment.worldVerticesLength);\n            const triangles = meshAttachment.triangles;\n            let hullLength = meshAttachment.hullLength;\n\n            meshAttachment.computeWorldVertices(slot, 0, meshAttachment.worldVerticesLength, vertices, 0, 2);\n            // draw the skinned mesh (triangle)\n            if (this.drawMeshTriangles) {\n                for (let i = 0, len = triangles.length; i < len; i += 3) {\n                    const v1 = triangles[i] * 2;\n                    const v2 = triangles[i + 1] * 2;\n                    const v3 = triangles[i + 2] * 2;\n\n                    debugDisplayObjects.meshTrianglesLine.moveTo(vertices[v1], vertices[v1 + 1]);\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v2], vertices[v2 + 1]);\n                    debugDisplayObjects.meshTrianglesLine.lineTo(vertices[v3], vertices[v3 + 1]);\n                }\n            }\n\n            // draw skin border\n            if (this.drawMeshHull && hullLength > 0) {\n                hullLength = (hullLength >> 1) * 2;\n                let lastX = vertices[hullLength - 2];\n                let lastY = vertices[hullLength - 1];\n\n                for (let i = 0, len = hullLength; i < len; i += 2) {\n                    const x = vertices[i];\n                    const y = vertices[i + 1];\n\n                    debugDisplayObjects.meshHullLine.moveTo(x, y);\n                    debugDisplayObjects.meshHullLine.lineTo(lastX, lastY);\n                    lastX = x;\n                    lastY = y;\n                }\n            }\n        }\n    }\n\n    private drawClippingFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.clippingPolygon.lineStyle(lineWidth, this.clippingPolygonColor, 1);\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Clipping) {\n                continue;\n            }\n\n            const clippingAttachment: IClippingAttachment = attachment as IClippingAttachment;\n\n            const nn = clippingAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            clippingAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            debugDisplayObjects.clippingPolygon.drawPolygon(Array.from(world));\n        }\n    }\n\n    private drawBoundingBoxesFunc(\n        spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>,\n        debugDisplayObjects: DebugDisplayObjects,\n        lineWidth: number\n    ): void {\n        // draw the total outline of the bounding box\n        debugDisplayObjects.boundingBoxesRect.lineStyle(lineWidth, this.boundingBoxesRectColor, 5);\n\n        const bounds = new SkeletonBoundsBase();\n\n        bounds.update(spine.skeleton, true);\n        debugDisplayObjects.boundingBoxesRect.drawRect(bounds.minX, bounds.minY, bounds.getWidth(), bounds.getHeight());\n\n        const polygons = bounds.polygons;\n        const drawPolygon = (polygonVertices: ArrayLike<number>, _offset: unknown, count: number): void => {\n            debugDisplayObjects.boundingBoxesPolygon.lineStyle(lineWidth, this.boundingBoxesPolygonColor, 1);\n            debugDisplayObjects.boundingBoxesPolygon.beginFill(this.boundingBoxesPolygonColor, 0.1);\n\n            if (count < 3) {\n                throw new Error('Polygon must contain at least 3 vertices');\n            }\n            const paths = [];\n            const dotSize = lineWidth * 2;\n\n            for (let i = 0, len = polygonVertices.length; i < len; i += 2) {\n                const x1 = polygonVertices[i];\n                const y1 = polygonVertices[i + 1];\n\n                // draw the bounding box node\n                debugDisplayObjects.boundingBoxesCircle.lineStyle(0);\n                debugDisplayObjects.boundingBoxesCircle.beginFill(this.boundingBoxesCircleColor);\n                debugDisplayObjects.boundingBoxesCircle.drawCircle(x1, y1, dotSize);\n                debugDisplayObjects.boundingBoxesCircle.endFill();\n\n                paths.push(x1, y1);\n            }\n\n            // draw the bounding box area\n            debugDisplayObjects.boundingBoxesPolygon.drawPolygon(paths);\n            debugDisplayObjects.boundingBoxesPolygon.endFill();\n        };\n\n        for (let i = 0, len = polygons.length; i < len; i++) {\n            const polygon = polygons[i];\n\n            drawPolygon(polygon, 0, polygon.length);\n        }\n    }\n\n    private drawPathsFunc(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>, debugDisplayObjects: DebugDisplayObjects, lineWidth: number): void {\n        const skeleton = spine.skeleton;\n        const slots = skeleton.slots;\n\n        debugDisplayObjects.pathsCurve.lineStyle(lineWidth, this.pathsCurveColor, 1);\n        debugDisplayObjects.pathsLine.lineStyle(lineWidth, this.pathsLineColor, 1);\n\n        for (let i = 0, len = slots.length; i < len; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) {\n                continue;\n            }\n            const attachment = slot.getAttachment();\n\n            if (attachment == null || attachment.type !== AttachmentType.Path) {\n                continue;\n            }\n\n            const pathAttachment = attachment as IVertexAttachment & { closed: boolean };\n            let nn = pathAttachment.worldVerticesLength;\n            const world = new Float32Array(nn);\n\n            pathAttachment.computeWorldVertices(slot, 0, nn, world, 0, 2);\n            let x1 = world[2];\n            let y1 = world[3];\n            let x2 = 0;\n            let y2 = 0;\n\n            if (pathAttachment.closed) {\n                const cx1 = world[0];\n                const cy1 = world[1];\n                const cx2 = world[nn - 2];\n                const cy2 = world[nn - 1];\n\n                x2 = world[nn - 4];\n                y2 = world[nn - 3];\n\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n            }\n            nn -= 4;\n            for (let ii = 4; ii < nn; ii += 6) {\n                const cx1 = world[ii];\n                const cy1 = world[ii + 1];\n                const cx2 = world[ii + 2];\n                const cy2 = world[ii + 3];\n\n                x2 = world[ii + 4];\n                y2 = world[ii + 5];\n                // curve\n                debugDisplayObjects.pathsCurve.moveTo(x1, y1);\n                debugDisplayObjects.pathsCurve.bezierCurveTo(cx1, cy1, cx2, cy2, x2, y2);\n\n                // handle\n                debugDisplayObjects.pathsLine.moveTo(x1, y1);\n                debugDisplayObjects.pathsLine.lineTo(cx1, cy1);\n                debugDisplayObjects.pathsLine.moveTo(x2, y2);\n                debugDisplayObjects.pathsLine.lineTo(cx2, cy2);\n                x1 = x2;\n                y1 = y2;\n            }\n        }\n    }\n\n    public unregisterSpine(spine: SpineBase<ISkeleton, ISkeletonData, IAnimationState, IAnimationStateData>): void {\n        if (!this.registeredSpines.has(spine)) {\n            console.warn(\"SpineDebugRenderer.unregisterSpine() - spine is not registered, can't unregister!\", spine);\n        }\n        const debugDisplayObjects = this.registeredSpines.get(spine);\n\n        debugDisplayObjects.parentDebugContainer.destroy({ baseTexture: true, children: true, texture: true });\n        this.registeredSpines.delete(spine);\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}