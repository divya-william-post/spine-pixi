{"ast":null,"code":"import _defineProperty from \"/Users/divya/Documents/vue-2024-spine/vue-20240spine/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport \"core-js/modules/es.array.push.js\";\n/******************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\nimport { BoundingBoxAttachment } from \"./attachments/BoundingBoxAttachment.js\";\nimport { Pool, Utils } from \"./Utils.js\";\n/** Collects each visible {@link BoundingBoxAttachment} and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection. */\nexport class SkeletonBounds {\n  constructor() {\n    /** The left edge of the axis aligned bounding box. */\n    _defineProperty(this, \"minX\", 0);\n    /** The bottom edge of the axis aligned bounding box. */\n    _defineProperty(this, \"minY\", 0);\n    /** The right edge of the axis aligned bounding box. */\n    _defineProperty(this, \"maxX\", 0);\n    /** The top edge of the axis aligned bounding box. */\n    _defineProperty(this, \"maxY\", 0);\n    /** The visible bounding boxes. */\n    _defineProperty(this, \"boundingBoxes\", new Array());\n    /** The world vertices for the bounding box polygons. */\n    _defineProperty(this, \"polygons\", new Array());\n    _defineProperty(this, \"polygonPool\", new Pool(() => {\n      return Utils.newFloatArray(16);\n    }));\n  }\n  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n   * box's polygon.\n   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n   *           SkeletonBounds AABB methods will always return true. */\n  update(skeleton, updateAabb) {\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    let boundingBoxes = this.boundingBoxes;\n    let polygons = this.polygons;\n    let polygonPool = this.polygonPool;\n    let slots = skeleton.slots;\n    let slotCount = slots.length;\n    boundingBoxes.length = 0;\n    polygonPool.freeAll(polygons);\n    polygons.length = 0;\n    for (let i = 0; i < slotCount; i++) {\n      let slot = slots[i];\n      if (!slot.bone.active) continue;\n      let attachment = slot.getAttachment();\n      if (attachment instanceof BoundingBoxAttachment) {\n        let boundingBox = attachment;\n        boundingBoxes.push(boundingBox);\n        let polygon = polygonPool.obtain();\n        if (polygon.length != boundingBox.worldVerticesLength) {\n          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n        }\n        polygons.push(polygon);\n        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n      }\n    }\n    if (updateAabb) {\n      this.aabbCompute();\n    } else {\n      this.minX = Number.POSITIVE_INFINITY;\n      this.minY = Number.POSITIVE_INFINITY;\n      this.maxX = Number.NEGATIVE_INFINITY;\n      this.maxY = Number.NEGATIVE_INFINITY;\n    }\n  }\n  aabbCompute() {\n    let minX = Number.POSITIVE_INFINITY,\n      minY = Number.POSITIVE_INFINITY,\n      maxX = Number.NEGATIVE_INFINITY,\n      maxY = Number.NEGATIVE_INFINITY;\n    let polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      let polygon = polygons[i];\n      let vertices = polygon;\n      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n        let x = vertices[ii];\n        let y = vertices[ii + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n      }\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /** Returns true if the axis aligned bounding box contains the point. */\n  aabbContainsPoint(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n  /** Returns true if the axis aligned bounding box intersects the line segment. */\n  aabbIntersectsSegment(x1, y1, x2, y2) {\n    let minX = this.minX;\n    let minY = this.minY;\n    let maxX = this.maxX;\n    let maxY = this.maxY;\n    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) return false;\n    let m = (y2 - y1) / (x2 - x1);\n    let y = m * (minX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    y = m * (maxX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    let x = (minY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    x = (maxY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    return false;\n  }\n  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n  aabbIntersectsSkeleton(bounds) {\n    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n  }\n  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true. */\n  containsPoint(x, y) {\n    let polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n    return null;\n  }\n  /** Returns true if the polygon contains the point. */\n  containsPointPolygon(polygon, x, y) {\n    let vertices = polygon;\n    let nn = polygon.length;\n    let prevIndex = nn - 2;\n    let inside = false;\n    for (let ii = 0; ii < nn; ii += 2) {\n      let vertexY = vertices[ii + 1];\n      let prevY = vertices[prevIndex + 1];\n      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n        let vertexX = vertices[ii];\n        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n      }\n      prevIndex = ii;\n    }\n    return inside;\n  }\n  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n   * true. */\n  intersectsSegment(x1, y1, x2, y2) {\n    let polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n    return null;\n  }\n  /** Returns true if the polygon contains any part of the line segment. */\n  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {\n    let vertices = polygon;\n    let nn = polygon.length;\n    let width12 = x1 - x2,\n      height12 = y1 - y2;\n    let det1 = x1 * y2 - y1 * x2;\n    let x3 = vertices[nn - 2],\n      y3 = vertices[nn - 1];\n    for (let ii = 0; ii < nn; ii += 2) {\n      let x4 = vertices[ii],\n        y4 = vertices[ii + 1];\n      let det2 = x3 * y4 - y3 * x4;\n      let width34 = x3 - x4,\n        height34 = y3 - y4;\n      let det3 = width12 * height34 - height12 * width34;\n      let x = (det1 * width34 - width12 * det2) / det3;\n      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n        let y = (det1 * height34 - height12 * det2) / det3;\n        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n      }\n      x3 = x4;\n      y3 = y4;\n    }\n    return false;\n  }\n  /** Returns the polygon for the specified bounding box, or null. */\n  getPolygon(boundingBox) {\n    if (!boundingBox) throw new Error(\"boundingBox cannot be null.\");\n    let index = this.boundingBoxes.indexOf(boundingBox);\n    return index == -1 ? null : this.polygons[index];\n  }\n  /** The width of the axis aligned bounding box. */\n  getWidth() {\n    return this.maxX - this.minX;\n  }\n  /** The height of the axis aligned bounding box. */\n  getHeight() {\n    return this.maxY - this.minY;\n  }\n}","map":{"version":3,"names":["BoundingBoxAttachment","Pool","Utils","SkeletonBounds","constructor","_defineProperty","Array","newFloatArray","update","skeleton","updateAabb","Error","boundingBoxes","polygons","polygonPool","slots","slotCount","length","freeAll","i","slot","bone","active","attachment","getAttachment","boundingBox","push","polygon","obtain","worldVerticesLength","computeWorldVertices","aabbCompute","minX","Number","POSITIVE_INFINITY","minY","maxX","NEGATIVE_INFINITY","maxY","n","vertices","ii","nn","x","y","Math","min","max","aabbContainsPoint","aabbIntersectsSegment","x1","y1","x2","y2","m","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","prevY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","index","indexOf","getWidth","getHeight"],"sources":["../src/SkeletonBounds.ts"],"sourcesContent":[null],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}