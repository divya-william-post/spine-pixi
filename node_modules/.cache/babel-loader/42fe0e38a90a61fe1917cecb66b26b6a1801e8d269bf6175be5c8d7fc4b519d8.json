{"ast":null,"code":"var MixBlend = /* @__PURE__ */(MixBlend2 => {\n  MixBlend2[MixBlend2[\"setup\"] = 0] = \"setup\";\n  MixBlend2[MixBlend2[\"first\"] = 1] = \"first\";\n  MixBlend2[MixBlend2[\"replace\"] = 2] = \"replace\";\n  MixBlend2[MixBlend2[\"add\"] = 3] = \"add\";\n  return MixBlend2;\n})(MixBlend || {});\nvar MixDirection = /* @__PURE__ */(MixDirection2 => {\n  MixDirection2[MixDirection2[\"mixIn\"] = 0] = \"mixIn\";\n  MixDirection2[MixDirection2[\"mixOut\"] = 1] = \"mixOut\";\n  return MixDirection2;\n})(MixDirection || {});\nexport { MixBlend, MixDirection };","map":{"version":3,"names":["MixBlend","MixBlend2","MixDirection","MixDirection2"],"sources":["../../src/core/IAnimation.ts"],"sourcesContent":["import type { ISkeleton, ISkeletonData } from './ISkeleton';\nimport type { Map } from './Utils';\n\n// Those enums were moved from Animation.ts of spine 3.8 and 4.0\n\n/** Controls how a timeline value is mixed with the setup pose value or current pose value when a timeline's `alpha`\n * < 1.\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixBlend {\n    /** Transitions from the setup value to the timeline value (the current value is not used). Before the first key, the setup\n     * value is set. */\n    setup,\n    /** Transitions from the current value to the timeline value. Before the first key, transitions from the current value to\n     * the setup value. Timelines which perform instant transitions, such as DrawOrderTimeline or\n     * AttachmentTimeline, use the setup value before the first key.\n     *\n     * `first` is intended for the first animations applied, not for animations layered on top of those. */\n    first,\n    /** Transitions from the current value to the timeline value. No change is made before the first key (the current value is\n     * kept until the first key).\n     *\n     * `replace` is intended for animations layered on top of others, not for the first animations applied. */\n    replace,\n    /** Transitions from the current value to the current value plus the timeline value. No change is made before the first key\n     * (the current value is kept until the first key).\n     *\n     * `add` is intended for animations layered on top of others, not for the first animations applied. Properties\n     * keyed by additive animations must be set manually or by another animation before applying the additive animations, else\n     * the property values will increase continually. */\n    add,\n}\n\n/** Indicates whether a timeline's `alpha` is mixing out over time toward 0 (the setup or current pose value) or\n * mixing in toward 1 (the timeline's value).\n *\n * See Timeline {@link Timeline#apply(Skeleton, float, float, Array, float, MixBlend, MixDirection)}.\n * @public\n * */\nexport enum MixDirection {\n    mixIn,\n    mixOut,\n}\n\n/**\n * @public\n */\nexport interface IAnimation<Timeline extends ITimeline = ITimeline> {\n    name: string;\n    timelines: Timeline[];\n    duration: number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationState<AnimationStateData extends IAnimationStateData = IAnimationStateData> {\n    data: AnimationStateData;\n    tracks: ITrackEntry[];\n    listeners: IAnimationStateListener[];\n    timeScale: number;\n\n    update(dt: number): void;\n    apply(skeleton: ISkeleton): boolean;\n\n    setAnimation(trackIndex: number, animationName: string, loop: boolean): ITrackEntry;\n    addAnimation(trackIndex: number, animationName: string, loop: boolean, delay: number): ITrackEntry;\n    addEmptyAnimation(trackIndex: number, mixDuration: number, delay: number): ITrackEntry;\n    setEmptyAnimation(trackIndex: number, mixDuration: number): ITrackEntry;\n    setEmptyAnimations(mixDuration: number): void;\n    hasAnimation(animationName: string): boolean;\n    addListener(listener: IAnimationStateListener): void;\n    removeListener(listener: IAnimationStateListener): void;\n    clearListeners(): void;\n    clearTracks(): void;\n    clearTrack(index: number): void;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateData<SkeletonData extends ISkeletonData = ISkeletonData, Animation extends IAnimation = IAnimation> {\n    skeletonData: SkeletonData;\n    animationToMixTime: Map<number>;\n    defaultMix: number;\n    setMix(fromName: string, toName: string, duration: number): void;\n    setMixWith(from: Animation, to: Animation, duration: number): void;\n    getMix(from: Animation, to: Animation): number;\n}\n\n/**\n * @public\n */\nexport interface IAnimationStateListener {\n    start?(entry: ITrackEntry): void;\n    interrupt?(entry: ITrackEntry): void;\n    end?(entry: ITrackEntry): void;\n    dispose?(entry: ITrackEntry): void;\n    complete?(entry: ITrackEntry): void;\n    event?(entry: ITrackEntry, event: IEvent): void;\n}\n\n/**\n * @public\n */\nexport interface ITimeline {}\n\n/**\n * @public\n */\nexport interface ITrackEntry {\n    trackIndex: number;\n    loop: boolean;\n    animationEnd: number;\n    listener: IAnimationStateListener;\n\n    delay: number;\n    trackTime: number;\n    trackLast: number;\n    nextTrackLast: number;\n    trackEnd: number;\n    timeScale: number;\n    alpha: number;\n    mixTime: number;\n    mixDuration: number;\n    interruptAlpha: number;\n    totalAlpha: number;\n}\n\n/**\n * @public\n */\nexport interface IEventData {\n    name: string;\n}\n\n/**\n * @public\n */\nexport interface IEvent {\n    time: number;\n    data: IEventData;\n}\n"],"mappings":"AAWY,IAAAA,QAAA,mBAAAC,SAAL;EAGHA,SAAA,CAAAA,SAAA;EAMAA,SAAA,CAAAA,SAAA;EAKAA,SAAA,CAAAA,SAAA;EAOAA,SAAA,CAAAA,SAAA;EArBQ,OAAAA,SAAA;AAAA,GAAAD,QAAA;AA8BA,IAAAE,YAAA,mBAAAC,aAAL;EACHA,aAAA,CAAAA,aAAA;EACAA,aAAA,CAAAA,aAAA;EAFQ,OAAAA,aAAA;AAAA,GAAAD,YAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}