{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { StringSet, Pool, MixBlend, Utils, MixDirection, MathUtils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, RotateTimeline, DrawOrderTimeline, Timeline, EventTimeline } from './Animation.mjs';\nconst _AnimationState = class {\n  constructor(data) {\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    this.tracks = new Array();\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    this.timeScale = 1;\n    this.unkeyedState = 0;\n    this.events = new Array();\n    this.listeners = new Array();\n    this.queue = new EventQueue(this);\n    this.propertyIDs = new StringSet();\n    this.animationsChanged = false;\n    this.trackEntryPool = new Pool(() => new TrackEntry());\n    this.data = data;\n  }\n  static emptyAnimation() {\n    return _AnimationState._emptyAnimation;\n  }\n  /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n  update(delta) {\n    delta *= this.timeScale;\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (!current) continue;\n      current.animationLast = current.nextAnimationLast;\n      current.trackLast = current.nextTrackLast;\n      let currentDelta = delta * current.timeScale;\n      if (current.delay > 0) {\n        current.delay -= currentDelta;\n        if (current.delay > 0) continue;\n        currentDelta = -current.delay;\n        current.delay = 0;\n      }\n      let next = current.next;\n      if (next) {\n        const nextTime = current.trackLast - next.delay;\n        if (nextTime >= 0) {\n          next.delay = 0;\n          next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n          current.trackTime += currentDelta;\n          this.setCurrent(i, next, true);\n          while (next.mixingFrom) {\n            next.mixTime += delta;\n            next = next.mixingFrom;\n          }\n          continue;\n        }\n      } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n        tracks[i] = null;\n        this.queue.end(current);\n        this.clearNext(current);\n        continue;\n      }\n      if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n        let from = current.mixingFrom;\n        current.mixingFrom = null;\n        if (from) from.mixingTo = null;\n        while (from) {\n          this.queue.end(from);\n          from = from.mixingFrom;\n        }\n      }\n      current.trackTime += currentDelta;\n    }\n    this.queue.drain();\n  }\n  /** Returns true when all mixing from entries are complete. */\n  updateMixingFrom(to, delta) {\n    const from = to.mixingFrom;\n    if (!from) return true;\n    const finished = this.updateMixingFrom(from, delta);\n    from.animationLast = from.nextAnimationLast;\n    from.trackLast = from.nextTrackLast;\n    if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n      if (from.totalAlpha == 0 || to.mixDuration == 0) {\n        to.mixingFrom = from.mixingFrom;\n        if (from.mixingFrom) from.mixingFrom.mixingTo = to;\n        to.interruptAlpha = from.interruptAlpha;\n        this.queue.end(from);\n      }\n      return finished;\n    }\n    from.trackTime += delta * from.timeScale;\n    to.mixTime += delta;\n    return false;\n  }\n  /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n   * animation state can be applied to multiple skeletons to pose them identically.\n   * @returns True if any animations were applied. */\n  apply(skeleton) {\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    if (this.animationsChanged) this._animationsChanged();\n    const events = this.events;\n    const tracks = this.tracks;\n    let applied = false;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      const current = tracks[i];\n      if (!current || current.delay > 0) continue;\n      applied = true;\n      const blend = i == 0 ? MixBlend.first : current.mixBlend;\n      let mix = current.alpha;\n      if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\n      const animationLast = current.animationLast;\n      const animationTime = current.getAnimationTime();\n      let applyTime = animationTime;\n      let applyEvents = events;\n      if (current.reverse) {\n        applyTime = current.animation.duration - applyTime;\n        applyEvents = null;\n      }\n      const timelines = current.animation.timelines;\n      const timelineCount = timelines.length;\n      if (i == 0 && mix == 1 || blend == MixBlend.add) {\n        for (let ii = 0; ii < timelineCount; ii++) {\n          Utils.webkit602BugfixHelper(mix, blend);\n          const timeline = timelines[ii];\n          if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n        }\n      } else {\n        const timelineMode = current.timelineMode;\n        const shortestRotation = current.shortestRotation;\n        const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\n        if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n        for (let ii = 0; ii < timelineCount; ii++) {\n          const timeline = timelines[ii];\n          const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n          if (!shortestRotation && timeline instanceof RotateTimeline) {\n            this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n          } else if (timeline instanceof AttachmentTimeline) {\n            this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n          } else {\n            Utils.webkit602BugfixHelper(mix, blend);\n            timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n          }\n        }\n      }\n      this.queueEvents(current, animationTime);\n      events.length = 0;\n      current.nextAnimationLast = animationTime;\n      current.nextTrackLast = current.trackTime;\n    }\n    const setupState = this.unkeyedState + SETUP;\n    const slots = skeleton.slots;\n    for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n      const slot = slots[i];\n      if (slot.attachmentState == setupState) {\n        const attachmentName = slot.data.attachmentName;\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n      }\n    }\n    this.unkeyedState += 2;\n    this.queue.drain();\n    return applied;\n  }\n  applyMixingFrom(to, skeleton, blend) {\n    const from = to.mixingFrom;\n    if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n    let mix = 0;\n    if (to.mixDuration == 0) {\n      mix = 1;\n      if (blend == MixBlend.first) blend = MixBlend.setup;\n    } else {\n      mix = to.mixTime / to.mixDuration;\n      if (mix > 1) mix = 1;\n      if (blend != MixBlend.first) blend = from.mixBlend;\n    }\n    const attachments = mix < from.attachmentThreshold;\n    const drawOrder = mix < from.drawOrderThreshold;\n    const timelines = from.animation.timelines;\n    const timelineCount = timelines.length;\n    const alphaHold = from.alpha * to.interruptAlpha;\n    const alphaMix = alphaHold * (1 - mix);\n    const animationLast = from.animationLast;\n    const animationTime = from.getAnimationTime();\n    let applyTime = animationTime;\n    let events = null;\n    if (from.reverse) applyTime = from.animation.duration - applyTime;else if (mix < from.eventThreshold) events = this.events;\n    if (blend == MixBlend.add) {\n      for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n    } else {\n      const timelineMode = from.timelineMode;\n      const timelineHoldMix = from.timelineHoldMix;\n      const shortestRotation = from.shortestRotation;\n      const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\n      if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n      from.totalAlpha = 0;\n      for (let i = 0; i < timelineCount; i++) {\n        const timeline = timelines[i];\n        let direction = MixDirection.mixOut;\n        let timelineBlend;\n        let alpha = 0;\n        switch (timelineMode[i]) {\n          case SUBSEQUENT:\n            if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n            timelineBlend = blend;\n            alpha = alphaMix;\n            break;\n          case FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaMix;\n            break;\n          case HOLD_SUBSEQUENT:\n            timelineBlend = blend;\n            alpha = alphaHold;\n            break;\n          case HOLD_FIRST:\n            timelineBlend = MixBlend.setup;\n            alpha = alphaHold;\n            break;\n          default:\n            timelineBlend = MixBlend.setup;\n            const holdMix = timelineHoldMix[i];\n            alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n            break;\n        }\n        from.totalAlpha += alpha;\n        if (!shortestRotation && timeline instanceof RotateTimeline) this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);else {\n          Utils.webkit602BugfixHelper(alpha, blend);\n          if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n          timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n        }\n      }\n    }\n    if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n    this.events.length = 0;\n    from.nextAnimationLast = animationTime;\n    from.nextTrackLast = from.trackTime;\n    return mix;\n  }\n  applyAttachmentTimeline(timeline, skeleton, time, blend, attachments) {\n    const slot = skeleton.slots[timeline.slotIndex];\n    if (!slot.bone.active) return;\n    if (time < timeline.frames[0]) {\n      if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n    } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\n    if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n  }\n  setAttachment(skeleton, slot, attachmentName, attachments) {\n    slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n    if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n  }\n  applyRotateTimeline(timeline, skeleton, time, alpha, blend, timelinesRotation, i, firstFrame) {\n    if (firstFrame) timelinesRotation[i] = 0;\n    if (alpha == 1) {\n      timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n      return;\n    }\n    const bone = skeleton.bones[timeline.boneIndex];\n    if (!bone.active) return;\n    const frames = timeline.frames;\n    let r1 = 0;\n    let r2 = 0;\n    if (time < frames[0]) {\n      switch (blend) {\n        case MixBlend.setup:\n          bone.rotation = bone.data.rotation;\n        default:\n          return;\n        case MixBlend.first:\n          r1 = bone.rotation;\n          r2 = bone.data.rotation;\n      }\n    } else {\n      r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n      r2 = bone.data.rotation + timeline.getCurveValue(time);\n    }\n    let total = 0;\n    let diff = r2 - r1;\n    diff -= (16384 - (16384.499999999996 - diff / 360 | 0)) * 360;\n    if (diff == 0) {\n      total = timelinesRotation[i];\n    } else {\n      let lastTotal = 0;\n      let lastDiff = 0;\n      if (firstFrame) {\n        lastTotal = 0;\n        lastDiff = diff;\n      } else {\n        lastTotal = timelinesRotation[i];\n        lastDiff = timelinesRotation[i + 1];\n      }\n      const current = diff > 0;\n      let dir = lastTotal >= 0;\n      if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n        if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n        dir = current;\n      }\n      total = diff + lastTotal - lastTotal % 360;\n      if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n      timelinesRotation[i] = total;\n    }\n    timelinesRotation[i + 1] = diff;\n    bone.rotation = r1 + total * alpha;\n  }\n  queueEvents(entry, animationTime) {\n    const animationStart = entry.animationStart;\n    const animationEnd = entry.animationEnd;\n    const duration = animationEnd - animationStart;\n    const trackLastWrapped = entry.trackLast % duration;\n    const events = this.events;\n    let i = 0;\n    const n = events.length;\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < trackLastWrapped) break;\n      if (event.time > animationEnd) continue;\n      this.queue.event(entry, event);\n    }\n    let complete = false;\n    if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n    if (complete) this.queue.complete(entry);\n    for (; i < n; i++) {\n      const event = events[i];\n      if (event.time < animationStart) continue;\n      this.queue.event(entry, event);\n    }\n  }\n  /** Removes all animations from all tracks, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTracks() {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n    this.tracks.length = 0;\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  /** Removes all animations from the track, leaving skeletons in their current pose.\n   *\n   * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n   * rather than leaving them in their current pose. */\n  clearTrack(trackIndex) {\n    if (trackIndex >= this.tracks.length) return;\n    const current = this.tracks[trackIndex];\n    if (!current) return;\n    this.queue.end(current);\n    this.clearNext(current);\n    let entry = current;\n    while (true) {\n      const from = entry.mixingFrom;\n      if (!from) break;\n      this.queue.end(from);\n      entry.mixingFrom = null;\n      entry.mixingTo = null;\n      entry = from;\n    }\n    this.tracks[current.trackIndex] = null;\n    this.queue.drain();\n  }\n  setCurrent(index, current, interrupt) {\n    const from = this.expandToIndex(index);\n    this.tracks[index] = current;\n    current.previous = null;\n    if (from) {\n      if (interrupt) this.queue.interrupt(from);\n      current.mixingFrom = from;\n      from.mixingTo = current;\n      current.mixTime = 0;\n      if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n      from.timelinesRotation.length = 0;\n    }\n    this.queue.start(current);\n  }\n  /** Sets an animation by name.\n   *\n   * See {@link #setAnimationWith()}. */\n  setAnimation(trackIndex, animationName, loop = false) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation) throw new Error(`Animation not found: ${animationName}`);\n    return this.setAnimationWith(trackIndex, animation, loop);\n  }\n  /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n   * applied to a skeleton, it is replaced (not mixed from).\n   * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n   *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  setAnimationWith(trackIndex, animation, loop = false) {\n    if (!animation) throw new Error(\"animation cannot be null.\");\n    let interrupt = true;\n    let current = this.expandToIndex(trackIndex);\n    if (current) {\n      if (current.nextTrackLast == -1) {\n        this.tracks[trackIndex] = current.mixingFrom;\n        this.queue.interrupt(current);\n        this.queue.end(current);\n        this.clearNext(current);\n        current = current.mixingFrom;\n        interrupt = false;\n      } else this.clearNext(current);\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, current);\n    this.setCurrent(trackIndex, entry, interrupt);\n    this.queue.drain();\n    return entry;\n  }\n  /** Queues an animation by name.\n   *\n   * See {@link #addAnimationWith()}. */\n  addAnimation(trackIndex, animationName, loop = false, delay = 0) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    if (!animation) throw new Error(`Animation not found: ${animationName}`);\n    return this.addAnimationWith(trackIndex, animation, loop, delay);\n  }\n  /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n   * equivalent to calling {@link #setAnimationWith()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n   *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n   *           previous entry is looping, its next loop completion is used instead of its duration.\n   * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addAnimationWith(trackIndex, animation, loop = false, delay = 0) {\n    if (!animation) throw new Error(\"animation cannot be null.\");\n    let last = this.expandToIndex(trackIndex);\n    if (last) {\n      while (last.next) last = last.next;\n    }\n    const entry = this.trackEntry(trackIndex, animation, loop, last);\n    if (!last) {\n      this.setCurrent(trackIndex, entry, true);\n      this.queue.drain();\n    } else {\n      last.next = entry;\n      entry.previous = last;\n      if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n    }\n    entry.delay = delay;\n    return entry;\n  }\n  /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n   * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n   *\n   * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n   * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n   * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n   * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n   * 0 still mixes out over one frame.\n   *\n   * Mixing in is done by first setting an empty animation, then adding an animation using\n   * {@link #addAnimation()} and on the returned track entry, set the\n   * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n   * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n   * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n  setEmptyAnimation(trackIndex, mixDuration = 0) {\n    const entry = this.setAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false);\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n   * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n   * {@link #setEmptyAnimation()}.\n   *\n   * See {@link #setEmptyAnimation()}.\n   * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n   *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n   *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n   *           loop completion is used instead of its duration.\n   * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n   *         after the {@link AnimationStateListener#dispose()} event occurs. */\n  addEmptyAnimation(trackIndex, mixDuration = 0, delay = 0) {\n    const entry = this.addAnimationWith(trackIndex, _AnimationState.emptyAnimation(), false, delay);\n    if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\n    entry.mixDuration = mixDuration;\n    entry.trackEnd = mixDuration;\n    return entry;\n  }\n  /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n   * duration. */\n  setEmptyAnimations(mixDuration = 0) {\n    const oldDrainDisabled = this.queue.drainDisabled;\n    this.queue.drainDisabled = true;\n    for (let i = 0, n = this.tracks.length; i < n; i++) {\n      const current = this.tracks[i];\n      if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n    }\n    this.queue.drainDisabled = oldDrainDisabled;\n    this.queue.drain();\n  }\n  expandToIndex(index) {\n    if (index < this.tracks.length) return this.tracks[index];\n    Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n    this.tracks.length = index + 1;\n    return null;\n  }\n  /** @param last May be null. */\n  trackEntry(trackIndex, animation, loop, last) {\n    const entry = this.trackEntryPool.obtain();\n    entry.reset();\n    entry.trackIndex = trackIndex;\n    entry.animation = animation;\n    entry.loop = loop;\n    entry.holdPrevious = false;\n    entry.reverse = false;\n    entry.shortestRotation = false;\n    entry.eventThreshold = 0;\n    entry.attachmentThreshold = 0;\n    entry.drawOrderThreshold = 0;\n    entry.animationStart = 0;\n    entry.animationEnd = animation.duration;\n    entry.animationLast = -1;\n    entry.nextAnimationLast = -1;\n    entry.delay = 0;\n    entry.trackTime = 0;\n    entry.trackLast = -1;\n    entry.nextTrackLast = -1;\n    entry.trackEnd = Number.MAX_VALUE;\n    entry.timeScale = 1;\n    entry.alpha = 1;\n    entry.mixTime = 0;\n    entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\n    entry.interruptAlpha = 1;\n    entry.totalAlpha = 0;\n    entry.mixBlend = MixBlend.replace;\n    return entry;\n  }\n  /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n  clearNext(entry) {\n    let next = entry.next;\n    while (next) {\n      this.queue.dispose(next);\n      next = next.next;\n    }\n    entry.next = null;\n  }\n  _animationsChanged() {\n    this.animationsChanged = false;\n    this.propertyIDs.clear();\n    const tracks = this.tracks;\n    for (let i = 0, n = tracks.length; i < n; i++) {\n      let entry = tracks[i];\n      if (!entry) continue;\n      while (entry.mixingFrom) entry = entry.mixingFrom;\n      do {\n        if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n        entry = entry.mixingTo;\n      } while (entry);\n    }\n  }\n  computeHold(entry) {\n    const to = entry.mixingTo;\n    const timelines = entry.animation.timelines;\n    const timelinesCount = entry.animation.timelines.length;\n    const timelineMode = entry.timelineMode;\n    timelineMode.length = timelinesCount;\n    const timelineHoldMix = entry.timelineHoldMix;\n    timelineHoldMix.length = 0;\n    const propertyIDs = this.propertyIDs;\n    if (to && to.holdPrevious) {\n      for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n      return;\n    }\n    outer: for (let i = 0; i < timelinesCount; i++) {\n      const timeline = timelines[i];\n      const ids = timeline.getPropertyIds();\n      if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;else if (!to || timeline instanceof AttachmentTimeline || timeline instanceof DrawOrderTimeline || timeline instanceof EventTimeline || !to.animation.hasTimeline(ids)) {\n        timelineMode[i] = FIRST;\n      } else {\n        for (let next = to.mixingTo; next; next = next.mixingTo) {\n          if (next.animation.hasTimeline(ids)) continue;\n          if (entry.mixDuration > 0) {\n            timelineMode[i] = HOLD_MIX;\n            timelineHoldMix[i] = next;\n            continue outer;\n          }\n          break;\n        }\n        timelineMode[i] = HOLD_FIRST;\n      }\n    }\n  }\n  /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n  getCurrent(trackIndex) {\n    if (trackIndex >= this.tracks.length) return null;\n    return this.tracks[trackIndex];\n  }\n  /** Adds a listener to receive events for all track entries. */\n  addListener(listener) {\n    if (!listener) throw new Error(\"listener cannot be null.\");\n    this.listeners.push(listener);\n  }\n  /** Removes the listener added with {@link #addListener()}. */\n  removeListener(listener) {\n    const index = this.listeners.indexOf(listener);\n    if (index >= 0) this.listeners.splice(index, 1);\n  }\n  /** Removes all listeners added with {@link #addListener()}. */\n  clearListeners() {\n    this.listeners.length = 0;\n  }\n  /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n   * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n   * are not wanted because new animations are being set. */\n  clearListenerNotifications() {\n    this.queue.clear();\n  }\n  setAnimationByName(trackIndex, animationName, loop) {\n    if (!_AnimationState.deprecatedWarning1) {\n      _AnimationState.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.\");\n    }\n    this.setAnimation(trackIndex, animationName, loop);\n  }\n  addAnimationByName(trackIndex, animationName, loop, delay) {\n    if (!_AnimationState.deprecatedWarning2) {\n      _AnimationState.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.\");\n    }\n    this.addAnimation(trackIndex, animationName, loop, delay);\n  }\n  hasAnimation(animationName) {\n    const animation = this.data.skeletonData.findAnimation(animationName);\n    return animation !== null;\n  }\n  hasAnimationByName(animationName) {\n    if (!_AnimationState.deprecatedWarning3) {\n      _AnimationState.deprecatedWarning3 = true;\n      console.warn(\"Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.\");\n    }\n    return this.hasAnimation(animationName);\n  }\n};\nlet AnimationState = _AnimationState;\nAnimationState._emptyAnimation = new Animation(\"<empty>\", [], 0);\nAnimationState.deprecatedWarning1 = false;\nAnimationState.deprecatedWarning2 = false;\nAnimationState.deprecatedWarning3 = false;\nconst _TrackEntry = class {\n  constructor() {\n    /** The animation to apply for this track entry. */\n    this.animation = null;\n    this.previous = null;\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    this.next = null;\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    this.mixingFrom = null;\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    this.mixingTo = null;\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    this.listener = null;\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    this.trackIndex = 0;\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    this.loop = false;\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    this.holdPrevious = false;\n    this.reverse = false;\n    this.shortestRotation = false;\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    this.eventThreshold = 0;\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    this.attachmentThreshold = 0;\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    this.drawOrderThreshold = 0;\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    this.animationStart = 0;\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    this.animationEnd = 0;\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    this.animationLast = 0;\n    this.nextAnimationLast = 0;\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    this.delay = 0;\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    this.trackTime = 0;\n    this.trackLast = 0;\n    this.nextTrackLast = 0;\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    this.trackEnd = 0;\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    this.timeScale = 0;\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    this.alpha = 0;\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    this.mixTime = 0;\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    this.mixDuration = 0;\n    this.interruptAlpha = 0;\n    this.totalAlpha = 0;\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    this.mixBlend = MixBlend.replace;\n    this.timelineMode = new Array();\n    this.timelineHoldMix = new Array();\n    this.timelinesRotation = new Array();\n  }\n  reset() {\n    this.next = null;\n    this.previous = null;\n    this.mixingFrom = null;\n    this.mixingTo = null;\n    this.animation = null;\n    this.listener = null;\n    this.timelineMode.length = 0;\n    this.timelineHoldMix.length = 0;\n    this.timelinesRotation.length = 0;\n  }\n  /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n   * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n   * `animationStart` time. */\n  getAnimationTime() {\n    if (this.loop) {\n      const duration = this.animationEnd - this.animationStart;\n      if (duration == 0) return this.animationStart;\n      return this.trackTime % duration + this.animationStart;\n    }\n    return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n  }\n  setAnimationLast(animationLast) {\n    this.animationLast = animationLast;\n    this.nextAnimationLast = animationLast;\n  }\n  /** Returns true if at least one loop has been completed.\n   *\n   * See {@link AnimationStateListener#complete()}. */\n  isComplete() {\n    return this.trackTime >= this.animationEnd - this.animationStart;\n  }\n  /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n   * long way around when using {@link #alpha} and starting animations on other tracks.\n   *\n   * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n   * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n   * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n   * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n  resetRotationDirections() {\n    this.timelinesRotation.length = 0;\n  }\n  getTrackComplete() {\n    const duration = this.animationEnd - this.animationStart;\n    if (duration != 0) {\n      if (this.loop) return duration * (1 + (this.trackTime / duration | 0));\n      if (this.trackTime < duration) return duration;\n    }\n    return this.trackTime;\n  }\n  get time() {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    return this.trackTime;\n  }\n  set time(value) {\n    if (!_TrackEntry.deprecatedWarning1) {\n      _TrackEntry.deprecatedWarning1 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.\");\n    }\n    this.trackTime = value;\n  }\n  get endTime() {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    return this.trackTime;\n  }\n  set endTime(value) {\n    if (!_TrackEntry.deprecatedWarning2) {\n      _TrackEntry.deprecatedWarning2 = true;\n      console.warn(\"Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.\");\n    }\n    this.trackTime = value;\n  }\n  loopsCount() {\n    return Math.floor(this.trackTime / this.trackEnd);\n  }\n};\nlet TrackEntry = _TrackEntry;\nTrackEntry.deprecatedWarning1 = false;\nTrackEntry.deprecatedWarning2 = false;\nclass EventQueue {\n  constructor(animState) {\n    this.objects = [];\n    this.drainDisabled = false;\n    this.animState = animState;\n  }\n  start(entry) {\n    this.objects.push(EventType.start);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  interrupt(entry) {\n    this.objects.push(EventType.interrupt);\n    this.objects.push(entry);\n  }\n  end(entry) {\n    this.objects.push(EventType.end);\n    this.objects.push(entry);\n    this.animState.animationsChanged = true;\n  }\n  dispose(entry) {\n    this.objects.push(EventType.dispose);\n    this.objects.push(entry);\n  }\n  complete(entry) {\n    this.objects.push(EventType.complete);\n    this.objects.push(entry);\n  }\n  event(entry, event) {\n    this.objects.push(EventType.event);\n    this.objects.push(entry);\n    this.objects.push(event);\n  }\n  drain() {\n    if (this.drainDisabled) return;\n    this.drainDisabled = true;\n    const objects = this.objects;\n    const listeners = this.animState.listeners;\n    for (let i = 0; i < objects.length; i += 2) {\n      const type = objects[i];\n      const entry = objects[i + 1];\n      switch (type) {\n        case EventType.start:\n          if (entry.listener && entry.listener.start) entry.listener.start(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.start) listener.start(entry);\n          }\n          break;\n        case EventType.interrupt:\n          if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.interrupt) listener.interrupt(entry);\n          }\n          break;\n        case EventType.end:\n          if (entry.listener && entry.listener.end) entry.listener.end(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.end) listener.end(entry);\n          }\n        case EventType.dispose:\n          if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.dispose) listener.dispose(entry);\n          }\n          this.animState.trackEntryPool.free(entry);\n          break;\n        case EventType.complete:\n          if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.complete) listener.complete(entry);\n          }\n          break;\n        case EventType.event:\n          const event = objects[i++ + 2];\n          if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\n          for (let ii = 0; ii < listeners.length; ii++) {\n            const listener = listeners[ii];\n            if (listener.event) listener.event(entry, event);\n          }\n          break;\n      }\n    }\n    this.clear();\n    this.drainDisabled = false;\n  }\n  clear() {\n    this.objects.length = 0;\n  }\n}\nvar EventType = /* @__PURE__ */(EventType2 => {\n  EventType2[EventType2[\"start\"] = 0] = \"start\";\n  EventType2[EventType2[\"interrupt\"] = 1] = \"interrupt\";\n  EventType2[EventType2[\"end\"] = 2] = \"end\";\n  EventType2[EventType2[\"dispose\"] = 3] = \"dispose\";\n  EventType2[EventType2[\"complete\"] = 4] = \"complete\";\n  EventType2[EventType2[\"event\"] = 5] = \"event\";\n  return EventType2;\n})(EventType || {});\nclass AnimationStateAdapter {\n  start(entry) {}\n  interrupt(entry) {}\n  end(entry) {}\n  dispose(entry) {}\n  complete(entry) {}\n  event(entry, event) {}\n}\nconst SUBSEQUENT = 0;\nconst FIRST = 1;\nconst HOLD_SUBSEQUENT = 2;\nconst HOLD_FIRST = 3;\nconst HOLD_MIX = 4;\nconst SETUP = 1;\nconst CURRENT = 2;\nexport { AnimationState, AnimationStateAdapter, EventQueue, EventType, TrackEntry };","map":{"version":3,"names":["_AnimationState","constructor","data","tracks","Array","timeScale","unkeyedState","events","listeners","queue","EventQueue","propertyIDs","StringSet","animationsChanged","trackEntryPool","Pool","TrackEntry","emptyAnimation","_emptyAnimation","update","delta","i","n","length","current","animationLast","nextAnimationLast","trackLast","nextTrackLast","currentDelta","delay","next","nextTime","trackTime","setCurrent","mixingFrom","mixTime","trackEnd","end","clearNext","updateMixingFrom","from","mixingTo","drain","to","finished","mixDuration","totalAlpha","interruptAlpha","apply","skeleton","Error","_animationsChanged","applied","blend","MixBlend","first","mixBlend","mix","alpha","applyMixingFrom","animationTime","getAnimationTime","applyTime","applyEvents","reverse","animation","duration","timelines","timelineCount","add","ii","Utils","webkit602BugfixHelper","timeline","AttachmentTimeline","applyAttachmentTimeline","MixDirection","mixIn","timelineMode","shortestRotation","firstFrame","timelinesRotation","timelineBlend","SUBSEQUENT","setup","RotateTimeline","applyRotateTimeline","queueEvents","setupState","SETUP","slots","slot","attachmentState","attachmentName","setAttachment","getAttachment","index","attachments","attachmentThreshold","drawOrder","drawOrderThreshold","alphaHold","alphaMix","eventThreshold","mixOut","timelineHoldMix","direction","DrawOrderTimeline","FIRST","HOLD_SUBSEQUENT","HOLD_FIRST","holdMix","Math","max","time","slotIndex","bone","active","frames","attachmentNames","Timeline","search1","CURRENT","bones","boneIndex","r1","r2","rotation","getCurveValue","total","diff","lastTotal","lastDiff","dir","MathUtils","signum","abs","entry","animationStart","animationEnd","trackLastWrapped","event","complete","loop","clearTracks","oldDrainDisabled","drainDisabled","clearTrack","trackIndex","interrupt","expandToIndex","previous","min","start","setAnimation","animationName","skeletonData","findAnimation","setAnimationWith","trackEntry","addAnimation","addAnimationWith","last","getTrackComplete","setEmptyAnimation","addEmptyAnimation","setEmptyAnimations","ensureArrayCapacity","obtain","reset","holdPrevious","Number","MAX_VALUE","getMix","replace","dispose","clear","computeHold","timelinesCount","addAll","getPropertyIds","outer","ids","EventTimeline","hasTimeline","HOLD_MIX","getCurrent","addListener","listener","push","removeListener","indexOf","splice","clearListeners","clearListenerNotifications","setAnimationByName","deprecatedWarning1","console","warn","addAnimationByName","deprecatedWarning2","hasAnimation","hasAnimationByName","deprecatedWarning3","AnimationState","Animation","_TrackEntry","setAnimationLast","isComplete","resetRotationDirections","value","endTime","loopsCount","floor","animState","objects","EventType","type","free","EventType2","AnimationStateAdapter"],"sources":["../../src/core/AnimationState.ts"],"sourcesContent":["import { IAnimationState, IAnimationStateListener, ITrackEntry, MathUtils, MixBlend, MixDirection, Pool, StringSet, Utils } from '@pixi-spine/base';\nimport { Animation, AttachmentTimeline, DrawOrderTimeline, EventTimeline, RotateTimeline, Timeline } from './Animation';\nimport type { AnimationStateData } from './AnimationStateData';\nimport type { Event } from './Event';\nimport type { Skeleton } from './Skeleton';\nimport type { Slot } from './Slot';\n\n/** Applies animations over time, queues animations for later playback, mixes (crossfading) between animations, and applies\n * multiple animations on top of each other (layering).\n *\n * See [Applying Animations](http://esotericsoftware.com/spine-applying-animations/) in the Spine Runtimes Guide.\n * @public\n * */\nexport class AnimationState implements IAnimationState<AnimationStateData> {\n    static _emptyAnimation = new Animation('<empty>', [], 0);\n    private static emptyAnimation(): Animation {\n        return AnimationState._emptyAnimation;\n    }\n\n    /** The AnimationStateData to look up mix durations. */\n    data: AnimationStateData;\n\n    /** The list of tracks that currently have animations, which may contain null entries. */\n    tracks = new Array<TrackEntry | null>();\n\n    /** Multiplier for the delta time when the animation state is updated, causing time for all animations and mixes to play slower\n     * or faster. Defaults to 1.\n     *\n     * See TrackEntry {@link TrackEntry#timeScale} for affecting a single animation. */\n    timeScale = 1;\n    unkeyedState = 0;\n\n    events = new Array<Event>();\n    listeners = new Array<AnimationStateListener>();\n    queue = new EventQueue(this);\n    propertyIDs = new StringSet();\n    animationsChanged = false;\n\n    trackEntryPool = new Pool<TrackEntry>(() => new TrackEntry());\n\n    constructor(data: AnimationStateData) {\n        this.data = data;\n    }\n\n    /** Increments each track entry {@link TrackEntry#trackTime()}, setting queued animations as current if needed. */\n    update(delta: number) {\n        delta *= this.timeScale;\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (!current) continue;\n\n            current.animationLast = current.nextAnimationLast;\n            current.trackLast = current.nextTrackLast;\n\n            let currentDelta = delta * current.timeScale;\n\n            if (current.delay > 0) {\n                current.delay -= currentDelta;\n                if (current.delay > 0) continue;\n                currentDelta = -current.delay;\n                current.delay = 0;\n            }\n\n            let next = current.next;\n\n            if (next) {\n                // When the next entry's delay is passed, change to the next entry, preserving leftover time.\n                const nextTime = current.trackLast - next.delay;\n\n                if (nextTime >= 0) {\n                    next.delay = 0;\n                    next.trackTime += current.timeScale == 0 ? 0 : (nextTime / current.timeScale + delta) * next.timeScale;\n                    current.trackTime += currentDelta;\n                    this.setCurrent(i, next, true);\n                    while (next.mixingFrom) {\n                        next.mixTime += delta;\n                        next = next.mixingFrom;\n                    }\n                    continue;\n                }\n            } else if (current.trackLast >= current.trackEnd && !current.mixingFrom) {\n                tracks[i] = null;\n                this.queue.end(current);\n                this.clearNext(current);\n                continue;\n            }\n            if (current.mixingFrom && this.updateMixingFrom(current, delta)) {\n                // End mixing from entries once all have completed.\n                let from: TrackEntry | null = current.mixingFrom;\n\n                current.mixingFrom = null;\n                if (from) from.mixingTo = null;\n                while (from) {\n                    this.queue.end(from);\n                    from = from.mixingFrom;\n                }\n            }\n\n            current.trackTime += currentDelta;\n        }\n\n        this.queue.drain();\n    }\n\n    /** Returns true when all mixing from entries are complete. */\n    updateMixingFrom(to: TrackEntry, delta: number): boolean {\n        const from = to.mixingFrom;\n\n        if (!from) return true;\n\n        const finished = this.updateMixingFrom(from, delta);\n\n        from.animationLast = from.nextAnimationLast;\n        from.trackLast = from.nextTrackLast;\n\n        // Require mixTime > 0 to ensure the mixing from entry was applied at least once.\n        if (to.mixTime > 0 && to.mixTime >= to.mixDuration) {\n            // Require totalAlpha == 0 to ensure mixing is complete, unless mixDuration == 0 (the transition is a single frame).\n            if (from.totalAlpha == 0 || to.mixDuration == 0) {\n                to.mixingFrom = from.mixingFrom;\n                if (from.mixingFrom) from.mixingFrom.mixingTo = to;\n                to.interruptAlpha = from.interruptAlpha;\n                this.queue.end(from);\n            }\n\n            return finished;\n        }\n\n        from.trackTime += delta * from.timeScale;\n        to.mixTime += delta;\n\n        return false;\n    }\n\n    /** Poses the skeleton using the track entry animations. There are no side effects other than invoking listeners, so the\n     * animation state can be applied to multiple skeletons to pose them identically.\n     * @returns True if any animations were applied. */\n    apply(skeleton: Skeleton): boolean {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        if (this.animationsChanged) this._animationsChanged();\n\n        const events = this.events;\n        const tracks = this.tracks;\n        let applied = false;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            const current = tracks[i];\n\n            if (!current || current.delay > 0) continue;\n            applied = true;\n            const blend: MixBlend = i == 0 ? MixBlend.first : current.mixBlend;\n\n            // Apply mixing from entries first.\n            let mix = current.alpha;\n\n            if (current.mixingFrom) mix *= this.applyMixingFrom(current, skeleton, blend);\n            else if (current.trackTime >= current.trackEnd && !current.next) mix = 0;\n\n            // Apply current entry.\n            const animationLast = current.animationLast;\n            const animationTime = current.getAnimationTime();\n            let applyTime = animationTime;\n            let applyEvents: Event[] | null = events;\n\n            if (current.reverse) {\n                applyTime = current.animation.duration - applyTime;\n                applyEvents = null;\n            }\n            const timelines = current.animation.timelines;\n            const timelineCount = timelines.length;\n\n            if ((i == 0 && mix == 1) || blend == MixBlend.add) {\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    // Fixes issue #302 on IOS9 where mix, blend sometimes became undefined and caused assets\n                    // to sometimes stop rendering when using color correction, as their RGBA values become NaN.\n                    // (https://github.com/pixijs/pixi-spine/issues/302)\n                    Utils.webkit602BugfixHelper(mix, blend);\n                    const timeline = timelines[ii];\n\n                    if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n                    else timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, blend, MixDirection.mixIn);\n                }\n            } else {\n                const timelineMode = current.timelineMode;\n\n                const shortestRotation = current.shortestRotation;\n                const firstFrame = !shortestRotation && current.timelinesRotation.length != timelineCount << 1;\n\n                if (firstFrame) current.timelinesRotation.length = timelineCount << 1;\n\n                for (let ii = 0; ii < timelineCount; ii++) {\n                    const timeline = timelines[ii];\n                    const timelineBlend = timelineMode[ii] == SUBSEQUENT ? blend : MixBlend.setup;\n\n                    if (!shortestRotation && timeline instanceof RotateTimeline) {\n                        this.applyRotateTimeline(timeline, skeleton, applyTime, mix, timelineBlend, current.timelinesRotation, ii << 1, firstFrame);\n                    } else if (timeline instanceof AttachmentTimeline) {\n                        this.applyAttachmentTimeline(timeline, skeleton, applyTime, blend, true);\n                    } else {\n                        // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                        Utils.webkit602BugfixHelper(mix, blend);\n                        timeline.apply(skeleton, animationLast, applyTime, applyEvents, mix, timelineBlend, MixDirection.mixIn);\n                    }\n                }\n            }\n            this.queueEvents(current, animationTime);\n            events.length = 0;\n            current.nextAnimationLast = animationTime;\n            current.nextTrackLast = current.trackTime;\n        }\n\n        // Set slots attachments to the setup pose, if needed. This occurs if an animation that is mixing out sets attachments so\n        // subsequent timelines see any deform, but the subsequent timelines don't set an attachment (eg they are also mixing out or\n        // the time is before the first key).\n        const setupState = this.unkeyedState + SETUP;\n        const slots = skeleton.slots;\n\n        for (let i = 0, n = skeleton.slots.length; i < n; i++) {\n            const slot = slots[i];\n\n            if (slot.attachmentState == setupState) {\n                const attachmentName = slot.data.attachmentName;\n\n                slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n            }\n        }\n        this.unkeyedState += 2; // Increasing after each use avoids the need to reset attachmentState for every slot.\n\n        this.queue.drain();\n\n        return applied;\n    }\n\n    applyMixingFrom(to: TrackEntry, skeleton: Skeleton, blend: MixBlend) {\n        const from = to.mixingFrom;\n\n        if (from.mixingFrom) this.applyMixingFrom(from, skeleton, blend);\n\n        let mix = 0;\n\n        if (to.mixDuration == 0) {\n            // Single frame mix to undo mixingFrom changes.\n            mix = 1;\n            if (blend == MixBlend.first) blend = MixBlend.setup;\n        } else {\n            mix = to.mixTime / to.mixDuration;\n            if (mix > 1) mix = 1;\n            if (blend != MixBlend.first) blend = from.mixBlend;\n        }\n\n        const attachments = mix < from.attachmentThreshold;\n        const drawOrder = mix < from.drawOrderThreshold;\n        const timelines = from.animation.timelines;\n        const timelineCount = timelines.length;\n        const alphaHold = from.alpha * to.interruptAlpha;\n        const alphaMix = alphaHold * (1 - mix);\n        const animationLast = from.animationLast;\n        const animationTime = from.getAnimationTime();\n        let applyTime = animationTime;\n        let events = null;\n\n        if (from.reverse) applyTime = from.animation.duration - applyTime;\n        else if (mix < from.eventThreshold) events = this.events;\n\n        if (blend == MixBlend.add) {\n            for (let i = 0; i < timelineCount; i++) timelines[i].apply(skeleton, animationLast, applyTime, events, alphaMix, blend, MixDirection.mixOut);\n        } else {\n            const timelineMode = from.timelineMode;\n            const timelineHoldMix = from.timelineHoldMix;\n\n            const shortestRotation = from.shortestRotation;\n            const firstFrame = !shortestRotation && from.timelinesRotation.length != timelineCount << 1;\n\n            if (firstFrame) from.timelinesRotation.length = timelineCount << 1;\n\n            from.totalAlpha = 0;\n            for (let i = 0; i < timelineCount; i++) {\n                const timeline = timelines[i];\n                let direction = MixDirection.mixOut;\n                let timelineBlend: MixBlend;\n                let alpha = 0;\n\n                switch (timelineMode[i]) {\n                    case SUBSEQUENT:\n                        if (!drawOrder && timeline instanceof DrawOrderTimeline) continue;\n                        timelineBlend = blend;\n                        alpha = alphaMix;\n                        break;\n                    case FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaMix;\n                        break;\n                    case HOLD_SUBSEQUENT:\n                        timelineBlend = blend;\n                        alpha = alphaHold;\n                        break;\n                    case HOLD_FIRST:\n                        timelineBlend = MixBlend.setup;\n                        alpha = alphaHold;\n                        break;\n                    default:\n                        timelineBlend = MixBlend.setup;\n                        const holdMix = timelineHoldMix[i];\n\n                        alpha = alphaHold * Math.max(0, 1 - holdMix.mixTime / holdMix.mixDuration);\n                        break;\n                }\n                from.totalAlpha += alpha;\n\n                if (!shortestRotation && timeline instanceof RotateTimeline)\n                    this.applyRotateTimeline(timeline, skeleton, applyTime, alpha, timelineBlend, from.timelinesRotation, i << 1, firstFrame);\n                else if (timeline instanceof AttachmentTimeline) this.applyAttachmentTimeline(timeline, skeleton, applyTime, timelineBlend, attachments);\n                else {\n                    // This fixes the WebKit 602 specific issue described at http://esotericsoftware.com/forum/iOS-10-disappearing-graphics-10109\n                    Utils.webkit602BugfixHelper(alpha, blend);\n                    if (drawOrder && timeline instanceof DrawOrderTimeline && timelineBlend == MixBlend.setup) direction = MixDirection.mixIn;\n                    timeline.apply(skeleton, animationLast, applyTime, events, alpha, timelineBlend, direction);\n                }\n            }\n        }\n\n        if (to.mixDuration > 0) this.queueEvents(from, animationTime);\n        this.events.length = 0;\n        from.nextAnimationLast = animationTime;\n        from.nextTrackLast = from.trackTime;\n\n        return mix;\n    }\n\n    applyAttachmentTimeline(timeline: AttachmentTimeline, skeleton: Skeleton, time: number, blend: MixBlend, attachments: boolean) {\n        const slot = skeleton.slots[timeline.slotIndex];\n\n        if (!slot.bone.active) return;\n\n        if (time < timeline.frames[0]) {\n            // Time is before first frame.\n            if (blend == MixBlend.setup || blend == MixBlend.first) this.setAttachment(skeleton, slot, slot.data.attachmentName, attachments);\n        } else this.setAttachment(skeleton, slot, timeline.attachmentNames[Timeline.search1(timeline.frames, time)], attachments);\n\n        // If an attachment wasn't set (ie before the first frame or attachments is false), set the setup attachment later.\n        if (slot.attachmentState <= this.unkeyedState) slot.attachmentState = this.unkeyedState + SETUP;\n    }\n\n    setAttachment(skeleton: Skeleton, slot: Slot, attachmentName: string | null, attachments: boolean) {\n        slot.setAttachment(!attachmentName ? null : skeleton.getAttachment(slot.data.index, attachmentName));\n        if (attachments) slot.attachmentState = this.unkeyedState + CURRENT;\n    }\n\n    applyRotateTimeline(\n        timeline: RotateTimeline,\n        skeleton: Skeleton,\n        time: number,\n        alpha: number,\n        blend: MixBlend,\n        timelinesRotation: Array<number>,\n        i: number,\n        firstFrame: boolean\n    ) {\n        if (firstFrame) timelinesRotation[i] = 0;\n\n        if (alpha == 1) {\n            timeline.apply(skeleton, 0, time, null, 1, blend, MixDirection.mixIn);\n\n            return;\n        }\n\n        const bone = skeleton.bones[timeline.boneIndex];\n\n        if (!bone.active) return;\n        const frames = timeline.frames;\n        let r1 = 0;\n        let r2 = 0;\n\n        if (time < frames[0]) {\n            switch (blend) {\n                case MixBlend.setup:\n                    bone.rotation = bone.data.rotation;\n                default:\n                    return;\n                case MixBlend.first:\n                    r1 = bone.rotation;\n                    r2 = bone.data.rotation;\n            }\n        } else {\n            r1 = blend == MixBlend.setup ? bone.data.rotation : bone.rotation;\n            r2 = bone.data.rotation + timeline.getCurveValue(time);\n        }\n\n        // Mix between rotations using the direction of the shortest route on the first frame while detecting crosses.\n        let total = 0;\n        let diff = r2 - r1;\n\n        diff -= (16384 - ((16384.499999999996 - diff / 360) | 0)) * 360;\n        if (diff == 0) {\n            total = timelinesRotation[i];\n        } else {\n            let lastTotal = 0;\n            let lastDiff = 0;\n\n            if (firstFrame) {\n                lastTotal = 0;\n                lastDiff = diff;\n            } else {\n                lastTotal = timelinesRotation[i]; // Angle and direction of mix, including loops.\n                lastDiff = timelinesRotation[i + 1]; // Difference between bones.\n            }\n            const current = diff > 0;\n            let dir = lastTotal >= 0;\n            // Detect cross at 0 (not 180).\n\n            if (MathUtils.signum(lastDiff) != MathUtils.signum(diff) && Math.abs(lastDiff) <= 90) {\n                // A cross after a 360 rotation is a loop.\n                if (Math.abs(lastTotal) > 180) lastTotal += 360 * MathUtils.signum(lastTotal);\n                dir = current;\n            }\n            total = diff + lastTotal - (lastTotal % 360); // Store loops as part of lastTotal.\n            if (dir != current) total += 360 * MathUtils.signum(lastTotal);\n            timelinesRotation[i] = total;\n        }\n        timelinesRotation[i + 1] = diff;\n        bone.rotation = r1 + total * alpha;\n    }\n\n    queueEvents(entry: TrackEntry, animationTime: number) {\n        const animationStart = entry.animationStart;\n        const animationEnd = entry.animationEnd;\n        const duration = animationEnd - animationStart;\n        const trackLastWrapped = entry.trackLast % duration;\n\n        // Queue events before complete.\n        const events = this.events;\n        let i = 0;\n        const n = events.length;\n\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < trackLastWrapped) break;\n            if (event.time > animationEnd) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n\n        // Queue complete if completed a loop iteration or the animation.\n        let complete = false;\n\n        if (entry.loop) complete = duration == 0 || trackLastWrapped > entry.trackTime % duration;\n        else complete = animationTime >= animationEnd && entry.animationLast < animationEnd;\n        if (complete) this.queue.complete(entry);\n\n        // Queue events after complete.\n        for (; i < n; i++) {\n            const event = events[i];\n\n            if (event.time < animationStart) continue; // Discard events outside animation start/end.\n            this.queue.event(entry, event);\n        }\n    }\n\n    /** Removes all animations from all tracks, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTracks() {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) this.clearTrack(i);\n        this.tracks.length = 0;\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    /** Removes all animations from the track, leaving skeletons in their current pose.\n     *\n     * It may be desired to use {@link AnimationState#setEmptyAnimation()} to mix the skeletons back to the setup pose,\n     * rather than leaving them in their current pose. */\n    clearTrack(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return;\n        const current = this.tracks[trackIndex];\n\n        if (!current) return;\n\n        this.queue.end(current);\n\n        this.clearNext(current);\n\n        let entry = current;\n\n        while (true) {\n            const from = entry.mixingFrom;\n\n            if (!from) break;\n            this.queue.end(from);\n            entry.mixingFrom = null;\n            entry.mixingTo = null;\n            entry = from;\n        }\n\n        this.tracks[current.trackIndex] = null;\n\n        this.queue.drain();\n    }\n\n    setCurrent(index: number, current: TrackEntry, interrupt: boolean) {\n        const from = this.expandToIndex(index);\n\n        this.tracks[index] = current;\n        current.previous = null;\n\n        if (from) {\n            if (interrupt) this.queue.interrupt(from);\n            current.mixingFrom = from;\n            from.mixingTo = current;\n            current.mixTime = 0;\n\n            // Store the interrupted mix percentage.\n            if (from.mixingFrom && from.mixDuration > 0) current.interruptAlpha *= Math.min(1, from.mixTime / from.mixDuration);\n\n            from.timelinesRotation.length = 0; // Reset rotation for mixing out, in case entry was mixed in.\n        }\n\n        this.queue.start(current);\n    }\n\n    /** Sets an animation by name.\n     *\n     * See {@link #setAnimationWith()}. */\n    setAnimation(trackIndex: number, animationName: string, loop = false) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.setAnimationWith(trackIndex, animation, loop);\n    }\n\n    /** Sets the current animation for a track, discarding any queued animations. If the formerly current track entry was never\n     * applied to a skeleton, it is replaced (not mixed from).\n     * @param loop If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     *           duration. In either case {@link TrackEntry#trackEnd} determines when the track is cleared.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    setAnimationWith(trackIndex: number, animation: Animation, loop = false) {\n        if (!animation) throw new Error('animation cannot be null.');\n        let interrupt = true;\n        let current = this.expandToIndex(trackIndex);\n\n        if (current) {\n            if (current.nextTrackLast == -1) {\n                // Don't mix from an entry that was never applied.\n                this.tracks[trackIndex] = current.mixingFrom;\n                this.queue.interrupt(current);\n                this.queue.end(current);\n                this.clearNext(current);\n                current = current.mixingFrom;\n                interrupt = false;\n            } else this.clearNext(current);\n        }\n        const entry = this.trackEntry(trackIndex, animation, loop, current);\n\n        this.setCurrent(trackIndex, entry, interrupt);\n        this.queue.drain();\n\n        return entry;\n    }\n\n    /** Queues an animation by name.\n     *\n     * See {@link #addAnimationWith()}. */\n    addAnimation(trackIndex: number, animationName: string, loop = false, delay = 0) {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        if (!animation) throw new Error(`Animation not found: ${animationName}`);\n\n        return this.addAnimationWith(trackIndex, animation, loop, delay);\n    }\n\n    /** Adds an animation to be played after the current or last queued animation for a track. If the track is empty, it is\n     * equivalent to calling {@link #setAnimationWith()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration (from the {@link AnimationStateData}) plus the specified `delay` (ie the mix\n     *           ends at (`delay` = 0) or before (`delay` < 0) the previous track entry duration). If the\n     *           previous entry is looping, its next loop completion is used instead of its duration.\n     * @returns A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addAnimationWith(trackIndex: number, animation: Animation, loop = false, delay = 0) {\n        if (!animation) throw new Error('animation cannot be null.');\n\n        let last = this.expandToIndex(trackIndex);\n\n        if (last) {\n            while (last.next) last = last.next;\n        }\n\n        const entry = this.trackEntry(trackIndex, animation, loop, last);\n\n        if (!last) {\n            this.setCurrent(trackIndex, entry, true);\n            this.queue.drain();\n        } else {\n            last.next = entry;\n            entry.previous = last;\n            if (delay <= 0) delay += last.getTrackComplete() - entry.mixDuration;\n        }\n\n        entry.delay = delay;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for a track, discarding any queued animations, and sets the track entry's\n     * {@link TrackEntry#mixduration}. An empty animation has no timelines and serves as a placeholder for mixing in or out.\n     *\n     * Mixing out is done by setting an empty animation with a mix duration using either {@link #setEmptyAnimation()},\n     * {@link #setEmptyAnimations()}, or {@link #addEmptyAnimation()}. Mixing to an empty animation causes\n     * the previous animation to be applied less and less over the mix duration. Properties keyed in the previous animation\n     * transition to the value from lower tracks or to the setup pose value if no lower tracks key the property. A mix duration of\n     * 0 still mixes out over one frame.\n     *\n     * Mixing in is done by first setting an empty animation, then adding an animation using\n     * {@link #addAnimation()} and on the returned track entry, set the\n     * {@link TrackEntry#setMixDuration()}. Mixing from an empty animation causes the new animation to be applied more and\n     * more over the mix duration. Properties keyed in the new animation transition from the value from lower tracks or from the\n     * setup pose value if no lower tracks key the property to the value keyed in the new animation. */\n    setEmptyAnimation(trackIndex: number, mixDuration = 0) {\n        const entry = this.setAnimationWith(trackIndex, AnimationState.emptyAnimation(), false);\n\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Adds an empty animation to be played after the current or last queued animation for a track, and sets the track entry's\n     * {@link TrackEntry#mixDuration}. If the track is empty, it is equivalent to calling\n     * {@link #setEmptyAnimation()}.\n     *\n     * See {@link #setEmptyAnimation()}.\n     * @param delay If > 0, sets {@link TrackEntry#delay}. If <= 0, the delay set is the duration of the previous track entry\n     *           minus any mix duration plus the specified `delay` (ie the mix ends at (`delay` = 0) or\n     *           before (`delay` < 0) the previous track entry duration). If the previous entry is looping, its next\n     *           loop completion is used instead of its duration.\n     * @return A track entry to allow further customization of animation playback. References to the track entry must not be kept\n     *         after the {@link AnimationStateListener#dispose()} event occurs. */\n    addEmptyAnimation(trackIndex: number, mixDuration = 0, delay = 0) {\n        const entry = this.addAnimationWith(trackIndex, AnimationState.emptyAnimation(), false, delay);\n\n        if (delay <= 0) entry.delay += entry.mixDuration - mixDuration;\n        entry.mixDuration = mixDuration;\n        entry.trackEnd = mixDuration;\n\n        return entry;\n    }\n\n    /** Sets an empty animation for every track, discarding any queued animations, and mixes to it over the specified mix\n     * duration. */\n    setEmptyAnimations(mixDuration = 0) {\n        const oldDrainDisabled = this.queue.drainDisabled;\n\n        this.queue.drainDisabled = true;\n        for (let i = 0, n = this.tracks.length; i < n; i++) {\n            const current = this.tracks[i];\n\n            if (current) this.setEmptyAnimation(current.trackIndex, mixDuration);\n        }\n        this.queue.drainDisabled = oldDrainDisabled;\n        this.queue.drain();\n    }\n\n    expandToIndex(index: number) {\n        if (index < this.tracks.length) return this.tracks[index];\n        Utils.ensureArrayCapacity(this.tracks, index + 1, null);\n        this.tracks.length = index + 1;\n\n        return null;\n    }\n\n    /** @param last May be null. */\n    trackEntry(trackIndex: number, animation: Animation, loop: boolean, last: TrackEntry | null) {\n        const entry = this.trackEntryPool.obtain();\n\n        entry.reset();\n        entry.trackIndex = trackIndex;\n        entry.animation = animation;\n        entry.loop = loop;\n        entry.holdPrevious = false;\n\n        entry.reverse = false;\n        entry.shortestRotation = false;\n\n        entry.eventThreshold = 0;\n        entry.attachmentThreshold = 0;\n        entry.drawOrderThreshold = 0;\n\n        entry.animationStart = 0;\n        entry.animationEnd = animation.duration;\n        entry.animationLast = -1;\n        entry.nextAnimationLast = -1;\n\n        entry.delay = 0;\n        entry.trackTime = 0;\n        entry.trackLast = -1;\n        entry.nextTrackLast = -1;\n        entry.trackEnd = Number.MAX_VALUE;\n        entry.timeScale = 1;\n\n        entry.alpha = 1;\n        entry.mixTime = 0;\n        entry.mixDuration = !last ? 0 : this.data.getMix(last.animation, animation);\n        entry.interruptAlpha = 1;\n        entry.totalAlpha = 0;\n        entry.mixBlend = MixBlend.replace;\n\n        return entry;\n    }\n\n    /** Removes the {@link TrackEntry#getNext() next entry} and all entries after it for the specified entry. */\n    clearNext(entry: TrackEntry) {\n        let next = entry.next;\n\n        while (next) {\n            this.queue.dispose(next);\n            next = next.next;\n        }\n        entry.next = null;\n    }\n\n    _animationsChanged() {\n        this.animationsChanged = false;\n\n        this.propertyIDs.clear();\n        const tracks = this.tracks;\n\n        for (let i = 0, n = tracks.length; i < n; i++) {\n            let entry = tracks[i];\n\n            if (!entry) continue;\n            while (entry.mixingFrom) entry = entry.mixingFrom;\n            do {\n                if (!entry.mixingTo || entry.mixBlend != MixBlend.add) this.computeHold(entry);\n                entry = entry.mixingTo;\n            } while (entry);\n        }\n    }\n\n    computeHold(entry: TrackEntry) {\n        const to = entry.mixingTo;\n        const timelines = entry.animation.timelines;\n        const timelinesCount = entry.animation.timelines.length;\n        const timelineMode = entry.timelineMode;\n\n        timelineMode.length = timelinesCount;\n        const timelineHoldMix = entry.timelineHoldMix;\n\n        timelineHoldMix.length = 0;\n        const propertyIDs = this.propertyIDs;\n\n        if (to && to.holdPrevious) {\n            for (let i = 0; i < timelinesCount; i++) timelineMode[i] = propertyIDs.addAll(timelines[i].getPropertyIds()) ? HOLD_FIRST : HOLD_SUBSEQUENT;\n\n            return;\n        }\n\n        // eslint-disable-next-line no-restricted-syntax, no-labels\n        outer: for (let i = 0; i < timelinesCount; i++) {\n            const timeline = timelines[i];\n            const ids = timeline.getPropertyIds();\n\n            if (!propertyIDs.addAll(ids)) timelineMode[i] = SUBSEQUENT;\n            else if (\n                !to ||\n                timeline instanceof AttachmentTimeline ||\n                timeline instanceof DrawOrderTimeline ||\n                timeline instanceof EventTimeline ||\n                !to.animation.hasTimeline(ids)\n            ) {\n                timelineMode[i] = FIRST;\n            } else {\n                for (let next = to.mixingTo; next; next = next.mixingTo) {\n                    if (next.animation.hasTimeline(ids)) continue;\n                    if (entry.mixDuration > 0) {\n                        timelineMode[i] = HOLD_MIX;\n                        timelineHoldMix[i] = next;\n                        // eslint-disable-next-line no-labels\n                        continue outer;\n                    }\n                    break;\n                }\n                timelineMode[i] = HOLD_FIRST;\n            }\n        }\n    }\n\n    /** Returns the track entry for the animation currently playing on the track, or null if no animation is currently playing. */\n    getCurrent(trackIndex: number) {\n        if (trackIndex >= this.tracks.length) return null;\n\n        return this.tracks[trackIndex];\n    }\n\n    /** Adds a listener to receive events for all track entries. */\n    addListener(listener: AnimationStateListener) {\n        if (!listener) throw new Error('listener cannot be null.');\n        this.listeners.push(listener);\n    }\n\n    /** Removes the listener added with {@link #addListener()}. */\n    removeListener(listener: AnimationStateListener) {\n        const index = this.listeners.indexOf(listener);\n\n        if (index >= 0) this.listeners.splice(index, 1);\n    }\n\n    /** Removes all listeners added with {@link #addListener()}. */\n    clearListeners() {\n        this.listeners.length = 0;\n    }\n\n    /** Discards all listener notifications that have not yet been delivered. This can be useful to call from an\n     * {@link AnimationStateListener} when it is known that further notifications that may have been already queued for delivery\n     * are not wanted because new animations are being set. */\n    clearListenerNotifications() {\n        this.queue.clear();\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1 = false;\n\n    setAnimationByName(trackIndex: number, animationName: string, loop: boolean) {\n        if (!AnimationState.deprecatedWarning1) {\n            AnimationState.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.setAnimationByName is deprecated, please use setAnimation from now on.');\n        }\n        this.setAnimation(trackIndex, animationName, loop);\n    }\n\n    private static deprecatedWarning2 = false;\n\n    addAnimationByName(trackIndex: number, animationName: string, loop: boolean, delay: number) {\n        if (!AnimationState.deprecatedWarning2) {\n            AnimationState.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.addAnimationByName is deprecated, please use addAnimation from now on.');\n        }\n        this.addAnimation(trackIndex, animationName, loop, delay);\n    }\n\n    private static deprecatedWarning3 = false;\n\n    hasAnimation(animationName: string): boolean {\n        const animation = this.data.skeletonData.findAnimation(animationName);\n\n        return animation !== null;\n    }\n\n    hasAnimationByName(animationName: string): boolean {\n        if (!AnimationState.deprecatedWarning3) {\n            AnimationState.deprecatedWarning3 = true;\n            console.warn('Spine Deprecation Warning: AnimationState.hasAnimationByName is deprecated, please use hasAnimation from now on.');\n        }\n\n        return this.hasAnimation(animationName);\n    }\n}\n\n/** Stores settings and other state for the playback of an animation on an {@link AnimationState} track.\n *\n * References to a track entry must not be kept after the {@link AnimationStateListener#dispose()} event occurs.\n * @public\n * */\nexport class TrackEntry implements ITrackEntry {\n    /** The animation to apply for this track entry. */\n    animation: Animation | null = null;\n\n    previous: TrackEntry | null = null;\n\n    /** The animation queued to start after this animation, or null. `next` makes up a linked list. */\n    next: TrackEntry | null = null;\n\n    /** The track entry for the previous animation when mixing from the previous animation to this animation, or null if no\n     * mixing is currently occuring. When mixing from multiple animations, `mixingFrom` makes up a linked list. */\n    mixingFrom: TrackEntry | null = null;\n\n    /** The track entry for the next animation when mixing from this animation to the next animation, or null if no mixing is\n     * currently occuring. When mixing to multiple animations, `mixingTo` makes up a linked list. */\n    mixingTo: TrackEntry | null = null;\n\n    /** The listener for events generated by this track entry, or null.\n     *\n     * A track entry returned from {@link AnimationState#setAnimation()} is already the current animation\n     * for the track, so the track entry listener {@link AnimationStateListener#start()} will not be called. */\n    listener: AnimationStateListener | null = null;\n\n    /** The index of the track where this track entry is either current or queued.\n     *\n     * See {@link AnimationState#getCurrent()}. */\n    trackIndex = 0;\n\n    /** If true, the animation will repeat. If false it will not, instead its last frame is applied if played beyond its\n     * duration. */\n    loop = false;\n\n    /** If true, when mixing from the previous animation to this animation, the previous animation is applied as normal instead\n     * of being mixed out.\n     *\n     * When mixing between animations that key the same property, if a lower track also keys that property then the value will\n     * briefly dip toward the lower track value during the mix. This happens because the first animation mixes from 100% to 0%\n     * while the second animation mixes from 0% to 100%. Setting `holdPrevious` to true applies the first animation\n     * at 100% during the mix so the lower track value is overwritten. Such dipping does not occur on the lowest track which\n     * keys the property, only when a higher track also keys the property.\n     *\n     * Snapping will occur if `holdPrevious` is true and this animation does not key all the same properties as the\n     * previous animation. */\n    holdPrevious = false;\n\n    reverse = false;\n\n    shortestRotation = false;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `eventThreshold`, event timelines are applied while this animation is being mixed out. Defaults to 0, so event\n     * timelines are not applied while this animation is being mixed out. */\n    eventThreshold = 0;\n\n    /** When the mix percentage ({@link #mixtime} / {@link #mixDuration}) is less than the\n     * `attachmentThreshold`, attachment timelines are applied while this animation is being mixed out. Defaults to\n     * 0, so attachment timelines are not applied while this animation is being mixed out. */\n    attachmentThreshold = 0;\n\n    /** When the mix percentage ({@link #mixTime} / {@link #mixDuration}) is less than the\n     * `drawOrderThreshold`, draw order timelines are applied while this animation is being mixed out. Defaults to 0,\n     * so draw order timelines are not applied while this animation is being mixed out. */\n    drawOrderThreshold = 0;\n\n    /** Seconds when this animation starts, both initially and after looping. Defaults to 0.\n     *\n     * When changing the `animationStart` time, it often makes sense to set {@link #animationLast} to the same\n     * value to prevent timeline keys before the start time from triggering. */\n    animationStart = 0;\n\n    /** Seconds for the last frame of this animation. Non-looping animations won't play past this time. Looping animations will\n     * loop back to {@link #animationStart} at this time. Defaults to the animation {@link Animation#duration}. */\n    animationEnd = 0;\n\n    /** The time in seconds this animation was last applied. Some timelines use this for one-time triggers. Eg, when this\n     * animation is applied, event timelines will fire all events between the `animationLast` time (exclusive) and\n     * `animationTime` (inclusive). Defaults to -1 to ensure triggers on frame 0 happen the first time this animation\n     * is applied. */\n    animationLast = 0;\n\n    nextAnimationLast = 0;\n\n    /** Seconds to postpone playing the animation. When this track entry is the current track entry, `delay`\n     * postpones incrementing the {@link #trackTime}. When this track entry is queued, `delay` is the time from\n     * the start of the previous animation to when this track entry will become the current track entry (ie when the previous\n     * track entry {@link TrackEntry#trackTime} >= this track entry's `delay`).\n     *\n     * {@link #timeScale} affects the delay. */\n    delay = 0;\n\n    /** Current time in seconds this track entry has been the current track entry. The track time determines\n     * {@link #animationTime}. The track time can be set to start the animation at a time other than 0, without affecting\n     * looping. */\n    trackTime = 0;\n\n    trackLast = 0;\n    nextTrackLast = 0;\n\n    /** The track time in seconds when this animation will be removed from the track. Defaults to the highest possible float\n     * value, meaning the animation will be applied until a new animation is set or the track is cleared. If the track end time\n     * is reached, no other animations are queued for playback, and mixing from any previous animations is complete, then the\n     * properties keyed by the animation are set to the setup pose and the track is cleared.\n     *\n     * It may be desired to use {@link AnimationState#addEmptyAnimation()} rather than have the animation\n     * abruptly cease being applied. */\n    trackEnd = 0;\n\n    /** Multiplier for the delta time when this track entry is updated, causing time for this animation to pass slower or\n     * faster. Defaults to 1.\n     *\n     * {@link #mixTime} is not affected by track entry time scale, so {@link #mixDuration} may need to be adjusted to\n     * match the animation speed.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, assuming time scale to be 1. If\n     * the time scale is not 1, the delay may need to be adjusted.\n     *\n     * See AnimationState {@link AnimationState#timeScale} for affecting all animations. */\n    timeScale = 0;\n\n    /** Values < 1 mix this animation with the skeleton's current pose (usually the pose resulting from lower tracks). Defaults\n     * to 1, which overwrites the skeleton's current pose with this animation.\n     *\n     * Typically track 0 is used to completely pose the skeleton, then alpha is used on higher tracks. It doesn't make sense to\n     * use alpha on track 0 if the skeleton pose is from the last frame render. */\n    alpha = 0;\n\n    /** Seconds from 0 to the {@link #getMixDuration()} when mixing from the previous animation to this animation. May be\n     * slightly more than `mixDuration` when the mix is complete. */\n    mixTime = 0;\n\n    /** Seconds for mixing from the previous animation to this animation. Defaults to the value provided by AnimationStateData\n     * {@link AnimationStateData#getMix()} based on the animation before this animation (if any).\n     *\n     * A mix duration of 0 still mixes out over one frame to provide the track entry being mixed out a chance to revert the\n     * properties it was animating.\n     *\n     * The `mixDuration` can be set manually rather than use the value from\n     * {@link AnimationStateData#getMix()}. In that case, the `mixDuration` can be set for a new\n     * track entry only before {@link AnimationState#update(float)} is first called.\n     *\n     * When using {@link AnimationState#addAnimation()} with a `delay` <= 0, note the\n     * {@link #delay} is set using the mix duration from the {@link AnimationStateData}, not a mix duration set\n     * afterward. */\n    mixDuration = 0;\n    interruptAlpha = 0;\n    totalAlpha = 0;\n\n    /** Controls how properties keyed in the animation are mixed with lower tracks. Defaults to {@link MixBlend#replace}, which\n     * replaces the values from the lower tracks with the animation values. {@link MixBlend#add} adds the animation values to\n     * the values from the lower tracks.\n     *\n     * The `mixBlend` can be set for a new track entry only before {@link AnimationState#apply()} is first\n     * called. */\n    mixBlend = MixBlend.replace;\n    timelineMode = new Array<number>();\n    timelineHoldMix = new Array<TrackEntry>();\n    timelinesRotation = new Array<number>();\n\n    reset() {\n        this.next = null;\n        this.previous = null;\n        this.mixingFrom = null;\n        this.mixingTo = null;\n        this.animation = null;\n        this.listener = null;\n        this.timelineMode.length = 0;\n        this.timelineHoldMix.length = 0;\n        this.timelinesRotation.length = 0;\n    }\n\n    /** Uses {@link #trackTime} to compute the `animationTime`, which is between {@link #animationStart}\n     * and {@link #animationEnd}. When the `trackTime` is 0, the `animationTime` is equal to the\n     * `animationStart` time. */\n    getAnimationTime() {\n        if (this.loop) {\n            const duration = this.animationEnd - this.animationStart;\n\n            if (duration == 0) return this.animationStart;\n\n            return (this.trackTime % duration) + this.animationStart;\n        }\n\n        return Math.min(this.trackTime + this.animationStart, this.animationEnd);\n    }\n\n    setAnimationLast(animationLast: number) {\n        this.animationLast = animationLast;\n        this.nextAnimationLast = animationLast;\n    }\n\n    /** Returns true if at least one loop has been completed.\n     *\n     * See {@link AnimationStateListener#complete()}. */\n    isComplete() {\n        return this.trackTime >= this.animationEnd - this.animationStart;\n    }\n\n    /** Resets the rotation directions for mixing this entry's rotate timelines. This can be useful to avoid bones rotating the\n     * long way around when using {@link #alpha} and starting animations on other tracks.\n     *\n     * Mixing with {@link MixBlend#replace} involves finding a rotation between two others, which has two possible solutions:\n     * the short way or the long way around. The two rotations likely change over time, so which direction is the short or long\n     * way also changes. If the short way was always chosen, bones would flip to the other side when that direction became the\n     * long way. TrackEntry chooses the short way the first time it is applied and remembers that direction. */\n    resetRotationDirections() {\n        this.timelinesRotation.length = 0;\n    }\n\n    getTrackComplete() {\n        const duration = this.animationEnd - this.animationStart;\n\n        if (duration != 0) {\n            if (this.loop) return duration * (1 + ((this.trackTime / duration) | 0)); // Completion of next loop.\n            if (this.trackTime < duration) return duration; // Before duration.\n        }\n\n        return this.trackTime; // Next update.\n    }\n\n    // deprecated stuff\n    onComplete: (trackIndex: number, loopCount: number) => any;\n    onEvent: (trackIndex: number, event: Event) => any;\n    onStart: (trackIndex: number) => any;\n    onEnd: (trackIndex: number) => any;\n\n    private static deprecatedWarning1: Boolean = false;\n    private static deprecatedWarning2: Boolean = false;\n\n    get time() {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set time(value: number) {\n        if (!TrackEntry.deprecatedWarning1) {\n            TrackEntry.deprecatedWarning1 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.time is deprecated, please use trackTime from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    get endTime() {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n\n        return this.trackTime;\n    }\n\n    set endTime(value: number) {\n        if (!TrackEntry.deprecatedWarning2) {\n            TrackEntry.deprecatedWarning2 = true;\n            console.warn('Spine Deprecation Warning: TrackEntry.endTime is deprecated, please use trackEnd from now on.');\n        }\n        this.trackTime = value;\n    }\n\n    loopsCount() {\n        return Math.floor(this.trackTime / this.trackEnd);\n    }\n}\n\n/**\n * @public\n */\nexport class EventQueue {\n    objects: Array<any> = [];\n    drainDisabled = false;\n    animState: AnimationState;\n\n    constructor(animState: AnimationState) {\n        this.animState = animState;\n    }\n\n    start(entry: TrackEntry) {\n        this.objects.push(EventType.start);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    interrupt(entry: TrackEntry) {\n        this.objects.push(EventType.interrupt);\n        this.objects.push(entry);\n    }\n\n    end(entry: TrackEntry) {\n        this.objects.push(EventType.end);\n        this.objects.push(entry);\n        this.animState.animationsChanged = true;\n    }\n\n    dispose(entry: TrackEntry) {\n        this.objects.push(EventType.dispose);\n        this.objects.push(entry);\n    }\n\n    complete(entry: TrackEntry) {\n        this.objects.push(EventType.complete);\n        this.objects.push(entry);\n    }\n\n    event(entry: TrackEntry, event: Event) {\n        this.objects.push(EventType.event);\n        this.objects.push(entry);\n        this.objects.push(event);\n    }\n\n    drain() {\n        if (this.drainDisabled) return;\n        this.drainDisabled = true;\n\n        const objects = this.objects;\n        const listeners = this.animState.listeners;\n\n        for (let i = 0; i < objects.length; i += 2) {\n            const type = objects[i] as EventType;\n            const entry = objects[i + 1] as TrackEntry;\n\n            switch (type) {\n                case EventType.start:\n                    if (entry.listener && entry.listener.start) entry.listener.start(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.start) listener.start(entry);\n                    }\n                    break;\n                case EventType.interrupt:\n                    if (entry.listener && entry.listener.interrupt) entry.listener.interrupt(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.interrupt) listener.interrupt(entry);\n                    }\n                    break;\n                case EventType.end:\n                    if (entry.listener && entry.listener.end) entry.listener.end(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.end) listener.end(entry);\n                    }\n                // Fall through.\n                case EventType.dispose:\n                    if (entry.listener && entry.listener.dispose) entry.listener.dispose(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.dispose) listener.dispose(entry);\n                    }\n                    this.animState.trackEntryPool.free(entry);\n                    break;\n                case EventType.complete:\n                    if (entry.listener && entry.listener.complete) entry.listener.complete(entry);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.complete) listener.complete(entry);\n                    }\n                    break;\n                case EventType.event:\n                    const event = objects[i++ + 2] as Event;\n\n                    if (entry.listener && entry.listener.event) entry.listener.event(entry, event);\n                    for (let ii = 0; ii < listeners.length; ii++) {\n                        const listener = listeners[ii];\n\n                        if (listener.event) listener.event(entry, event);\n                    }\n                    break;\n            }\n        }\n        this.clear();\n\n        this.drainDisabled = false;\n    }\n\n    clear() {\n        this.objects.length = 0;\n    }\n}\n\n/**\n * @public\n */\nexport enum EventType {\n    start,\n    interrupt,\n    end,\n    dispose,\n    complete,\n    event,\n}\n\n/** The interface to implement for receiving TrackEntry events. It is always safe to call AnimationState methods when receiving\n * events.\n *\n * See TrackEntry {@link TrackEntry#listener} and AnimationState\n * {@link AnimationState#addListener()}.\n * @public\n * */\nexport interface AnimationStateListener extends IAnimationStateListener {\n    /** Invoked when this entry has been set as the current entry. */\n    start?: (entry: TrackEntry) => void;\n\n    /** Invoked when another entry has replaced this entry as the current entry. This entry may continue being applied for\n     * mixing. */\n    interrupt?: (entry: TrackEntry) => void;\n\n    /** Invoked when this entry is no longer the current entry and will never be applied again. */\n    end?: (entry: TrackEntry) => void;\n\n    /** Invoked when this entry will be disposed. This may occur without the entry ever being set as the current entry.\n     * References to the entry should not be kept after dispose is called, as it may be destroyed or reused. */\n    dispose?: (entry: TrackEntry) => void;\n\n    /** Invoked every time this entry's animation completes a loop. */\n    complete?: (entry: TrackEntry) => void;\n\n    /** Invoked when this entry's animation triggers an event. */\n    event?: (entry: TrackEntry, event: Event) => void;\n}\n\n/**\n * @public\n */\nexport abstract class AnimationStateAdapter implements AnimationStateListener {\n    start(entry: TrackEntry) {}\n\n    interrupt(entry: TrackEntry) {}\n\n    end(entry: TrackEntry) {}\n\n    dispose(entry: TrackEntry) {}\n\n    complete(entry: TrackEntry) {}\n\n    event(entry: TrackEntry, event: Event) {}\n}\n\n/** 1. A previously applied timeline has set this property.\n *\n * Result: Mix from the current pose to the timeline pose. */\nconst SUBSEQUENT = 0;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry applied after this one does not have a timeline to set this property.\n *\n * Result: Mix from the setup pose to the timeline pose. */\nconst FIRST = 1;\n/** 1) A previously applied timeline has set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the current pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading\n * animations that key the same property. A subsequent timeline will set this property using a mix. */\nconst HOLD_SUBSEQUENT = 2;\n/** 1) This is the first timeline to set this property.<br>\n * 2) The next track entry to be applied does have a timeline to set this property.<br>\n * 3) The next track entry after that one does not have a timeline to set this property.<br>\n * Result: Mix from the setup pose to the timeline pose, but do not mix out. This avoids \"dipping\" when crossfading animations\n * that key the same property. A subsequent timeline will set this property using a mix. */\nconst HOLD_FIRST = 3;\n/** 1. This is the first timeline to set this property.\n * 2. The next track entry to be applied does have a timeline to set this property.\n * 3. The next track entry after that one does have a timeline to set this property.\n * 4. timelineHoldMix stores the first subsequent track entry that does not have a timeline to set this property.\n *\n * Result: The same as HOLD except the mix percentage from the timelineHoldMix track entry is used. This handles when more than\n * 2 track entries in a row have a timeline that sets the same property.\n *\n * Eg, A -> B -> C -> D where A, B, and C have a timeline setting same property, but D does not. When A is applied, to avoid\n * \"dipping\" A is not mixed out, however D (the first entry that doesn't set the property) mixing in is used to mix out A\n * (which affects B and C). Without using D to mix out, A would be applied fully until mixing completes, then snap into\n * place. */\nconst HOLD_MIX = 4;\n\nconst SETUP = 1;\nconst CURRENT = 2;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}