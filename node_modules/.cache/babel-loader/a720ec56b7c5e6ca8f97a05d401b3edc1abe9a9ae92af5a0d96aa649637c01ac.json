{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport \"core-js/modules/es.array-buffer.detached.js\";\nimport \"core-js/modules/es.array-buffer.transfer.js\";\nimport \"core-js/modules/es.array-buffer.transfer-to-fixed-length.js\";\nimport \"core-js/modules/es.typed-array.to-reversed.js\";\nimport \"core-js/modules/es.typed-array.to-sorted.js\";\nimport \"core-js/modules/es.typed-array.with.js\";\nimport { AlphaTimeline, RGB2Timeline, RGBA2Timeline, RGBTimeline, RGBATimeline, AttachmentTimeline, ShearYTimeline, ShearXTimeline, ShearTimeline, ScaleYTimeline, ScaleXTimeline, ScaleTimeline, TranslateYTimeline, TranslateXTimeline, TranslateTimeline, RotateTimeline, IkConstraintTimeline, TransformConstraintTimeline, PathConstraintMixTimeline, PathConstraintSpacingTimeline, PathConstraintPositionTimeline, SequenceTimeline, DeformTimeline, DrawOrderTimeline, EventTimeline, Animation } from './Animation.mjs';\nimport { Event } from './Event.mjs';\nimport { SkeletonData } from './SkeletonData.mjs';\nimport { SlotData } from './SlotData.mjs';\nimport { BoneData } from './BoneData.mjs';\nimport { IkConstraintData } from './IkConstraintData.mjs';\nimport { TransformConstraintData } from './TransformConstraintData.mjs';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData.mjs';\nimport { Skin } from './Skin.mjs';\nimport { EventData } from './EventData.mjs';\nimport { BinaryInput, Color, PositionMode, Utils, AttachmentType } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport './attachments/Attachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport { Sequence, SequenceModeValues } from './attachments/Sequence.mjs';\nclass SkeletonBinary {\n  constructor(attachmentLoader) {\n    this.ver40 = false;\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    this.scale = 1;\n    this.linkedMeshes = new Array();\n    this.attachmentLoader = attachmentLoader;\n  }\n  readSkeletonData(binary) {\n    const scale = this.scale;\n    const skeletonData = new SkeletonData();\n    skeletonData.name = \"\";\n    const input = new BinaryInput(binary);\n    const lowHash = input.readInt32();\n    const highHash = input.readInt32();\n    skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n    skeletonData.version = input.readString();\n    const verShort = skeletonData.version.substr(0, 3);\n    if (verShort !== \"4.0\" && verShort !== \"4.1\") {\n      const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n      console.error(error);\n    }\n    this.ver40 = verShort === \"4.0\";\n    skeletonData.x = input.readFloat();\n    skeletonData.y = input.readFloat();\n    skeletonData.width = input.readFloat();\n    skeletonData.height = input.readFloat();\n    const nonessential = input.readBoolean();\n    if (nonessential) {\n      skeletonData.fps = input.readFloat();\n      skeletonData.imagesPath = input.readString();\n      skeletonData.audioPath = input.readString();\n    }\n    let n = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const str = input.readString();\n      if (!str) throw new Error(\"String in string table must not be null.\");\n      input.strings.push(str);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error(\"Bone name must not be null.\");\n      const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n      const data = new BoneData(i, name, parent);\n      data.rotation = input.readFloat();\n      data.x = input.readFloat() * scale;\n      data.y = input.readFloat() * scale;\n      data.scaleX = input.readFloat();\n      data.scaleY = input.readFloat();\n      data.shearX = input.readFloat();\n      data.shearY = input.readFloat();\n      data.length = input.readFloat() * scale;\n      data.transformMode = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n      skeletonData.bones.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const slotName = input.readString();\n      if (!slotName) throw new Error(\"Slot name must not be null.\");\n      const boneData = skeletonData.bones[input.readInt(true)];\n      const data = new SlotData(i, slotName, boneData);\n      Color.rgba8888ToColor(data.color, input.readInt32());\n      const darkColor = input.readInt32();\n      if (darkColor != -1) Color.rgb888ToColor(data.darkColor = new Color(), darkColor);\n      data.attachmentName = input.readStringRef();\n      data.blendMode = input.readInt(true);\n      skeletonData.slots.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error(\"IK constraint data name must not be null.\");\n      const data = new IkConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.mix = input.readFloat();\n      data.softness = input.readFloat() * scale;\n      data.bendDirection = input.readByte();\n      data.compress = input.readBoolean();\n      data.stretch = input.readBoolean();\n      data.uniform = input.readBoolean();\n      skeletonData.ikConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error(\"Transform constraint data name must not be null.\");\n      const data = new TransformConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.bones[input.readInt(true)];\n      data.local = input.readBoolean();\n      data.relative = input.readBoolean();\n      data.offsetRotation = input.readFloat();\n      data.offsetX = input.readFloat() * scale;\n      data.offsetY = input.readFloat() * scale;\n      data.offsetScaleX = input.readFloat();\n      data.offsetScaleY = input.readFloat();\n      data.offsetShearY = input.readFloat();\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      data.mixScaleX = input.readFloat();\n      data.mixScaleY = input.readFloat();\n      data.mixShearY = input.readFloat();\n      skeletonData.transformConstraints.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0, nn; i < n; i++) {\n      const name = input.readString();\n      if (!name) throw new Error(\"Path constraint data name must not be null.\");\n      const data = new PathConstraintData(name);\n      data.order = input.readInt(true);\n      data.skinRequired = input.readBoolean();\n      nn = input.readInt(true);\n      for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n      data.target = skeletonData.slots[input.readInt(true)];\n      data.positionMode = input.readInt(true);\n      data.spacingMode = input.readInt(true);\n      data.rotateMode = input.readInt(true);\n      data.offsetRotation = input.readFloat();\n      data.position = input.readFloat();\n      if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n      data.spacing = input.readFloat();\n      if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n      data.mixRotate = input.readFloat();\n      data.mixX = input.readFloat();\n      data.mixY = input.readFloat();\n      skeletonData.pathConstraints.push(data);\n    }\n    const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n    if (defaultSkin) {\n      skeletonData.defaultSkin = defaultSkin;\n      skeletonData.skins.push(defaultSkin);\n    }\n    {\n      let i = skeletonData.skins.length;\n      Utils.setArraySize(skeletonData.skins, n = i + input.readInt(true));\n      for (; i < n; i++) {\n        const skin = this.readSkin(input, skeletonData, false, nonessential);\n        if (!skin) throw new Error(\"readSkin() should not have returned null.\");\n        skeletonData.skins[i] = skin;\n      }\n    }\n    n = this.linkedMeshes.length;\n    for (let i = 0; i < n; i++) {\n      const linkedMesh = this.linkedMeshes[i];\n      const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n      if (!skin) throw new Error(\"Not skin found for linked mesh.\");\n      if (!linkedMesh.parent) throw new Error(\"Linked mesh parent must not be null\");\n      const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n      if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n      linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? parent : linkedMesh.mesh;\n      linkedMesh.mesh.setParentMesh(parent);\n    }\n    this.linkedMeshes.length = 0;\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const eventName = input.readStringRef();\n      if (!eventName) throw new Error();\n      const data = new EventData(eventName);\n      data.intValue = input.readInt(false);\n      data.floatValue = input.readFloat();\n      data.stringValue = input.readString();\n      data.audioPath = input.readString();\n      if (data.audioPath) {\n        data.volume = input.readFloat();\n        data.balance = input.readFloat();\n      }\n      skeletonData.events.push(data);\n    }\n    n = input.readInt(true);\n    for (let i = 0; i < n; i++) {\n      const animationName = input.readString();\n      if (!animationName) throw new Error(\"Animatio name must not be null.\");\n      skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n    }\n    return skeletonData;\n  }\n  readSkin(input, skeletonData, defaultSkin, nonessential) {\n    let skin = null;\n    let slotCount = 0;\n    if (defaultSkin) {\n      slotCount = input.readInt(true);\n      if (slotCount == 0) return null;\n      skin = new Skin(\"default\");\n    } else {\n      const skinName = input.readStringRef();\n      if (!skinName) throw new Error(\"Skin name must not be null.\");\n      skin = new Skin(skinName);\n      skin.bones.length = input.readInt(true);\n      for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n      for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n      for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n      slotCount = input.readInt(true);\n    }\n    for (let i = 0; i < slotCount; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const name = input.readStringRef();\n        if (!name) throw new Error(\"Attachment name must not be null\");\n        const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n        if (attachment) skin.setAttachment(slotIndex, name, attachment);\n      }\n    }\n    return skin;\n  }\n  readAttachment(input, skeletonData, skin, slotIndex, attachmentName, nonessential) {\n    const scale = this.scale;\n    let name = input.readStringRef();\n    if (!name) name = attachmentName;\n    switch (input.readByte()) {\n      case AttachmentType.Region:\n        {\n          let path = input.readStringRef();\n          const rotation = input.readFloat();\n          const x = input.readFloat();\n          const y = input.readFloat();\n          const scaleX = input.readFloat();\n          const scaleY = input.readFloat();\n          const width = input.readFloat();\n          const height = input.readFloat();\n          const color = input.readInt32();\n          const sequence = this.readSequence(input);\n          if (!path) path = name;\n          const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n          if (!region) return null;\n          region.path = path;\n          region.x = x * scale;\n          region.y = y * scale;\n          region.scaleX = scaleX;\n          region.scaleY = scaleY;\n          region.rotation = rotation;\n          region.width = width * scale;\n          region.height = height * scale;\n          Color.rgba8888ToColor(region.color, color);\n          region.sequence = sequence;\n          if (sequence == null) region.updateRegion();\n          return region;\n        }\n      case AttachmentType.BoundingBox:\n        {\n          const vertexCount = input.readInt(true);\n          const vertices = this.readVertices(input, vertexCount);\n          const color = nonessential ? input.readInt32() : 0;\n          const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n          if (!box) return null;\n          box.worldVerticesLength = vertexCount << 1;\n          box.vertices = vertices.vertices;\n          box.bones = vertices.bones;\n          if (nonessential) Color.rgba8888ToColor(box.color, color);\n          return box;\n        }\n      case AttachmentType.Mesh:\n        {\n          let path = input.readStringRef();\n          const color = input.readInt32();\n          const vertexCount = input.readInt(true);\n          const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n          const triangles = this.readShortArray(input);\n          const vertices = this.readVertices(input, vertexCount);\n          const hullLength = input.readInt(true);\n          const sequence = this.readSequence(input);\n          let edges = [];\n          let width = 0;\n          let height = 0;\n          if (nonessential) {\n            edges = this.readShortArray(input);\n            width = input.readFloat();\n            height = input.readFloat();\n          }\n          if (!path) path = name;\n          const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n          if (!mesh) return null;\n          mesh.path = path;\n          Color.rgba8888ToColor(mesh.color, color);\n          mesh.bones = vertices.bones;\n          mesh.vertices = vertices.vertices;\n          mesh.worldVerticesLength = vertexCount << 1;\n          mesh.triangles = triangles;\n          mesh.regionUVs = new Float32Array(uvs);\n          mesh.hullLength = hullLength << 1;\n          mesh.sequence = sequence;\n          if (nonessential) {\n            mesh.edges = edges;\n            mesh.width = width * scale;\n            mesh.height = height * scale;\n          }\n          return mesh;\n        }\n      case AttachmentType.LinkedMesh:\n        {\n          let path = input.readStringRef();\n          const color = input.readInt32();\n          const skinName = input.readStringRef();\n          const parent = input.readStringRef();\n          const inheritTimelines = input.readBoolean();\n          const sequence = this.readSequence(input);\n          let width = 0;\n          let height = 0;\n          if (nonessential) {\n            width = input.readFloat();\n            height = input.readFloat();\n          }\n          if (!path) path = name;\n          const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n          if (!mesh) return null;\n          mesh.path = path;\n          Color.rgba8888ToColor(mesh.color, color);\n          mesh.sequence = sequence;\n          if (nonessential) {\n            mesh.width = width * scale;\n            mesh.height = height * scale;\n          }\n          this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\n          return mesh;\n        }\n      case AttachmentType.Path:\n        {\n          const closed = input.readBoolean();\n          const constantSpeed = input.readBoolean();\n          const vertexCount = input.readInt(true);\n          const vertices = this.readVertices(input, vertexCount);\n          const lengths = Utils.newArray(vertexCount / 3, 0);\n          for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n          const color = nonessential ? input.readInt32() : 0;\n          const path = this.attachmentLoader.newPathAttachment(skin, name);\n          if (!path) return null;\n          path.closed = closed;\n          path.constantSpeed = constantSpeed;\n          path.worldVerticesLength = vertexCount << 1;\n          path.vertices = vertices.vertices;\n          path.bones = vertices.bones;\n          path.lengths = lengths;\n          if (nonessential) Color.rgba8888ToColor(path.color, color);\n          return path;\n        }\n      case AttachmentType.Point:\n        {\n          const rotation = input.readFloat();\n          const x = input.readFloat();\n          const y = input.readFloat();\n          const color = nonessential ? input.readInt32() : 0;\n          const point = this.attachmentLoader.newPointAttachment(skin, name);\n          if (!point) return null;\n          point.x = x * scale;\n          point.y = y * scale;\n          point.rotation = rotation;\n          if (nonessential) Color.rgba8888ToColor(point.color, color);\n          return point;\n        }\n      case AttachmentType.Clipping:\n        {\n          const endSlotIndex = input.readInt(true);\n          const vertexCount = input.readInt(true);\n          const vertices = this.readVertices(input, vertexCount);\n          const color = nonessential ? input.readInt32() : 0;\n          const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n          if (!clip) return null;\n          clip.endSlot = skeletonData.slots[endSlotIndex];\n          clip.worldVerticesLength = vertexCount << 1;\n          clip.vertices = vertices.vertices;\n          clip.bones = vertices.bones;\n          if (nonessential) Color.rgba8888ToColor(clip.color, color);\n          return clip;\n        }\n    }\n    return null;\n  }\n  readSequence(input) {\n    if (this.ver40 || !input.readBoolean()) return null;\n    const sequence = new Sequence(input.readInt(true));\n    sequence.start = input.readInt(true);\n    sequence.digits = input.readInt(true);\n    sequence.setupIndex = input.readInt(true);\n    return sequence;\n  }\n  readDeformTimelineType(input) {\n    if (this.ver40) return ATTACHMENT_DEFORM;\n    return input.readByte();\n  }\n  readVertices(input, vertexCount) {\n    const scale = this.scale;\n    const verticesLength = vertexCount << 1;\n    const vertices = new Vertices();\n    if (!input.readBoolean()) {\n      vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n      return vertices;\n    }\n    const weights = new Array();\n    const bonesArray = new Array();\n    for (let i = 0; i < vertexCount; i++) {\n      const boneCount = input.readInt(true);\n      bonesArray.push(boneCount);\n      for (let ii = 0; ii < boneCount; ii++) {\n        bonesArray.push(input.readInt(true));\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat() * scale);\n        weights.push(input.readFloat());\n      }\n    }\n    vertices.vertices = Utils.toFloatArray(weights);\n    vertices.bones = bonesArray;\n    return vertices;\n  }\n  readFloatArray(input, n, scale) {\n    const array = new Array(n);\n    if (scale == 1) {\n      for (let i = 0; i < n; i++) array[i] = input.readFloat();\n    } else {\n      for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n    }\n    return array;\n  }\n  readShortArray(input) {\n    const n = input.readInt(true);\n    const array = new Array(n);\n    for (let i = 0; i < n; i++) array[i] = input.readShort();\n    return array;\n  }\n  readAnimation(input, name, skeletonData) {\n    input.readInt(true);\n    const timelines = new Array();\n    const scale = this.scale;\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const slotIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const timelineType = input.readByte();\n        const frameCount = input.readInt(true);\n        const frameLast = frameCount - 1;\n        switch (timelineType) {\n          case SLOT_ATTACHMENT:\n            {\n              const timeline = new AttachmentTimeline(frameCount, slotIndex);\n              for (let frame = 0; frame < frameCount; frame++) timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n              timelines.push(timeline);\n              break;\n            }\n          case SLOT_RGBA:\n            {\n              const bezierCount = input.readInt(true);\n              const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255;\n              let g = input.readUnsignedByte() / 255;\n              let b = input.readUnsignedByte() / 255;\n              let a = input.readUnsignedByte() / 255;\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b, a);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const r2 = input.readUnsignedByte() / 255;\n                const g2 = input.readUnsignedByte() / 255;\n                const b2 = input.readUnsignedByte() / 255;\n                const a2 = input.readUnsignedByte() / 255;\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n                }\n                time = time2;\n                r = r2;\n                g = g2;\n                b = b2;\n                a = a2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n          case SLOT_RGB:\n            {\n              const bezierCount = input.readInt(true);\n              const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255;\n              let g = input.readUnsignedByte() / 255;\n              let b = input.readUnsignedByte() / 255;\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const r2 = input.readUnsignedByte() / 255;\n                const g2 = input.readUnsignedByte() / 255;\n                const b2 = input.readUnsignedByte() / 255;\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                }\n                time = time2;\n                r = r2;\n                g = g2;\n                b = b2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n          case SLOT_RGBA2:\n            {\n              const bezierCount = input.readInt(true);\n              const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255;\n              let g = input.readUnsignedByte() / 255;\n              let b = input.readUnsignedByte() / 255;\n              let a = input.readUnsignedByte() / 255;\n              let r2 = input.readUnsignedByte() / 255;\n              let g2 = input.readUnsignedByte() / 255;\n              let b2 = input.readUnsignedByte() / 255;\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const nr = input.readUnsignedByte() / 255;\n                const ng = input.readUnsignedByte() / 255;\n                const nb = input.readUnsignedByte() / 255;\n                const na = input.readUnsignedByte() / 255;\n                const nr2 = input.readUnsignedByte() / 255;\n                const ng2 = input.readUnsignedByte() / 255;\n                const nb2 = input.readUnsignedByte() / 255;\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n                }\n                time = time2;\n                r = nr;\n                g = ng;\n                b = nb;\n                a = na;\n                r2 = nr2;\n                g2 = ng2;\n                b2 = nb2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n          case SLOT_RGB2:\n            {\n              const bezierCount = input.readInt(true);\n              const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n              let time = input.readFloat();\n              let r = input.readUnsignedByte() / 255;\n              let g = input.readUnsignedByte() / 255;\n              let b = input.readUnsignedByte() / 255;\n              let r2 = input.readUnsignedByte() / 255;\n              let g2 = input.readUnsignedByte() / 255;\n              let b2 = input.readUnsignedByte() / 255;\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const nr = input.readUnsignedByte() / 255;\n                const ng = input.readUnsignedByte() / 255;\n                const nb = input.readUnsignedByte() / 255;\n                const nr2 = input.readUnsignedByte() / 255;\n                const ng2 = input.readUnsignedByte() / 255;\n                const nb2 = input.readUnsignedByte() / 255;\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n                }\n                time = time2;\n                r = nr;\n                g = ng;\n                b = nb;\n                r2 = nr2;\n                g2 = ng2;\n                b2 = nb2;\n              }\n              timelines.push(timeline);\n              break;\n            }\n          case SLOT_ALPHA:\n            {\n              const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n              let time = input.readFloat();\n              let a = input.readUnsignedByte() / 255;\n              for (let frame = 0, bezier = 0;; frame++) {\n                timeline.setFrame(frame, time, a);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const a2 = input.readUnsignedByte() / 255;\n                switch (input.readByte()) {\n                  case CURVE_STEPPED:\n                    timeline.setStepped(frame);\n                    break;\n                  case CURVE_BEZIER:\n                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n                }\n                time = time2;\n                a = a2;\n              }\n              timelines.push(timeline);\n            }\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const boneIndex = input.readInt(true);\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const type = input.readByte();\n        const frameCount = input.readInt(true);\n        const bezierCount = input.readInt(true);\n        switch (type) {\n          case BONE_ROTATE:\n            timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_TRANSLATE:\n            timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEX:\n            timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_TRANSLATEY:\n            timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n            break;\n          case BONE_SCALE:\n            timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEX:\n            timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SCALEY:\n            timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEAR:\n            timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARX:\n            timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n            break;\n          case BONE_SHEARY:\n            timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const frameLast = frameCount - 1;\n      const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat();\n      let mix = input.readFloat();\n      let softness = input.readFloat() * scale;\n      for (let frame = 0, bezier = 0;; frame++) {\n        timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const mix2 = input.readFloat();\n        const softness2 = input.readFloat() * scale;\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n        }\n        time = time2;\n        mix = mix2;\n        softness = softness2;\n      }\n      timelines.push(timeline);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const frameCount = input.readInt(true);\n      const frameLast = frameCount - 1;\n      const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n      let time = input.readFloat();\n      let mixRotate = input.readFloat();\n      let mixX = input.readFloat();\n      let mixY = input.readFloat();\n      let mixScaleX = input.readFloat();\n      let mixScaleY = input.readFloat();\n      let mixShearY = input.readFloat();\n      for (let frame = 0, bezier = 0;; frame++) {\n        timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const mixRotate2 = input.readFloat();\n        const mixX2 = input.readFloat();\n        const mixY2 = input.readFloat();\n        const mixScaleX2 = input.readFloat();\n        const mixScaleY2 = input.readFloat();\n        const mixShearY2 = input.readFloat();\n        switch (input.readByte()) {\n          case CURVE_STEPPED:\n            timeline.setStepped(frame);\n            break;\n          case CURVE_BEZIER:\n            setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n            setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n            setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n            setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n            setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n            setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n        }\n        time = time2;\n        mixRotate = mixRotate2;\n        mixX = mixX2;\n        mixY = mixY2;\n        mixScaleX = mixScaleX2;\n        mixScaleY = mixScaleY2;\n        mixShearY = mixShearY2;\n      }\n      timelines.push(timeline);\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const index = input.readInt(true);\n      const data = skeletonData.pathConstraints[index];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        switch (input.readByte()) {\n          case PATH_POSITION:\n            timelines.push(readTimeline1(input, new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index), data.positionMode == PositionMode.Fixed ? scale : 1));\n            break;\n          case PATH_SPACING:\n            timelines.push(readTimeline1(input, new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index), data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1));\n            break;\n          case PATH_MIX:\n            const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n            let time = input.readFloat();\n            let mixRotate = input.readFloat();\n            let mixX = input.readFloat();\n            let mixY = input.readFloat();\n            for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\n              timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n              if (frame == frameLast) break;\n              const time2 = input.readFloat();\n              const mixRotate2 = input.readFloat();\n              const mixX2 = input.readFloat();\n              const mixY2 = input.readFloat();\n              switch (input.readByte()) {\n                case CURVE_STEPPED:\n                  timeline.setStepped(frame);\n                  break;\n                case CURVE_BEZIER:\n                  setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                  setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                  setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n              }\n              time = time2;\n              mixRotate = mixRotate2;\n              mixX = mixX2;\n              mixY = mixY2;\n            }\n            timelines.push(timeline);\n        }\n      }\n    }\n    for (let i = 0, n = input.readInt(true); i < n; i++) {\n      const skin = skeletonData.skins[input.readInt(true)];\n      for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n        const slotIndex = input.readInt(true);\n        for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n          const attachmentName = input.readStringRef();\n          if (!attachmentName) throw new Error(\"attachmentName must not be null.\");\n          const attachment = skin.getAttachment(slotIndex, attachmentName);\n          const timelineType = this.readDeformTimelineType(input);\n          const frameCount = input.readInt(true);\n          const frameLast = frameCount - 1;\n          switch (timelineType) {\n            case ATTACHMENT_DEFORM:\n              {\n                const vertexAttachment = attachment;\n                const weighted = vertexAttachment.bones;\n                const vertices = vertexAttachment.vertices;\n                const deformLength = weighted ? vertices.length / 3 * 2 : vertices.length;\n                const bezierCount = input.readInt(true);\n                const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n                let time = input.readFloat();\n                for (let frame = 0, bezier = 0;; frame++) {\n                  let deform;\n                  let end = input.readInt(true);\n                  if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;else {\n                    deform = Utils.newFloatArray(deformLength);\n                    const start = input.readInt(true);\n                    end += start;\n                    if (scale == 1) {\n                      for (let v = start; v < end; v++) deform[v] = input.readFloat();\n                    } else {\n                      for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n                    }\n                    if (!weighted) {\n                      for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n                    }\n                  }\n                  timeline.setFrame(frame, time, deform);\n                  if (frame == frameLast) break;\n                  const time2 = input.readFloat();\n                  switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                      timeline.setStepped(frame);\n                      break;\n                    case CURVE_BEZIER:\n                      setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                  }\n                  time = time2;\n                }\n                timelines.push(timeline);\n                break;\n              }\n            case ATTACHMENT_SEQUENCE:\n              {\n                const timeline = new SequenceTimeline(frameCount, slotIndex, attachment);\n                for (let frame = 0; frame < frameCount; frame++) {\n                  const time = input.readFloat();\n                  const modeAndIndex = input.readInt32();\n                  timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 15], modeAndIndex >> 4, input.readFloat());\n                }\n                timelines.push(timeline);\n                break;\n              }\n          }\n        }\n      }\n    }\n    const drawOrderCount = input.readInt(true);\n    if (drawOrderCount > 0) {\n      const timeline = new DrawOrderTimeline(drawOrderCount);\n      const slotCount = skeletonData.slots.length;\n      for (let i = 0; i < drawOrderCount; i++) {\n        const time = input.readFloat();\n        const offsetCount = input.readInt(true);\n        const drawOrder = Utils.newArray(slotCount, 0);\n        for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n        const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n        let originalIndex = 0;\n        let unchangedIndex = 0;\n        for (let ii = 0; ii < offsetCount; ii++) {\n          const slotIndex = input.readInt(true);\n          while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n          drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n        }\n        while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n        for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n        timeline.setFrame(i, time, drawOrder);\n      }\n      timelines.push(timeline);\n    }\n    const eventCount = input.readInt(true);\n    if (eventCount > 0) {\n      const timeline = new EventTimeline(eventCount);\n      for (let i = 0; i < eventCount; i++) {\n        const time = input.readFloat();\n        const eventData = skeletonData.events[input.readInt(true)];\n        const event = new Event(time, eventData);\n        event.intValue = input.readInt(false);\n        event.floatValue = input.readFloat();\n        event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n        if (event.data.audioPath) {\n          event.volume = input.readFloat();\n          event.balance = input.readFloat();\n        }\n        timeline.setFrame(i, event);\n      }\n      timelines.push(timeline);\n    }\n    let duration = 0;\n    for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n    return new Animation(name, timelines, duration);\n  }\n}\nSkeletonBinary.BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\nclass LinkedMesh {\n  constructor(mesh, skin, slotIndex, parent, inheritDeform) {\n    this.mesh = mesh;\n    this.skin = skin;\n    this.slotIndex = slotIndex;\n    this.parent = parent;\n    this.inheritTimeline = inheritDeform;\n  }\n}\nclass Vertices {\n  constructor(bones = null, vertices = null) {\n    this.bones = bones;\n    this.vertices = vertices;\n  }\n}\nfunction readTimeline1(input, timeline, scale) {\n  let time = input.readFloat();\n  let value = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\n    timeline.setFrame(frame, time, value);\n    if (frame == frameLast) break;\n    const time2 = input.readFloat();\n    const value2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n    }\n    time = time2;\n    value = value2;\n  }\n  return timeline;\n}\nfunction readTimeline2(input, timeline, scale) {\n  let time = input.readFloat();\n  let value1 = input.readFloat() * scale;\n  let value2 = input.readFloat() * scale;\n  for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1;; frame++) {\n    timeline.setFrame(frame, time, value1, value2);\n    if (frame == frameLast) break;\n    const time2 = input.readFloat();\n    const nvalue1 = input.readFloat() * scale;\n    const nvalue2 = input.readFloat() * scale;\n    switch (input.readByte()) {\n      case CURVE_STEPPED:\n        timeline.setStepped(frame);\n        break;\n      case CURVE_BEZIER:\n        setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n        setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n    }\n    time = time2;\n    value1 = nvalue1;\n    value2 = nvalue2;\n  }\n  return timeline;\n}\nfunction setBezier(input, timeline, bezier, frame, value, time1, time2, value1, value2, scale) {\n  timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\nexport { SkeletonBinary };","map":{"version":3,"names":["SkeletonBinary","constructor","attachmentLoader","ver40","scale","linkedMeshes","Array","readSkeletonData","binary","skeletonData","SkeletonData","name","input","BinaryInput","lowHash","readInt32","highHash","hash","toString","version","readString","verShort","substr","error","console","x","readFloat","y","width","height","nonessential","readBoolean","fps","imagesPath","audioPath","n","readInt","i","str","Error","strings","push","parent","bones","data","BoneData","rotation","scaleX","scaleY","shearX","shearY","length","transformMode","skinRequired","Color","rgba8888ToColor","color","slotName","boneData","SlotData","darkColor","rgb888ToColor","attachmentName","readStringRef","blendMode","slots","nn","IkConstraintData","order","ii","target","mix","softness","bendDirection","readByte","compress","stretch","uniform","ikConstraints","TransformConstraintData","local","relative","offsetRotation","offsetX","offsetY","offsetScaleX","offsetScaleY","offsetShearY","mixRotate","mixX","mixY","mixScaleX","mixScaleY","mixShearY","transformConstraints","PathConstraintData","positionMode","spacingMode","rotateMode","position","PositionMode","Fixed","spacing","SpacingMode","Length","pathConstraints","defaultSkin","readSkin","skins","Utils","setArraySize","skin","linkedMesh","findSkin","getAttachment","slotIndex","mesh","timelineAttachment","inheritTimeline","setParentMesh","eventName","EventData","intValue","floatValue","stringValue","volume","balance","events","animationName","animations","readAnimation","slotCount","Skin","skinName","constraints","attachment","readAttachment","setAttachment","AttachmentType","Region","path","sequence","readSequence","region","newRegionAttachment","updateRegion","BoundingBox","vertexCount","vertices","readVertices","box","newBoundingBoxAttachment","worldVerticesLength","Mesh","uvs","readFloatArray","triangles","readShortArray","hullLength","edges","newMeshAttachment","regionUVs","Float32Array","LinkedMesh","inheritTimelines","Path","closed","constantSpeed","lengths","newArray","newPathAttachment","Point","point","newPointAttachment","Clipping","endSlotIndex","clip","newClippingAttachment","endSlot","Sequence","start","digits","setupIndex","readDeformTimelineType","ATTACHMENT_DEFORM","verticesLength","Vertices","weights","bonesArray","boneCount","toFloatArray","array","readShort","timelines","timelineType","frameCount","frameLast","SLOT_ATTACHMENT","timeline","AttachmentTimeline","frame","setFrame","SLOT_RGBA","bezierCount","RGBATimeline","time","r","readUnsignedByte","g","b","a","bezier","time2","r2","g2","b2","a2","CURVE_STEPPED","setStepped","CURVE_BEZIER","setBezier","SLOT_RGB","RGBTimeline","SLOT_RGBA2","RGBA2Timeline","nr","ng","nb","na","nr2","ng2","nb2","SLOT_RGB2","RGB2Timeline","SLOT_ALPHA","AlphaTimeline","boneIndex","type","BONE_ROTATE","readTimeline1","RotateTimeline","BONE_TRANSLATE","readTimeline2","TranslateTimeline","BONE_TRANSLATEX","TranslateXTimeline","BONE_TRANSLATEY","TranslateYTimeline","BONE_SCALE","ScaleTimeline","BONE_SCALEX","ScaleXTimeline","BONE_SCALEY","ScaleYTimeline","BONE_SHEAR","ShearTimeline","BONE_SHEARX","ShearXTimeline","BONE_SHEARY","ShearYTimeline","index","IkConstraintTimeline","mix2","softness2","TransformConstraintTimeline","mixRotate2","mixX2","mixY2","mixScaleX2","mixScaleY2","mixShearY2","PATH_POSITION","PathConstraintPositionTimeline","PATH_SPACING","PathConstraintSpacingTimeline","PATH_MIX","PathConstraintMixTimeline","getFrameCount","iii","nnn","vertexAttachment","weighted","deformLength","DeformTimeline","deform","end","newFloatArray","v","vn","ATTACHMENT_SEQUENCE","SequenceTimeline","modeAndIndex","SequenceModeValues","drawOrderCount","DrawOrderTimeline","offsetCount","drawOrder","unchanged","originalIndex","unchangedIndex","eventCount","EventTimeline","eventData","event","Event","duration","Math","max","getDuration","Animation","BlendModeValues","BLEND_MODES","NORMAL","ADD","MULTIPLY","SCREEN","inheritDeform","value","value2","value1","nvalue1","nvalue2","time1"],"sources":["../../src/core/SkeletonBinary.ts"],"sourcesContent":["import type { Attachment, AttachmentLoader, MeshAttachment, VertexAttachment } from './attachments';\nimport {\n    AlphaTimeline,\n    Animation,\n    AttachmentTimeline,\n    CurveTimeline,\n    CurveTimeline1,\n    CurveTimeline2,\n    DeformTimeline,\n    DrawOrderTimeline,\n    EventTimeline,\n    IkConstraintTimeline,\n    PathConstraintMixTimeline,\n    PathConstraintPositionTimeline,\n    PathConstraintSpacingTimeline,\n    RGB2Timeline,\n    RGBA2Timeline,\n    RGBATimeline,\n    RGBTimeline,\n    RotateTimeline,\n    ScaleTimeline,\n    ScaleXTimeline,\n    ScaleYTimeline,\n    SequenceTimeline,\n    ShearTimeline,\n    ShearXTimeline,\n    ShearYTimeline,\n    Timeline,\n    TransformConstraintTimeline,\n    TranslateTimeline,\n    TranslateXTimeline,\n    TranslateYTimeline,\n} from './Animation';\nimport { Event } from './Event';\nimport { SkeletonData } from './SkeletonData';\nimport { SlotData } from './SlotData';\nimport { BoneData } from './BoneData';\nimport { IkConstraintData } from './IkConstraintData';\nimport { TransformConstraintData } from './TransformConstraintData';\nimport { PathConstraintData, SpacingMode } from './PathConstraintData';\nimport { Skin } from './Skin';\nimport { EventData } from './EventData';\nimport { AttachmentType, BinaryInput, Color, IHasTextureRegion, PositionMode, Utils } from '@pixi-spine/base';\nimport { BLEND_MODES } from '@pixi/core';\nimport { Sequence, SequenceModeValues } from './attachments';\n\n/** Loads skeleton data in the Spine binary format.\n *\n * See [Spine binary format](http://esotericsoftware.com/spine-binary-format) and\n * [JSON and binary data](http://esotericsoftware.com/spine-loading-skeleton-data#JSON-and-binary-data) in the Spine\n * Runtimes Guide.\n * @public\n * */\nexport class SkeletonBinary {\n    ver40 = false;\n    static BlendModeValues = [BLEND_MODES.NORMAL, BLEND_MODES.ADD, BLEND_MODES.MULTIPLY, BLEND_MODES.SCREEN];\n    /** Scales bone positions, image sizes, and translations as they are loaded. This allows different size images to be used at\n     * runtime than were used in Spine.\n     *\n     * See [Scaling](http://esotericsoftware.com/spine-loading-skeleton-data#Scaling) in the Spine Runtimes Guide. */\n    scale = 1;\n\n    attachmentLoader: AttachmentLoader;\n    private linkedMeshes = new Array<LinkedMesh>();\n\n    constructor(attachmentLoader: AttachmentLoader) {\n        this.attachmentLoader = attachmentLoader;\n    }\n\n    readSkeletonData(binary: Uint8Array): SkeletonData {\n        const scale = this.scale;\n\n        const skeletonData = new SkeletonData();\n\n        skeletonData.name = ''; // BOZO\n\n        const input = new BinaryInput(binary);\n\n        const lowHash = input.readInt32();\n        const highHash = input.readInt32();\n\n        skeletonData.hash = highHash == 0 && lowHash == 0 ? null : highHash.toString(16) + lowHash.toString(16);\n        skeletonData.version = input.readString();\n        const verShort = skeletonData.version.substr(0, 3);\n\n        if (verShort !== '4.0' && verShort !== '4.1') {\n            const error = `Spine 4.1 loader cant load version ${skeletonData.version}. Please configure your pixi-spine bundle`;\n\n            console.error(error);\n        }\n        this.ver40 = verShort === '4.0';\n        skeletonData.x = input.readFloat();\n        skeletonData.y = input.readFloat();\n        skeletonData.width = input.readFloat();\n        skeletonData.height = input.readFloat();\n\n        const nonessential = input.readBoolean();\n\n        if (nonessential) {\n            skeletonData.fps = input.readFloat();\n\n            skeletonData.imagesPath = input.readString();\n            skeletonData.audioPath = input.readString();\n        }\n\n        let n = 0;\n        // Strings.\n\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const str = input.readString();\n\n            if (!str) throw new Error('String in string table must not be null.');\n            input.strings.push(str);\n        }\n\n        // Bones.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('Bone name must not be null.');\n            const parent = i == 0 ? null : skeletonData.bones[input.readInt(true)];\n            const data = new BoneData(i, name, parent);\n\n            data.rotation = input.readFloat();\n            data.x = input.readFloat() * scale;\n            data.y = input.readFloat() * scale;\n            data.scaleX = input.readFloat();\n            data.scaleY = input.readFloat();\n            data.shearX = input.readFloat();\n            data.shearY = input.readFloat();\n            data.length = input.readFloat() * scale;\n            data.transformMode = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            if (nonessential) Color.rgba8888ToColor(data.color, input.readInt32());\n            skeletonData.bones.push(data);\n        }\n\n        // Slots.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const slotName = input.readString();\n\n            if (!slotName) throw new Error('Slot name must not be null.');\n            const boneData = skeletonData.bones[input.readInt(true)];\n            const data = new SlotData(i, slotName, boneData);\n\n            Color.rgba8888ToColor(data.color, input.readInt32());\n\n            const darkColor = input.readInt32();\n\n            if (darkColor != -1) Color.rgb888ToColor((data.darkColor = new Color()), darkColor);\n\n            data.attachmentName = input.readStringRef();\n            data.blendMode = input.readInt(true);\n            skeletonData.slots.push(data);\n        }\n\n        // IK constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('IK constraint data name must not be null.');\n            const data = new IkConstraintData(name);\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.mix = input.readFloat();\n            data.softness = input.readFloat() * scale;\n            data.bendDirection = input.readByte();\n            data.compress = input.readBoolean();\n            data.stretch = input.readBoolean();\n            data.uniform = input.readBoolean();\n            skeletonData.ikConstraints.push(data);\n        }\n\n        // Transform constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('Transform constraint data name must not be null.');\n            const data = new TransformConstraintData(name);\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.bones[input.readInt(true)];\n            data.local = input.readBoolean();\n            data.relative = input.readBoolean();\n            data.offsetRotation = input.readFloat();\n            data.offsetX = input.readFloat() * scale;\n            data.offsetY = input.readFloat() * scale;\n            data.offsetScaleX = input.readFloat();\n            data.offsetScaleY = input.readFloat();\n            data.offsetShearY = input.readFloat();\n            data.mixRotate = input.readFloat();\n            data.mixX = input.readFloat();\n            data.mixY = input.readFloat();\n            data.mixScaleX = input.readFloat();\n            data.mixScaleY = input.readFloat();\n            data.mixShearY = input.readFloat();\n            skeletonData.transformConstraints.push(data);\n        }\n\n        // Path constraints.\n        n = input.readInt(true);\n        for (let i = 0, nn; i < n; i++) {\n            const name = input.readString();\n\n            if (!name) throw new Error('Path constraint data name must not be null.');\n            const data = new PathConstraintData(name);\n\n            data.order = input.readInt(true);\n            data.skinRequired = input.readBoolean();\n            nn = input.readInt(true);\n            for (let ii = 0; ii < nn; ii++) data.bones.push(skeletonData.bones[input.readInt(true)]);\n            data.target = skeletonData.slots[input.readInt(true)];\n            data.positionMode = input.readInt(true);\n            data.spacingMode = input.readInt(true);\n            data.rotateMode = input.readInt(true);\n            data.offsetRotation = input.readFloat();\n            data.position = input.readFloat();\n            if (data.positionMode == PositionMode.Fixed) data.position *= scale;\n            data.spacing = input.readFloat();\n            if (data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed) data.spacing *= scale;\n            data.mixRotate = input.readFloat();\n            data.mixX = input.readFloat();\n            data.mixY = input.readFloat();\n            skeletonData.pathConstraints.push(data);\n        }\n\n        // Default skin.\n        const defaultSkin = this.readSkin(input, skeletonData, true, nonessential);\n\n        if (defaultSkin) {\n            skeletonData.defaultSkin = defaultSkin;\n            skeletonData.skins.push(defaultSkin);\n        }\n\n        // Skins.\n        {\n            let i = skeletonData.skins.length;\n\n            Utils.setArraySize(skeletonData.skins, (n = i + input.readInt(true)));\n            for (; i < n; i++) {\n                const skin = this.readSkin(input, skeletonData, false, nonessential);\n\n                if (!skin) throw new Error('readSkin() should not have returned null.');\n                skeletonData.skins[i] = skin;\n            }\n        }\n\n        // Linked meshes.\n        n = this.linkedMeshes.length;\n        for (let i = 0; i < n; i++) {\n            const linkedMesh = this.linkedMeshes[i];\n            const skin = !linkedMesh.skin ? skeletonData.defaultSkin : skeletonData.findSkin(linkedMesh.skin);\n\n            if (!skin) throw new Error('Not skin found for linked mesh.');\n            if (!linkedMesh.parent) throw new Error('Linked mesh parent must not be null');\n            const parent = skin.getAttachment(linkedMesh.slotIndex, linkedMesh.parent);\n\n            if (!parent) throw new Error(`Parent mesh not found: ${linkedMesh.parent}`);\n            linkedMesh.mesh.timelineAttachment = linkedMesh.inheritTimeline ? (parent as VertexAttachment) : linkedMesh.mesh;\n            linkedMesh.mesh.setParentMesh(parent as MeshAttachment);\n            // if (linkedMesh.mesh.region != null) linkedMesh.mesh.updateRegion();\n        }\n        this.linkedMeshes.length = 0;\n\n        // Events.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const eventName = input.readStringRef();\n\n            if (!eventName) throw new Error();\n            const data = new EventData(eventName);\n\n            data.intValue = input.readInt(false);\n            data.floatValue = input.readFloat();\n            data.stringValue = input.readString();\n            data.audioPath = input.readString();\n            if (data.audioPath) {\n                data.volume = input.readFloat();\n                data.balance = input.readFloat();\n            }\n            skeletonData.events.push(data);\n        }\n\n        // Animations.\n        n = input.readInt(true);\n        for (let i = 0; i < n; i++) {\n            const animationName = input.readString();\n\n            if (!animationName) throw new Error('Animatio name must not be null.');\n            skeletonData.animations.push(this.readAnimation(input, animationName, skeletonData));\n        }\n\n        return skeletonData;\n    }\n\n    private readSkin(input: BinaryInput, skeletonData: SkeletonData, defaultSkin: boolean, nonessential: boolean): Skin | null {\n        let skin = null;\n        let slotCount = 0;\n\n        if (defaultSkin) {\n            slotCount = input.readInt(true);\n            if (slotCount == 0) return null;\n            skin = new Skin('default');\n        } else {\n            const skinName = input.readStringRef();\n\n            if (!skinName) throw new Error('Skin name must not be null.');\n            skin = new Skin(skinName);\n            skin.bones.length = input.readInt(true);\n            for (let i = 0, n = skin.bones.length; i < n; i++) skin.bones[i] = skeletonData.bones[input.readInt(true)];\n\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.ikConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.transformConstraints[input.readInt(true)]);\n            for (let i = 0, n = input.readInt(true); i < n; i++) skin.constraints.push(skeletonData.pathConstraints[input.readInt(true)]);\n\n            slotCount = input.readInt(true);\n        }\n\n        for (let i = 0; i < slotCount; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const name = input.readStringRef();\n\n                if (!name) throw new Error('Attachment name must not be null');\n                const attachment = this.readAttachment(input, skeletonData, skin, slotIndex, name, nonessential);\n\n                if (attachment) skin.setAttachment(slotIndex, name, attachment);\n            }\n        }\n\n        return skin;\n    }\n\n    private readAttachment(input: BinaryInput, skeletonData: SkeletonData, skin: Skin, slotIndex: number, attachmentName: string, nonessential: boolean): Attachment | null {\n        const scale = this.scale;\n\n        let name = input.readStringRef();\n\n        if (!name) name = attachmentName;\n\n        switch (input.readByte()) {\n            case AttachmentType.Region: {\n                let path = input.readStringRef();\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const scaleX = input.readFloat();\n                const scaleY = input.readFloat();\n                const width = input.readFloat();\n                const height = input.readFloat();\n                const color = input.readInt32();\n                const sequence = this.readSequence(input);\n\n                if (!path) path = name;\n                const region = this.attachmentLoader.newRegionAttachment(skin, name, path, sequence);\n\n                if (!region) return null;\n                region.path = path;\n                region.x = x * scale;\n                region.y = y * scale;\n                region.scaleX = scaleX;\n                region.scaleY = scaleY;\n                region.rotation = rotation;\n                region.width = width * scale;\n                region.height = height * scale;\n                Color.rgba8888ToColor(region.color, color);\n                region.sequence = sequence;\n                if (sequence == null) region.updateRegion();\n\n                return region;\n            }\n            case AttachmentType.BoundingBox: {\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const box = this.attachmentLoader.newBoundingBoxAttachment(skin, name);\n\n                if (!box) return null;\n                box.worldVerticesLength = vertexCount << 1;\n                box.vertices = vertices.vertices;\n                box.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(box.color, color);\n\n                return box;\n            }\n            case AttachmentType.Mesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const vertexCount = input.readInt(true);\n                const uvs = this.readFloatArray(input, vertexCount << 1, 1);\n                const triangles = this.readShortArray(input);\n                const vertices = this.readVertices(input, vertexCount);\n                const hullLength = input.readInt(true);\n                const sequence = this.readSequence(input);\n                let edges: number[] = [];\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    edges = this.readShortArray(input);\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (!path) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\n                if (!mesh) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                mesh.bones = vertices.bones;\n                mesh.vertices = vertices.vertices;\n                mesh.worldVerticesLength = vertexCount << 1;\n                mesh.triangles = triangles;\n                mesh.regionUVs = new Float32Array(uvs);\n                // if (sequence == null) mesh.updateRegion();\n                mesh.hullLength = hullLength << 1;\n                mesh.sequence = sequence;\n                if (nonessential) {\n                    mesh.edges = edges;\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n\n                return mesh;\n            }\n            case AttachmentType.LinkedMesh: {\n                let path = input.readStringRef();\n                const color = input.readInt32();\n                const skinName = input.readStringRef();\n                const parent = input.readStringRef();\n                const inheritTimelines = input.readBoolean();\n                const sequence = this.readSequence(input);\n                let width = 0;\n                let height = 0;\n\n                if (nonessential) {\n                    width = input.readFloat();\n                    height = input.readFloat();\n                }\n\n                if (!path) path = name;\n                const mesh = this.attachmentLoader.newMeshAttachment(skin, name, path, sequence);\n\n                if (!mesh) return null;\n                mesh.path = path;\n                Color.rgba8888ToColor(mesh.color, color);\n                mesh.sequence = sequence;\n                if (nonessential) {\n                    mesh.width = width * scale;\n                    mesh.height = height * scale;\n                }\n                this.linkedMeshes.push(new LinkedMesh(mesh, skinName, slotIndex, parent, inheritTimelines));\n\n                return mesh;\n            }\n            case AttachmentType.Path: {\n                const closed = input.readBoolean();\n                const constantSpeed = input.readBoolean();\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const lengths = Utils.newArray(vertexCount / 3, 0);\n\n                for (let i = 0, n = lengths.length; i < n; i++) lengths[i] = input.readFloat() * scale;\n                const color = nonessential ? input.readInt32() : 0;\n\n                const path = this.attachmentLoader.newPathAttachment(skin, name);\n\n                if (!path) return null;\n                path.closed = closed;\n                path.constantSpeed = constantSpeed;\n                path.worldVerticesLength = vertexCount << 1;\n                path.vertices = vertices.vertices;\n                path.bones = vertices.bones;\n                path.lengths = lengths;\n                if (nonessential) Color.rgba8888ToColor(path.color, color);\n\n                return path;\n            }\n            case AttachmentType.Point: {\n                const rotation = input.readFloat();\n                const x = input.readFloat();\n                const y = input.readFloat();\n                const color = nonessential ? input.readInt32() : 0;\n\n                const point = this.attachmentLoader.newPointAttachment(skin, name);\n\n                if (!point) return null;\n                point.x = x * scale;\n                point.y = y * scale;\n                point.rotation = rotation;\n                if (nonessential) Color.rgba8888ToColor(point.color, color);\n\n                return point;\n            }\n            case AttachmentType.Clipping: {\n                const endSlotIndex = input.readInt(true);\n                const vertexCount = input.readInt(true);\n                const vertices = this.readVertices(input, vertexCount);\n                const color = nonessential ? input.readInt32() : 0;\n\n                const clip = this.attachmentLoader.newClippingAttachment(skin, name);\n\n                if (!clip) return null;\n                clip.endSlot = skeletonData.slots[endSlotIndex];\n                clip.worldVerticesLength = vertexCount << 1;\n                clip.vertices = vertices.vertices;\n                clip.bones = vertices.bones;\n                if (nonessential) Color.rgba8888ToColor(clip.color, color);\n\n                return clip;\n            }\n        }\n\n        return null;\n    }\n\n    private readSequence(input: BinaryInput) {\n        if (this.ver40 || !input.readBoolean()) return null;\n        const sequence = new Sequence(input.readInt(true));\n\n        sequence.start = input.readInt(true);\n        sequence.digits = input.readInt(true);\n        sequence.setupIndex = input.readInt(true);\n\n        return sequence;\n    }\n\n    private readDeformTimelineType(input: BinaryInput) {\n        if (this.ver40) return ATTACHMENT_DEFORM;\n\n        return input.readByte();\n    }\n\n    private readVertices(input: BinaryInput, vertexCount: number): Vertices {\n        const scale = this.scale;\n        const verticesLength = vertexCount << 1;\n        const vertices = new Vertices();\n\n        if (!input.readBoolean()) {\n            vertices.vertices = this.readFloatArray(input, verticesLength, scale);\n\n            return vertices;\n        }\n        const weights = new Array<number>();\n        const bonesArray = new Array<number>();\n\n        for (let i = 0; i < vertexCount; i++) {\n            const boneCount = input.readInt(true);\n\n            bonesArray.push(boneCount);\n            for (let ii = 0; ii < boneCount; ii++) {\n                bonesArray.push(input.readInt(true));\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat() * scale);\n                weights.push(input.readFloat());\n            }\n        }\n        vertices.vertices = Utils.toFloatArray(weights);\n        vertices.bones = bonesArray;\n\n        return vertices;\n    }\n\n    private readFloatArray(input: BinaryInput, n: number, scale: number): number[] {\n        const array = new Array<number>(n);\n\n        if (scale == 1) {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat();\n        } else {\n            for (let i = 0; i < n; i++) array[i] = input.readFloat() * scale;\n        }\n\n        return array;\n    }\n\n    private readShortArray(input: BinaryInput): number[] {\n        const n = input.readInt(true);\n        const array = new Array<number>(n);\n\n        for (let i = 0; i < n; i++) array[i] = input.readShort();\n\n        return array;\n    }\n\n    private readAnimation(input: BinaryInput, name: string, skeletonData: SkeletonData): Animation {\n        input.readInt(true); // Number of timelines.\n        const timelines = new Array<Timeline>();\n        const scale = this.scale;\n        // Slot timelines.\n\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const slotIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const timelineType = input.readByte();\n                const frameCount = input.readInt(true);\n                const frameLast = frameCount - 1;\n\n                switch (timelineType) {\n                    case SLOT_ATTACHMENT: {\n                        const timeline = new AttachmentTimeline(frameCount, slotIndex);\n\n                        for (let frame = 0; frame < frameCount; frame++) timeline.setFrame(frame, input.readFloat(), input.readStringRef());\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGBA: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBATimeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let a = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, a);\n                            if (frame == frameLast) break;\n\n                            const time2 = input.readFloat();\n                            const r2 = input.readUnsignedByte() / 255.0;\n                            const g2 = input.readUnsignedByte() / 255.0;\n                            const b2 = input.readUnsignedByte() / 255.0;\n                            const a2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, a2, 1);\n                            }\n                            time = time2;\n                            r = r2;\n                            g = g2;\n                            b = b2;\n                            a = a2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGB: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBTimeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b);\n                            if (frame == frameLast) break;\n\n                            const time2 = input.readFloat();\n                            const r2 = input.readUnsignedByte() / 255.0;\n                            const g2 = input.readUnsignedByte() / 255.0;\n                            const b2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, r2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, g2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, b2, 1);\n                            }\n                            time = time2;\n                            r = r2;\n                            g = g2;\n                            b = b2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGBA2: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGBA2Timeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let a = input.readUnsignedByte() / 255.0;\n                        let r2 = input.readUnsignedByte() / 255.0;\n                        let g2 = input.readUnsignedByte() / 255.0;\n                        let b2 = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, a, r2, g2, b2);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const nr = input.readUnsignedByte() / 255.0;\n                            const ng = input.readUnsignedByte() / 255.0;\n                            const nb = input.readUnsignedByte() / 255.0;\n                            const na = input.readUnsignedByte() / 255.0;\n                            const nr2 = input.readUnsignedByte() / 255.0;\n                            const ng2 = input.readUnsignedByte() / 255.0;\n                            const nb2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, a, na, 1);\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, r2, nr2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, g2, ng2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 6, time, time2, b2, nb2, 1);\n                            }\n                            time = time2;\n                            r = nr;\n                            g = ng;\n                            b = nb;\n                            a = na;\n                            r2 = nr2;\n                            g2 = ng2;\n                            b2 = nb2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_RGB2: {\n                        const bezierCount = input.readInt(true);\n                        const timeline = new RGB2Timeline(frameCount, bezierCount, slotIndex);\n\n                        let time = input.readFloat();\n                        let r = input.readUnsignedByte() / 255.0;\n                        let g = input.readUnsignedByte() / 255.0;\n                        let b = input.readUnsignedByte() / 255.0;\n                        let r2 = input.readUnsignedByte() / 255.0;\n                        let g2 = input.readUnsignedByte() / 255.0;\n                        let b2 = input.readUnsignedByte() / 255.0;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, r, g, b, r2, g2, b2);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const nr = input.readUnsignedByte() / 255.0;\n                            const ng = input.readUnsignedByte() / 255.0;\n                            const nb = input.readUnsignedByte() / 255.0;\n                            const nr2 = input.readUnsignedByte() / 255.0;\n                            const ng2 = input.readUnsignedByte() / 255.0;\n                            const nb2 = input.readUnsignedByte() / 255.0;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, r, nr, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, g, ng, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, b, nb, 1);\n                                    setBezier(input, timeline, bezier++, frame, 3, time, time2, r2, nr2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 4, time, time2, g2, ng2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 5, time, time2, b2, nb2, 1);\n                            }\n                            time = time2;\n                            r = nr;\n                            g = ng;\n                            b = nb;\n                            r2 = nr2;\n                            g2 = ng2;\n                            b2 = nb2;\n                        }\n                        timelines.push(timeline);\n                        break;\n                    }\n                    case SLOT_ALPHA: {\n                        const timeline = new AlphaTimeline(frameCount, input.readInt(true), slotIndex);\n                        let time = input.readFloat();\n                        let a = input.readUnsignedByte() / 255;\n\n                        for (let frame = 0, bezier = 0; ; frame++) {\n                            timeline.setFrame(frame, time, a);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const a2 = input.readUnsignedByte() / 255;\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, a, a2, 1);\n                            }\n                            time = time2;\n                            a = a2;\n                        }\n                        timelines.push(timeline);\n                    }\n                }\n            }\n        }\n\n        // Bone timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const boneIndex = input.readInt(true);\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const type = input.readByte();\n                const frameCount = input.readInt(true);\n                const bezierCount = input.readInt(true);\n\n                switch (type) {\n                    case BONE_ROTATE:\n                        timelines.push(readTimeline1(input, new RotateTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_TRANSLATE:\n                        timelines.push(readTimeline2(input, new TranslateTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_TRANSLATEX:\n                        timelines.push(readTimeline1(input, new TranslateXTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_TRANSLATEY:\n                        timelines.push(readTimeline1(input, new TranslateYTimeline(frameCount, bezierCount, boneIndex), scale));\n                        break;\n                    case BONE_SCALE:\n                        timelines.push(readTimeline2(input, new ScaleTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SCALEX:\n                        timelines.push(readTimeline1(input, new ScaleXTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SCALEY:\n                        timelines.push(readTimeline1(input, new ScaleYTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEAR:\n                        timelines.push(readTimeline2(input, new ShearTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEARX:\n                        timelines.push(readTimeline1(input, new ShearXTimeline(frameCount, bezierCount, boneIndex), 1));\n                        break;\n                    case BONE_SHEARY:\n                        timelines.push(readTimeline1(input, new ShearYTimeline(frameCount, bezierCount, boneIndex), 1));\n                }\n            }\n        }\n\n        // IK constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const frameLast = frameCount - 1;\n            const timeline = new IkConstraintTimeline(frameCount, input.readInt(true), index);\n            let time = input.readFloat();\n            let mix = input.readFloat();\n            let softness = input.readFloat() * scale;\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n                timeline.setFrame(frame, time, mix, softness, input.readByte(), input.readBoolean(), input.readBoolean());\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const mix2 = input.readFloat();\n                const softness2 = input.readFloat() * scale;\n\n                switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                        timeline.setStepped(frame);\n                        break;\n                    case CURVE_BEZIER:\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mix, mix2, 1);\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, softness, softness2, scale);\n                }\n                time = time2;\n                mix = mix2;\n                softness = softness2;\n            }\n            timelines.push(timeline);\n        }\n\n        // Transform constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const frameCount = input.readInt(true);\n            const frameLast = frameCount - 1;\n            const timeline = new TransformConstraintTimeline(frameCount, input.readInt(true), index);\n            let time = input.readFloat();\n            let mixRotate = input.readFloat();\n            let mixX = input.readFloat();\n            let mixY = input.readFloat();\n            let mixScaleX = input.readFloat();\n            let mixScaleY = input.readFloat();\n            let mixShearY = input.readFloat();\n\n            for (let frame = 0, bezier = 0; ; frame++) {\n                timeline.setFrame(frame, time, mixRotate, mixX, mixY, mixScaleX, mixScaleY, mixShearY);\n                if (frame == frameLast) break;\n                const time2 = input.readFloat();\n                const mixRotate2 = input.readFloat();\n                const mixX2 = input.readFloat();\n                const mixY2 = input.readFloat();\n                const mixScaleX2 = input.readFloat();\n                const mixScaleY2 = input.readFloat();\n                const mixShearY2 = input.readFloat();\n\n                switch (input.readByte()) {\n                    case CURVE_STEPPED:\n                        timeline.setStepped(frame);\n                        break;\n                    case CURVE_BEZIER:\n                        setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                        setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                        setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n                        setBezier(input, timeline, bezier++, frame, 3, time, time2, mixScaleX, mixScaleX2, 1);\n                        setBezier(input, timeline, bezier++, frame, 4, time, time2, mixScaleY, mixScaleY2, 1);\n                        setBezier(input, timeline, bezier++, frame, 5, time, time2, mixShearY, mixShearY2, 1);\n                }\n                time = time2;\n                mixRotate = mixRotate2;\n                mixX = mixX2;\n                mixY = mixY2;\n                mixScaleX = mixScaleX2;\n                mixScaleY = mixScaleY2;\n                mixShearY = mixShearY2;\n            }\n            timelines.push(timeline);\n        }\n\n        // Path constraint timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const index = input.readInt(true);\n            const data = skeletonData.pathConstraints[index];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                switch (input.readByte()) {\n                    case PATH_POSITION:\n                        timelines.push(\n                            readTimeline1(\n                                input,\n                                new PathConstraintPositionTimeline(input.readInt(true), input.readInt(true), index),\n                                data.positionMode == PositionMode.Fixed ? scale : 1\n                            )\n                        );\n                        break;\n                    case PATH_SPACING:\n                        timelines.push(\n                            readTimeline1(\n                                input,\n                                new PathConstraintSpacingTimeline(input.readInt(true), input.readInt(true), index),\n                                data.spacingMode == SpacingMode.Length || data.spacingMode == SpacingMode.Fixed ? scale : 1\n                            )\n                        );\n                        break;\n                    case PATH_MIX:\n                        const timeline = new PathConstraintMixTimeline(input.readInt(true), input.readInt(true), index);\n                        let time = input.readFloat();\n                        let mixRotate = input.readFloat();\n                        let mixX = input.readFloat();\n                        let mixY = input.readFloat();\n\n                        for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n                            timeline.setFrame(frame, time, mixRotate, mixX, mixY);\n                            if (frame == frameLast) break;\n                            const time2 = input.readFloat();\n                            const mixRotate2 = input.readFloat();\n                            const mixX2 = input.readFloat();\n                            const mixY2 = input.readFloat();\n\n                            switch (input.readByte()) {\n                                case CURVE_STEPPED:\n                                    timeline.setStepped(frame);\n                                    break;\n                                case CURVE_BEZIER:\n                                    setBezier(input, timeline, bezier++, frame, 0, time, time2, mixRotate, mixRotate2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 1, time, time2, mixX, mixX2, 1);\n                                    setBezier(input, timeline, bezier++, frame, 2, time, time2, mixY, mixY2, 1);\n                            }\n                            time = time2;\n                            mixRotate = mixRotate2;\n                            mixX = mixX2;\n                            mixY = mixY2;\n                        }\n                        timelines.push(timeline);\n                }\n            }\n        }\n\n        // Deform timelines.\n        for (let i = 0, n = input.readInt(true); i < n; i++) {\n            const skin = skeletonData.skins[input.readInt(true)];\n\n            for (let ii = 0, nn = input.readInt(true); ii < nn; ii++) {\n                const slotIndex = input.readInt(true);\n\n                for (let iii = 0, nnn = input.readInt(true); iii < nnn; iii++) {\n                    const attachmentName = input.readStringRef();\n\n                    if (!attachmentName) throw new Error('attachmentName must not be null.');\n                    const attachment = skin.getAttachment(slotIndex, attachmentName);\n                    const timelineType = this.readDeformTimelineType(input);\n                    const frameCount = input.readInt(true);\n                    const frameLast = frameCount - 1;\n\n                    switch (timelineType) {\n                        case ATTACHMENT_DEFORM: {\n                            const vertexAttachment = attachment as VertexAttachment;\n                            const weighted = vertexAttachment.bones;\n                            const vertices = vertexAttachment.vertices;\n                            const deformLength = weighted ? (vertices.length / 3) * 2 : vertices.length;\n\n                            const bezierCount = input.readInt(true);\n                            const timeline = new DeformTimeline(frameCount, bezierCount, slotIndex, vertexAttachment);\n\n                            let time = input.readFloat();\n\n                            for (let frame = 0, bezier = 0; ; frame++) {\n                                let deform;\n                                let end = input.readInt(true);\n\n                                if (end == 0) deform = weighted ? Utils.newFloatArray(deformLength) : vertices;\n                                else {\n                                    deform = Utils.newFloatArray(deformLength);\n                                    const start = input.readInt(true);\n\n                                    end += start;\n                                    /* eslint-disable max-depth*/\n                                    if (scale == 1) {\n                                        for (let v = start; v < end; v++) deform[v] = input.readFloat();\n                                    } else {\n                                        for (let v = start; v < end; v++) deform[v] = input.readFloat() * scale;\n                                    }\n                                    if (!weighted) {\n                                        for (let v = 0, vn = deform.length; v < vn; v++) deform[v] += vertices[v];\n                                    }\n                                    /* eslint-enable max-depth*/\n                                }\n\n                                timeline.setFrame(frame, time, deform);\n                                if (frame == frameLast) break;\n                                const time2 = input.readFloat();\n\n                                switch (input.readByte()) {\n                                    case CURVE_STEPPED:\n                                        timeline.setStepped(frame);\n                                        break;\n                                    case CURVE_BEZIER:\n                                        setBezier(input, timeline, bezier++, frame, 0, time, time2, 0, 1, 1);\n                                }\n                                time = time2;\n                            }\n                            timelines.push(timeline);\n                            break;\n                        }\n                        case ATTACHMENT_SEQUENCE: {\n                            const timeline = new SequenceTimeline(frameCount, slotIndex, attachment as unknown as IHasTextureRegion);\n\n                            for (let frame = 0; frame < frameCount; frame++) {\n                                const time = input.readFloat();\n                                const modeAndIndex = input.readInt32();\n\n                                timeline.setFrame(frame, time, SequenceModeValues[modeAndIndex & 0xf], modeAndIndex >> 4, input.readFloat());\n                            }\n                            timelines.push(timeline);\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        // Draw order timeline.\n        const drawOrderCount = input.readInt(true);\n\n        if (drawOrderCount > 0) {\n            const timeline = new DrawOrderTimeline(drawOrderCount);\n            const slotCount = skeletonData.slots.length;\n\n            for (let i = 0; i < drawOrderCount; i++) {\n                const time = input.readFloat();\n                const offsetCount = input.readInt(true);\n                const drawOrder = Utils.newArray(slotCount, 0);\n\n                for (let ii = slotCount - 1; ii >= 0; ii--) drawOrder[ii] = -1;\n                const unchanged = Utils.newArray(slotCount - offsetCount, 0);\n                let originalIndex = 0;\n                let unchangedIndex = 0;\n\n                for (let ii = 0; ii < offsetCount; ii++) {\n                    const slotIndex = input.readInt(true);\n                    // Collect unchanged items.\n\n                    while (originalIndex != slotIndex) unchanged[unchangedIndex++] = originalIndex++;\n                    // Set changed items.\n                    drawOrder[originalIndex + input.readInt(true)] = originalIndex++;\n                }\n                // Collect remaining unchanged items.\n                while (originalIndex < slotCount) unchanged[unchangedIndex++] = originalIndex++;\n                // Fill in unchanged items.\n                for (let ii = slotCount - 1; ii >= 0; ii--) if (drawOrder[ii] == -1) drawOrder[ii] = unchanged[--unchangedIndex];\n                timeline.setFrame(i, time, drawOrder);\n            }\n            timelines.push(timeline);\n        }\n\n        // Event timeline.\n        const eventCount = input.readInt(true);\n\n        if (eventCount > 0) {\n            const timeline = new EventTimeline(eventCount);\n\n            for (let i = 0; i < eventCount; i++) {\n                const time = input.readFloat();\n                const eventData = skeletonData.events[input.readInt(true)];\n                const event = new Event(time, eventData);\n\n                event.intValue = input.readInt(false);\n                event.floatValue = input.readFloat();\n                event.stringValue = input.readBoolean() ? input.readString() : eventData.stringValue;\n                if (event.data.audioPath) {\n                    event.volume = input.readFloat();\n                    event.balance = input.readFloat();\n                }\n                timeline.setFrame(i, event);\n            }\n            timelines.push(timeline);\n        }\n\n        let duration = 0;\n\n        for (let i = 0, n = timelines.length; i < n; i++) duration = Math.max(duration, timelines[i].getDuration());\n\n        return new Animation(name, timelines, duration);\n    }\n}\n\nclass LinkedMesh {\n    parent: string | null;\n    skin: string | null;\n    slotIndex: number;\n    mesh: MeshAttachment;\n    inheritTimeline: boolean;\n\n    constructor(mesh: MeshAttachment, skin: string | null, slotIndex: number, parent: string | null, inheritDeform: boolean) {\n        this.mesh = mesh;\n        this.skin = skin;\n        this.slotIndex = slotIndex;\n        this.parent = parent;\n        this.inheritTimeline = inheritDeform;\n    }\n}\n\nclass Vertices {\n    constructor(public bones: Array<number> | null = null, public vertices: Array<number> | Float32Array | null = null) {}\n}\n\nfunction readTimeline1(input: BinaryInput, timeline: CurveTimeline1, scale: number): CurveTimeline1 {\n    let time = input.readFloat();\n    let value = input.readFloat() * scale;\n\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n        timeline.setFrame(frame, time, value);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const value2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n            case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n            case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value, value2, scale);\n        }\n        time = time2;\n        value = value2;\n    }\n\n    return timeline;\n}\n\nfunction readTimeline2(input: BinaryInput, timeline: CurveTimeline2, scale: number): CurveTimeline2 {\n    let time = input.readFloat();\n    let value1 = input.readFloat() * scale;\n    let value2 = input.readFloat() * scale;\n\n    for (let frame = 0, bezier = 0, frameLast = timeline.getFrameCount() - 1; ; frame++) {\n        timeline.setFrame(frame, time, value1, value2);\n        if (frame == frameLast) break;\n        const time2 = input.readFloat();\n        const nvalue1 = input.readFloat() * scale;\n        const nvalue2 = input.readFloat() * scale;\n\n        switch (input.readByte()) {\n            case CURVE_STEPPED:\n                timeline.setStepped(frame);\n                break;\n            case CURVE_BEZIER:\n                setBezier(input, timeline, bezier++, frame, 0, time, time2, value1, nvalue1, scale);\n                setBezier(input, timeline, bezier++, frame, 1, time, time2, value2, nvalue2, scale);\n        }\n        time = time2;\n        value1 = nvalue1;\n        value2 = nvalue2;\n    }\n\n    return timeline;\n}\n\nfunction setBezier(\n    input: BinaryInput,\n    timeline: CurveTimeline,\n    bezier: number,\n    frame: number,\n    value: number,\n    time1: number,\n    time2: number,\n    value1: number,\n    value2: number,\n    scale: number\n) {\n    timeline.setBezier(bezier, frame, value, time1, value1, input.readFloat(), input.readFloat() * scale, input.readFloat(), input.readFloat() * scale, time2, value2);\n}\n\nconst BONE_ROTATE = 0;\nconst BONE_TRANSLATE = 1;\nconst BONE_TRANSLATEX = 2;\nconst BONE_TRANSLATEY = 3;\nconst BONE_SCALE = 4;\nconst BONE_SCALEX = 5;\nconst BONE_SCALEY = 6;\nconst BONE_SHEAR = 7;\nconst BONE_SHEARX = 8;\nconst BONE_SHEARY = 9;\n\nconst SLOT_ATTACHMENT = 0;\nconst SLOT_RGBA = 1;\nconst SLOT_RGB = 2;\nconst SLOT_RGBA2 = 3;\nconst SLOT_RGB2 = 4;\nconst SLOT_ALPHA = 5;\n\nconst ATTACHMENT_DEFORM = 0;\nconst ATTACHMENT_SEQUENCE = 1;\n\nconst PATH_POSITION = 0;\nconst PATH_SPACING = 1;\nconst PATH_MIX = 2;\n\n// const CURVE_LINEAR = 0;\nconst CURVE_STEPPED = 1;\nconst CURVE_BEZIER = 2;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}