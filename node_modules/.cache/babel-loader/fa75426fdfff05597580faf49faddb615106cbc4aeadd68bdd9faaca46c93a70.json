{"ast":null,"code":"/* eslint-disable */\nexport async function initSpine() {\n  var app = new PIXI.Application();\n  await app.init({\n    width: window.innerWidth,\n    height: window.innerHeight,\n    resolution: window.devicePixelRatio || 1,\n    autoDensity: true,\n    resizeTo: window,\n    backgroundColor: 0x2c3e50,\n    hello: true\n  });\n  document.body.appendChild(app.view);\n\n  // Pre-load the skeleton data and atlas. You can also load .json skeleton data.\n  PIXI.Assets.add({\n    alias: \"spineboyData\",\n    src: \"./spineboy-pro.skel\"\n  });\n  PIXI.Assets.add({\n    alias: \"spineboyAtlas\",\n    src: \"./spineboy-pma.atlas\"\n  });\n  await PIXI.Assets.load([\"spineboyData\", \"spineboyAtlas\"]);\n\n  // Create the spine display object\n  const spineboy = spine.Spine.from({\n    skeleton: \"spineboyData\",\n    atlas: \"spineboyAtlas\",\n    scale: 0.5\n  });\n\n  // Set the default mix time to use when transitioning\n  // from one animation to another.\n  spineboy.state.data.defaultMix = 0.2;\n\n  // Center the Spine object on screen.\n  spineboy.x = window.innerWidth / 2;\n  spineboy.y = window.innerHeight / 2 + spineboy.getBounds().height / 2;\n\n  // Set looping animations \"idle\" on track 0 and \"aim\" on track 1.\n  spineboy.state.setAnimation(0, \"idle\", true);\n  spineboy.state.setAnimation(1, \"aim\", true);\n\n  // Add the display object to the stage.\n  app.stage.addChild(spineboy);\n  app.stage.hitArea = new PIXI.Rectangle(0, 0, app.view.width, app.view.height);\n\n  // Make the stage interactive and register pointer events\n  app.stage.eventMode = \"dynamic\";\n  let isDragging = false;\n  const bones = spineboy.skeleton.bones;\n  console.log(bones);\n\n  // Set looping animations \"idle\" on track 0 and \"aim\" on track 1.\n  spineboy.state.setAnimation(0, \"idle\", true);\n  spineboy.state.setAnimation(1, \"aim\", true);\n\n  // Add the display object to the stage.\n  app.stage.addChild(spineboy);\n  app.stage.hitArea = new PIXI.Rectangle(0, 0, app.view.width, app.view.height);\n\n  // Make the stage interactive and register pointer events\n  app.stage.eventMode = \"dynamic\";\n\n  // Event handler for pointer down\n  app.stage.on(\"pointerdown\", e => {\n    isDragging = true;\n    setBonePosition(e); // Adjust the bone position based on pointer\n\n    // Set the aim animation\n    spineboy.state.setAnimation(1, \"aim\", true); // Use \"aim\" animation instead of \"shoot\"\n  });\n\n  // Event handler for pointer up\n  app.stage.on(\"pointerup\", () => {\n    isDragging = false;\n\n    // Optionally reset to idle or keep the last animation\n    // spineboy.state.setAnimation(0, \"idle\", true);\n  });\n\n  // Optional: Event handler for pointer move to set the position of the bone\n  app.stage.on(\"pointermove\", e => {\n    if (isDragging) {\n      setBonePosition(e);\n\n      // Determine the aim position\n      const aimX = e.data.global.x; // Pointer's x position in the global space\n      const spineboyX = spineboy.x; // Spineboy's x position\n\n      // Update spineboy's scale based on aim position\n      if (aimX < spineboyX) {\n        spineboy.skeleton.scaleX = -1; // Turn left\n      } else {\n        spineboy.skeleton.scaleX = 1; // Turn right\n      }\n\n      // Maintain the aim animation while dragging\n      spineboy.state.setAnimation(1, \"aim\", true); // Keep \"aim\" animation active\n    }\n  });\n\n  // Function to set the position of the bone\n  function setBonePosition(e) {\n    const point = e.data.getLocalPosition(spineboy); // Get the local position relative to the spineboy\n    const bone = spineboy.skeleton.findBone(\"crosshair\"); // Assuming \"crosshair\" is the bone you're manipulating\n    if (bone) {\n      // Set the bone's position based on the pointer location\n      bone.x = point.x;\n      bone.y = point.y;\n    }\n  }\n\n  // wait a frame as pixi bounds do not work until rendered\n  await new Promise(resolve => requestAnimationFrame(resolve));\n  // Add variables for movement, speed.\n  let moveLeft = false;\n  let moveRight = false;\n  const speed = 5;\n\n  // Handle the case that the keyboard keys specified below are pressed.\n  function onKeyDown(key) {\n    spineboy.state.setAnimation(0, \"hoverboard\", true, 0);\n    if (key.code === \"ArrowLeft\" || key.code === \"KeyA\") {\n      moveLeft = true;\n      spineboy.skeleton.scaleX = -1;\n    } else if (key.code === \"ArrowRight\" || key.code === \"KeyD\") {\n      moveRight = true;\n      spineboy.skeleton.scaleX = 1;\n    }\n  }\n\n  // Handle when the keys are released, if they were pressed.\n  function onKeyUp(key) {\n    if (key.code === \"ArrowLeft\" || key.code === \"KeyA\") {\n      moveLeft = false;\n    } else if (key.code === \"ArrowRight\" || key.code === \"KeyD\") {\n      moveRight = false;\n    }\n  }\n\n  // Add event listeners so that the window will correctly handle input.\n  window.addEventListener(\"keydown\", onKeyDown);\n  window.addEventListener(\"keyup\", onKeyUp);\n\n  // Update the application to move Spineboy if input is detected.\n  app.ticker.add(() => {\n    if (moveLeft) {\n      spineboy.x -= speed;\n    }\n    if (moveRight) {\n      spineboy.x += speed;\n    }\n  });\n\n  //time for sack\n  // Pre-load the skeleton data and atlas. You can also load .json skeleton data.\n  PIXI.Assets.add({\n    alias: \"sackData\",\n    src: \"./sack-pro.skel\"\n  });\n  PIXI.Assets.add({\n    alias: \"sackAtlas\",\n    src: \"./sack-pma.atlas\"\n  });\n  await PIXI.Assets.load([\"sackData\", \"sackAtlas\"]);\n\n  // Create the spine display object\n  const sack = spine.Spine.from({\n    skeleton: \"sackData\",\n    atlas: \"sackAtlas\",\n    scale: 0.1\n  });\n\n  // Center the spine object on screen.\n  sack.x = window.innerWidth / 2;\n  sack.y = window.innerHeight / 2 + sack.getBounds().height / 2;\n\n  // Set animation \"cape-follow-example\" on track 0, looped.\n  sack.state.setAnimation(0, \"cape-follow-example\", true);\n  // Add the display object to the stage.\n  app.stage.addChild(sack);\n  setInterval(jumpSack, 1000);\n\n  // Function to randomly jump the sack within a specified range\n  function jumpSack() {\n    const jumpDistance = 450; // Define a distance to consider for collision check\n    let newX, newY;\n    let tooClose = true;\n\n    // Keep generating new positions until a valid one is found\n    while (tooClose) {\n      // Randomly generate X and Y positions between 100 and 1000\n      newX = Math.random() * (1000 - 100) + 100; // Random X between 100 and 1000\n      newY = Math.random() * (1000 - 100) + 100; // Random Y between 100 and 1000\n\n      // Calculate distance from the spineboy\n      const distanceX = newX - spineboy.x;\n      const distanceY = newY - spineboy.y;\n      const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n      // Check if the new position is too close to the spineboy\n      if (distance > jumpDistance) {\n        tooClose = false; // Valid position found\n      }\n    }\n\n    // Update sack's position\n    sack.x = newX;\n    sack.y = newY;\n  }\n}","map":{"version":3,"names":["initSpine","app","PIXI","Application","init","width","window","innerWidth","height","innerHeight","resolution","devicePixelRatio","autoDensity","resizeTo","backgroundColor","hello","document","body","appendChild","view","Assets","add","alias","src","load","spineboy","spine","Spine","from","skeleton","atlas","scale","state","data","defaultMix","x","y","getBounds","setAnimation","stage","addChild","hitArea","Rectangle","eventMode","isDragging","bones","console","log","on","e","setBonePosition","aimX","global","spineboyX","scaleX","point","getLocalPosition","bone","findBone","Promise","resolve","requestAnimationFrame","moveLeft","moveRight","speed","onKeyDown","key","code","onKeyUp","addEventListener","ticker","sack","setInterval","jumpSack","jumpDistance","newX","newY","tooClose","Math","random","distanceX","distanceY","distance","sqrt"],"sources":["/Users/divya/Documents/vue-2024-spine/vue-20240spine/src/spine.js"],"sourcesContent":["/* eslint-disable */\nexport async function initSpine () {\n    var app = new PIXI.Application();\n    await app.init({\n        width: window.innerWidth,\n        height: window.innerHeight,\n        resolution: window.devicePixelRatio || 1,\n        autoDensity: true,\n        resizeTo: window,\n        backgroundColor: 0x2c3e50,\n        hello: true,\n    })\n    document.body.appendChild(app.view);\n\n    // Pre-load the skeleton data and atlas. You can also load .json skeleton data.\n    PIXI.Assets.add({alias: \"spineboyData\", src: \"./spineboy-pro.skel\" });\n    PIXI.Assets.add({alias: \"spineboyAtlas\", src: \"./spineboy-pma.atlas\" });\n    await PIXI.Assets.load([\"spineboyData\", \"spineboyAtlas\"]);\n\n    // Create the spine display object\n    const spineboy = spine.Spine.from({skeleton: \"spineboyData\", atlas: \"spineboyAtlas\", \n        scale: 0.5,\n    });\n\n    // Set the default mix time to use when transitioning\n    // from one animation to another.\n    spineboy.state.data.defaultMix = 0.2;\n\n    // Center the Spine object on screen.\n    spineboy.x = window.innerWidth / 2;\n    spineboy.y = window.innerHeight / 2 + spineboy.getBounds().height / 2;\n\n    // Set looping animations \"idle\" on track 0 and \"aim\" on track 1.\n    spineboy.state.setAnimation(0, \"idle\", true);\n    spineboy.state.setAnimation(1, \"aim\", true);\n\n    // Add the display object to the stage.\n    app.stage.addChild(spineboy);\n    app.stage.hitArea = new PIXI.Rectangle(0, 0, app.view.width, app.view.height);\n\n    // Make the stage interactive and register pointer events\n    app.stage.eventMode = \"dynamic\";\n    let isDragging = false;\n    const bones = spineboy.skeleton.bones;\nconsole.log(bones)\n  \n// Set looping animations \"idle\" on track 0 and \"aim\" on track 1.\nspineboy.state.setAnimation(0, \"idle\", true);\nspineboy.state.setAnimation(1, \"aim\", true);\n\n// Add the display object to the stage.\napp.stage.addChild(spineboy);\napp.stage.hitArea = new PIXI.Rectangle(0, 0, app.view.width, app.view.height);\n\n// Make the stage interactive and register pointer events\napp.stage.eventMode = \"dynamic\";\n\n// Event handler for pointer down\napp.stage.on(\"pointerdown\", (e) => {\n    isDragging = true;\n    setBonePosition(e); // Adjust the bone position based on pointer\n\n    // Set the aim animation\n    spineboy.state.setAnimation(1, \"aim\", true); // Use \"aim\" animation instead of \"shoot\"\n});\n\n// Event handler for pointer up\napp.stage.on(\"pointerup\", () => {\n    isDragging = false;\n\n    // Optionally reset to idle or keep the last animation\n    // spineboy.state.setAnimation(0, \"idle\", true);\n});\n\n// Optional: Event handler for pointer move to set the position of the bone\napp.stage.on(\"pointermove\", (e) => {\n    if (isDragging) {\n        setBonePosition(e);\n        \n        // Determine the aim position\n        const aimX = e.data.global.x; // Pointer's x position in the global space\n        const spineboyX = spineboy.x; // Spineboy's x position\n\n        // Update spineboy's scale based on aim position\n        if (aimX < spineboyX) {\n            spineboy.skeleton.scaleX = -1; // Turn left\n        } else {\n            spineboy.skeleton.scaleX = 1; // Turn right\n        }\n\n        // Maintain the aim animation while dragging\n        spineboy.state.setAnimation(1, \"aim\", true); // Keep \"aim\" animation active\n    }\n});\n\n// Function to set the position of the bone\nfunction setBonePosition(e) {\n    const point = e.data.getLocalPosition(spineboy); // Get the local position relative to the spineboy\n    const bone = spineboy.skeleton.findBone(\"crosshair\"); // Assuming \"crosshair\" is the bone you're manipulating\n    if (bone) {\n        // Set the bone's position based on the pointer location\n        bone.x = point.x;\n        bone.y = point.y;\n    }\n}\n\n\n\n      // wait a frame as pixi bounds do not work until rendered\n      await new Promise((resolve) => requestAnimationFrame(resolve));\n // Add variables for movement, speed.\n let moveLeft = false;\n let moveRight = false;\n const speed = 5;\n\n\n      // Handle the case that the keyboard keys specified below are pressed.\n      function onKeyDown(key) {\n        spineboy.state.setAnimation(0, \"hoverboard\", true, 0);\n        if (key.code === \"ArrowLeft\" || key.code === \"KeyA\") {\n          moveLeft = true;\n          spineboy.skeleton.scaleX = -1;\n        } else if (key.code === \"ArrowRight\" || key.code === \"KeyD\") {\n          moveRight = true;\n          spineboy.skeleton.scaleX = 1;\n        }\n      }\n\n      // Handle when the keys are released, if they were pressed.\n      function onKeyUp(key) {\n        if (key.code === \"ArrowLeft\" || key.code === \"KeyA\") {\n          moveLeft = false;\n        } else if (key.code === \"ArrowRight\" || key.code === \"KeyD\") {\n          moveRight = false;\n        }\n      }\n\n      // Add event listeners so that the window will correctly handle input.\n      window.addEventListener(\"keydown\", onKeyDown);\n      window.addEventListener(\"keyup\", onKeyUp);\n\n      // Update the application to move Spineboy if input is detected.\n      app.ticker.add(() => {\n        if (moveLeft) {\n          spineboy.x -= speed;\n        }\n        if (moveRight) {\n          spineboy.x += speed;\n        }\n      });\n\n\n\n\n\n      //time for sack\n       // Pre-load the skeleton data and atlas. You can also load .json skeleton data.\n    PIXI.Assets.add({alias: \"sackData\", src: \"./sack-pro.skel\"});\n    PIXI.Assets.add({alias: \"sackAtlas\", src: \"./sack-pma.atlas\"});\n    await PIXI.Assets.load([\"sackData\", \"sackAtlas\"]);\n\n    // Create the spine display object\n    const sack = spine.Spine.from({skeleton: \"sackData\", atlas: \"sackAtlas\", \n      scale: 0.1,\n    });\n\n    // Center the spine object on screen.\n    sack.x = window.innerWidth / 2;\n    sack.y = window.innerHeight / 2 + sack.getBounds().height / 2;\n\n    // Set animation \"cape-follow-example\" on track 0, looped.\n    sack.state.setAnimation(0, \"cape-follow-example\", true);\n    // Add the display object to the stage.\n    app.stage.addChild(sack);\n\n\n    setInterval(jumpSack, 1000);\n\n    // Function to randomly jump the sack within a specified range\n    function jumpSack() {\n        const jumpDistance = 450; // Define a distance to consider for collision check\n        let newX, newY;\n        let tooClose = true;\n\n        // Keep generating new positions until a valid one is found\n        while (tooClose) {\n            // Randomly generate X and Y positions between 100 and 1000\n            newX = Math.random() * (1000 - 100) + 100; // Random X between 100 and 1000\n            newY = Math.random() * (1000 - 100) + 100; // Random Y between 100 and 1000\n\n            // Calculate distance from the spineboy\n            const distanceX = newX - spineboy.x;\n            const distanceY = newY - spineboy.y;\n            const distance = Math.sqrt(distanceX * distanceX + distanceY * distanceY);\n\n            // Check if the new position is too close to the spineboy\n            if (distance > jumpDistance) {\n                tooClose = false; // Valid position found\n            }\n        }\n\n        // Update sack's position\n        sack.x = newX;\n        sack.y = newY;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}