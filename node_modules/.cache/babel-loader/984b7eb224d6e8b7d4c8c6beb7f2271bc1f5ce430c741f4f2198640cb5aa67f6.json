{"ast":null,"code":"import { Texture as Texture$1 } from 'pixi.js';\nimport { Texture, TextureFilter, TextureWrap, BlendMode } from '@esotericsoftware/spine-core';\nvar __defProp = Object.defineProperty;\nvar __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, {\n  enumerable: true,\n  configurable: true,\n  writable: true,\n  value\n}) : obj[key] = value;\nvar __publicField = (obj, key, value) => {\n  __defNormalProp(obj, typeof key !== \"symbol\" ? key + \"\" : key, value);\n  return value;\n};\nconst _SpineTexture = class _SpineTexture extends Texture {\n  constructor(image) {\n    super(image.resource);\n    __publicField(this, \"texture\");\n    this.texture = Texture$1.from(image);\n  }\n  static from(texture) {\n    if (_SpineTexture.textureMap.has(texture)) {\n      return _SpineTexture.textureMap.get(texture);\n    }\n    return new _SpineTexture(texture);\n  }\n  setFilters(minFilter, magFilter) {\n    const style = this.texture.source.style;\n    style.minFilter = _SpineTexture.toPixiTextureFilter(minFilter);\n    style.magFilter = _SpineTexture.toPixiTextureFilter(magFilter);\n    this.texture.source.autoGenerateMipmaps = _SpineTexture.toPixiMipMap(minFilter);\n    this.texture.source.updateMipmaps();\n  }\n  setWraps(uWrap, vWrap) {\n    const style = this.texture.source.style;\n    style.addressModeU = _SpineTexture.toPixiTextureWrap(uWrap);\n    style.addressModeV = _SpineTexture.toPixiTextureWrap(vWrap);\n  }\n  dispose() {\n    this.texture.destroy();\n  }\n  static toPixiMipMap(filter) {\n    switch (filter) {\n      case TextureFilter.Nearest:\n      case TextureFilter.Linear:\n        return false;\n      case TextureFilter.MipMapNearestLinear:\n      case TextureFilter.MipMapNearestNearest:\n      case TextureFilter.MipMapLinearLinear:\n      case TextureFilter.MipMapLinearNearest:\n        return true;\n      default:\n        throw new Error(`Unknown texture filter: ${String(filter)}`);\n    }\n  }\n  static toPixiTextureFilter(filter) {\n    switch (filter) {\n      case TextureFilter.Nearest:\n      case TextureFilter.MipMapNearestLinear:\n      case TextureFilter.MipMapNearestNearest:\n        return \"nearest\";\n      case TextureFilter.Linear:\n      case TextureFilter.MipMapLinearLinear:\n      case TextureFilter.MipMapLinearNearest:\n        return \"linear\";\n      default:\n        throw new Error(`Unknown texture filter: ${String(filter)}`);\n    }\n  }\n  static toPixiTextureWrap(wrap) {\n    switch (wrap) {\n      case TextureWrap.ClampToEdge:\n        return \"clamp-to-edge\";\n      case TextureWrap.MirroredRepeat:\n        return \"mirror-repeat\";\n      case TextureWrap.Repeat:\n        return \"repeat\";\n      default:\n        throw new Error(`Unknown texture wrap: ${String(wrap)}`);\n    }\n  }\n  static toPixiBlending(blend) {\n    switch (blend) {\n      case BlendMode.Normal:\n        return \"normal\";\n      case BlendMode.Additive:\n        return \"add\";\n      case BlendMode.Multiply:\n        return \"multiply\";\n      case BlendMode.Screen:\n        return \"screen\";\n      default:\n        throw new Error(`Unknown blendMode: ${String(blend)}`);\n    }\n  }\n};\n__publicField(_SpineTexture, \"textureMap\", /* @__PURE__ */new Map());\nlet SpineTexture = _SpineTexture;\nexport { SpineTexture };","map":{"version":3,"names":["_SpineTexture","Texture","constructor","image","resource","__publicField","texture","Texture$1","from","textureMap","has","get","setFilters","minFilter","magFilter","style","source","toPixiTextureFilter","autoGenerateMipmaps","toPixiMipMap","updateMipmaps","setWraps","uWrap","vWrap","addressModeU","toPixiTextureWrap","addressModeV","dispose","destroy","filter","TextureFilter","Nearest","Linear","MipMapNearestLinear","MipMapNearestNearest","MipMapLinearLinear","MipMapLinearNearest","Error","String","wrap","TextureWrap","ClampToEdge","MirroredRepeat","Repeat","toPixiBlending","blend","BlendMode","Normal","Additive","Multiply","Screen","Map","SpineTexture"],"sources":["../src/SpineTexture.ts"],"sourcesContent":["/** ****************************************************************************\n * Spine Runtimes License Agreement\n * Last updated July 28, 2023. Replaces all prior versions.\n *\n * Copyright (c) 2013-2023, Esoteric Software LLC\n *\n * Integration of the Spine Runtimes into software or otherwise creating\n * derivative works of the Spine Runtimes is permitted under the terms and\n * conditions of Section 2 of the Spine Editor License Agreement:\n * http://esotericsoftware.com/spine-editor-license\n *\n * Otherwise, it is permitted to integrate the Spine Runtimes into software or\n * otherwise create derivative works of the Spine Runtimes (collectively,\n * \"Products\"), provided that each user of the Products must obtain their own\n * Spine Editor license and redistribution of the Products in any form must\n * include this license and copyright notice.\n *\n * THE SPINE RUNTIMES ARE PROVIDED BY ESOTERIC SOFTWARE LLC \"AS IS\" AND ANY\n * EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\n * DISCLAIMED. IN NO EVENT SHALL ESOTERIC SOFTWARE LLC BE LIABLE FOR ANY\n * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES,\n * BUSINESS INTERRUPTION, OR LOSS OF USE, DATA, OR PROFITS) HOWEVER CAUSED AND\n * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THE\n * SPINE RUNTIMES, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *****************************************************************************/\n\nimport { Texture as PixiTexture } from 'pixi.js';\nimport { BlendMode, Texture, TextureFilter, TextureWrap } from '@esotericsoftware/spine-core';\n\nimport type { BLEND_MODES, SCALE_MODE, TextureSource, WRAP_MODE } from 'pixi.js';\n\nexport class SpineTexture extends Texture\n{\n    private static readonly textureMap: Map<TextureSource, SpineTexture> = new Map<TextureSource, SpineTexture>();\n\n    public static from(texture: TextureSource): SpineTexture\n    {\n        if (SpineTexture.textureMap.has(texture))\n        {\n            return SpineTexture.textureMap.get(texture) as SpineTexture;\n        }\n\n        return new SpineTexture(texture);\n    }\n\n    public readonly texture: PixiTexture;\n\n    private constructor(image: TextureSource)\n    {\n        // Todo: maybe add error handling if you feed a video texture to spine?\n        super(image.resource);\n        this.texture = PixiTexture.from(image);\n    }\n\n    public setFilters(minFilter: TextureFilter, magFilter: TextureFilter): void\n    {\n        const style = this.texture.source.style;\n\n        style.minFilter = SpineTexture.toPixiTextureFilter(minFilter);\n        style.magFilter = SpineTexture.toPixiTextureFilter(magFilter);\n        this.texture.source.autoGenerateMipmaps = SpineTexture.toPixiMipMap(minFilter);\n        this.texture.source.updateMipmaps();\n    }\n\n    public setWraps(uWrap: TextureWrap, vWrap: TextureWrap): void\n    {\n        const style = this.texture.source.style;\n\n        style.addressModeU = SpineTexture.toPixiTextureWrap(uWrap);\n        style.addressModeV = SpineTexture.toPixiTextureWrap(vWrap);\n    }\n\n    public dispose(): void\n    {\n        // I am not entirely sure about this...\n        this.texture.destroy();\n    }\n\n    private static toPixiMipMap(filter: TextureFilter): boolean\n    {\n        switch (filter)\n        {\n            case TextureFilter.Nearest:\n            case TextureFilter.Linear:\n                return false;\n\n            case TextureFilter.MipMapNearestLinear:\n            case TextureFilter.MipMapNearestNearest:\n            case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\n            case TextureFilter.MipMapLinearNearest:\n                return true;\n\n            default:\n                throw new Error(`Unknown texture filter: ${String(filter)}`);\n        }\n    }\n\n    private static toPixiTextureFilter(filter: TextureFilter): SCALE_MODE\n    {\n        switch (filter)\n        {\n            case TextureFilter.Nearest:\n            case TextureFilter.MipMapNearestLinear:\n            case TextureFilter.MipMapNearestNearest:\n                return 'nearest';\n\n            case TextureFilter.Linear:\n            case TextureFilter.MipMapLinearLinear: // TextureFilter.MipMapLinearLinear == TextureFilter.MipMap\n            case TextureFilter.MipMapLinearNearest:\n                return 'linear';\n\n            default:\n                throw new Error(`Unknown texture filter: ${String(filter)}`);\n        }\n    }\n\n    private static toPixiTextureWrap(wrap: TextureWrap): WRAP_MODE\n    {\n        switch (wrap)\n        {\n            case TextureWrap.ClampToEdge:\n                return 'clamp-to-edge';\n\n            case TextureWrap.MirroredRepeat:\n                return 'mirror-repeat';\n\n            case TextureWrap.Repeat:\n                return 'repeat';\n\n            default:\n                throw new Error(`Unknown texture wrap: ${String(wrap)}`);\n        }\n    }\n\n    public static toPixiBlending(blend: BlendMode): BLEND_MODES\n    {\n        switch (blend)\n        {\n            case BlendMode.Normal:\n                return 'normal';\n\n            case BlendMode.Additive:\n                return 'add';\n\n            case BlendMode.Multiply:\n                return 'multiply';\n\n            case BlendMode.Screen:\n                return 'screen';\n\n            default:\n                throw new Error(`Unknown blendMode: ${String(blend)}`);\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}