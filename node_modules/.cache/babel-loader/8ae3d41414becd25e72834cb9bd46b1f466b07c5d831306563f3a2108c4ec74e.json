{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport './attachments/Attachment.mjs';\nimport '@pixi-spine/base';\nimport { MeshAttachment } from './attachments/MeshAttachment.mjs';\nimport './attachments/RegionAttachment.mjs';\nimport './attachments/Sequence.mjs';\nclass SkinEntry {\n  constructor(slotIndex, name, attachment) {\n    this.slotIndex = slotIndex;\n    this.name = name;\n    this.attachment = attachment;\n  }\n}\nclass Skin {\n  constructor(name) {\n    this.attachments = new Array();\n    this.bones = Array();\n    this.constraints = new Array();\n    if (!name) throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n  /** Adds an attachment to the skin for the specified slot index and name. */\n  setAttachment(slotIndex, name, attachment) {\n    if (!attachment) throw new Error(\"attachment cannot be null.\");\n    const attachments = this.attachments;\n    if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n    if (!attachments[slotIndex]) attachments[slotIndex] = {};\n    attachments[slotIndex][name] = attachment;\n  }\n  /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n  addSkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n    }\n  }\n  /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n   * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n  copySkin(skin) {\n    for (let i = 0; i < skin.bones.length; i++) {\n      const bone = skin.bones[i];\n      let contained = false;\n      for (let ii = 0; ii < this.bones.length; ii++) {\n        if (this.bones[ii] == bone) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.bones.push(bone);\n    }\n    for (let i = 0; i < skin.constraints.length; i++) {\n      const constraint = skin.constraints[i];\n      let contained = false;\n      for (let ii = 0; ii < this.constraints.length; ii++) {\n        if (this.constraints[ii] == constraint) {\n          contained = true;\n          break;\n        }\n      }\n      if (!contained) this.constraints.push(constraint);\n    }\n    const attachments = skin.getAttachments();\n    for (let i = 0; i < attachments.length; i++) {\n      const attachment = attachments[i];\n      if (!attachment.attachment) continue;\n      if (attachment.attachment instanceof MeshAttachment) {\n        attachment.attachment = attachment.attachment.newLinkedMesh();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      } else {\n        attachment.attachment = attachment.attachment.copy();\n        this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n      }\n    }\n  }\n  /** Returns the attachment for the specified slot index and name, or null. */\n  getAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    return dictionary ? dictionary[name] : null;\n  }\n  /** Removes the attachment in the skin for the specified slot index and name, if any. */\n  removeAttachment(slotIndex, name) {\n    const dictionary = this.attachments[slotIndex];\n    if (dictionary) delete dictionary[name];\n  }\n  /** Returns all attachments in this skin. */\n  getAttachments() {\n    const entries = new Array();\n    for (let i = 0; i < this.attachments.length; i++) {\n      const slotAttachments = this.attachments[i];\n      if (slotAttachments) {\n        for (const name in slotAttachments) {\n          const attachment = slotAttachments[name];\n          if (attachment) entries.push(new SkinEntry(i, name, attachment));\n        }\n      }\n    }\n    return entries;\n  }\n  /** Returns all attachments in this skin for the specified slot index. */\n  getAttachmentsForSlot(slotIndex, attachments) {\n    const slotAttachments = this.attachments[slotIndex];\n    if (slotAttachments) {\n      for (const name in slotAttachments) {\n        const attachment = slotAttachments[name];\n        if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n      }\n    }\n  }\n  /** Clears all attachments, bones, and constraints. */\n  clear() {\n    this.attachments.length = 0;\n    this.bones.length = 0;\n    this.constraints.length = 0;\n  }\n  /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n  attachAll(skeleton, oldSkin) {\n    let slotIndex = 0;\n    for (let i = 0; i < skeleton.slots.length; i++) {\n      const slot = skeleton.slots[i];\n      const slotAttachment = slot.getAttachment();\n      if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n        const dictionary = oldSkin.attachments[slotIndex];\n        for (const key in dictionary) {\n          const skinAttachment = dictionary[key];\n          if (slotAttachment == skinAttachment) {\n            const attachment = this.getAttachment(slotIndex, key);\n            if (attachment) slot.setAttachment(attachment);\n            break;\n          }\n        }\n      }\n      slotIndex++;\n    }\n  }\n}\nexport { Skin, SkinEntry };","map":{"version":3,"names":["SkinEntry","constructor","slotIndex","name","attachment","Skin","attachments","Array","bones","constraints","Error","setAttachment","length","addSkin","skin","i","bone","contained","ii","push","constraint","getAttachments","copySkin","MeshAttachment","newLinkedMesh","copy","getAttachment","dictionary","removeAttachment","entries","slotAttachments","getAttachmentsForSlot","clear","attachAll","skeleton","oldSkin","slots","slot","slotAttachment","key","skinAttachment"],"sources":["../../src/core/Skin.ts"],"sourcesContent":["import { Attachment, MeshAttachment } from './attachments';\nimport type { BoneData } from './BoneData';\nimport type { ConstraintData } from './ConstraintData';\nimport type { Skeleton } from './Skeleton';\n\nimport type { StringMap, ISkin } from '@pixi-spine/base';\n\n/** Stores an entry in the skin consisting of the slot index, name, and attachment\n * @public\n * **/\nexport class SkinEntry {\n    constructor(public slotIndex: number, public name: string, public attachment: Attachment) {}\n}\n\n/** Stores attachments by slot index and attachment name.\n *\n * See SkeletonData {@link SkeletonData#defaultSkin}, Skeleton {@link Skeleton#skin}, and\n * [Runtime skins](http://esotericsoftware.com/spine-runtime-skins) in the Spine Runtimes Guide.\n * @public\n * */\nexport class Skin implements ISkin {\n    /** The skin's name, which is unique across all skins in the skeleton. */\n    name: string;\n\n    attachments = new Array<StringMap<Attachment>>();\n    bones = Array<BoneData>();\n    constraints = new Array<ConstraintData>();\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    /** Adds an attachment to the skin for the specified slot index and name. */\n    setAttachment(slotIndex: number, name: string, attachment: Attachment) {\n        if (!attachment) throw new Error('attachment cannot be null.');\n        const attachments = this.attachments;\n\n        if (slotIndex >= attachments.length) attachments.length = slotIndex + 1;\n        if (!attachments[slotIndex]) attachments[slotIndex] = {};\n        attachments[slotIndex][name] = attachment;\n    }\n\n    /** Adds all attachments, bones, and constraints from the specified skin to this skin. */\n    addSkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.bones.length; ii++) {\n                if (this.bones[ii] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.constraints.length; ii++) {\n                if (this.constraints[ii] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n        }\n    }\n\n    /** Adds all bones and constraints and copies of all attachments from the specified skin to this skin. Mesh attachments are not\n     * copied, instead a new linked mesh is created. The attachment copies can be modified without affecting the originals. */\n    copySkin(skin: Skin) {\n        for (let i = 0; i < skin.bones.length; i++) {\n            const bone = skin.bones[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.bones.length; ii++) {\n                if (this.bones[ii] == bone) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.bones.push(bone);\n        }\n\n        for (let i = 0; i < skin.constraints.length; i++) {\n            const constraint = skin.constraints[i];\n            let contained = false;\n\n            for (let ii = 0; ii < this.constraints.length; ii++) {\n                if (this.constraints[ii] == constraint) {\n                    contained = true;\n                    break;\n                }\n            }\n            if (!contained) this.constraints.push(constraint);\n        }\n\n        const attachments = skin.getAttachments();\n\n        for (let i = 0; i < attachments.length; i++) {\n            const attachment = attachments[i];\n\n            if (!attachment.attachment) continue;\n            if (attachment.attachment instanceof MeshAttachment) {\n                attachment.attachment = attachment.attachment.newLinkedMesh();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            } else {\n                attachment.attachment = attachment.attachment.copy();\n                this.setAttachment(attachment.slotIndex, attachment.name, attachment.attachment);\n            }\n        }\n    }\n\n    /** Returns the attachment for the specified slot index and name, or null. */\n    getAttachment(slotIndex: number, name: string): Attachment | null {\n        const dictionary = this.attachments[slotIndex];\n\n        return dictionary ? dictionary[name] : null;\n    }\n\n    /** Removes the attachment in the skin for the specified slot index and name, if any. */\n    removeAttachment(slotIndex: number, name: string) {\n        const dictionary = this.attachments[slotIndex];\n\n        if (dictionary) delete dictionary[name];\n    }\n\n    /** Returns all attachments in this skin. */\n    getAttachments(): Array<SkinEntry> {\n        const entries = new Array<SkinEntry>();\n\n        for (let i = 0; i < this.attachments.length; i++) {\n            const slotAttachments = this.attachments[i];\n\n            if (slotAttachments) {\n                for (const name in slotAttachments) {\n                    const attachment = slotAttachments[name];\n\n                    if (attachment) entries.push(new SkinEntry(i, name, attachment));\n                }\n            }\n        }\n\n        return entries;\n    }\n\n    /** Returns all attachments in this skin for the specified slot index. */\n    getAttachmentsForSlot(slotIndex: number, attachments: Array<SkinEntry>) {\n        const slotAttachments = this.attachments[slotIndex];\n\n        if (slotAttachments) {\n            for (const name in slotAttachments) {\n                const attachment = slotAttachments[name];\n\n                if (attachment) attachments.push(new SkinEntry(slotIndex, name, attachment));\n            }\n        }\n    }\n\n    /** Clears all attachments, bones, and constraints. */\n    clear() {\n        this.attachments.length = 0;\n        this.bones.length = 0;\n        this.constraints.length = 0;\n    }\n\n    /** Attach each attachment in this skin if the corresponding attachment in the old skin is currently attached. */\n    attachAll(skeleton: Skeleton, oldSkin: Skin) {\n        let slotIndex = 0;\n\n        for (let i = 0; i < skeleton.slots.length; i++) {\n            const slot = skeleton.slots[i];\n            const slotAttachment = slot.getAttachment();\n\n            if (slotAttachment && slotIndex < oldSkin.attachments.length) {\n                const dictionary = oldSkin.attachments[slotIndex];\n\n                for (const key in dictionary) {\n                    const skinAttachment: Attachment = dictionary[key];\n\n                    if (slotAttachment == skinAttachment) {\n                        const attachment = this.getAttachment(slotIndex, key);\n\n                        if (attachment) slot.setAttachment(attachment);\n                        break;\n                    }\n                }\n            }\n            slotIndex++;\n        }\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}