{"ast":null,"code":"import { Utils } from '@pixi-spine/base';\nclass Attachment {\n  constructor(name) {\n    if (!name) throw new Error(\"name cannot be null.\");\n    this.name = name;\n  }\n}\nconst _VertexAttachment = class extends Attachment {\n  constructor(name) {\n    super(name);\n    /** The unique ID for this attachment. */\n    this.id = _VertexAttachment.nextID++;\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n     * if this attachment has no weights. */\n    this.bones = null;\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n     * each vertex. */\n    this.vertices = [];\n    /** The maximum number of world vertex values that can be output by\n     * {@link #computeWorldVertices()} using the `count` parameter. */\n    this.worldVerticesLength = 0;\n    /** Timelines for the timeline attachment are also applied to this attachment.\n     * May be null if no attachment-specific timelines should be applied. */\n    this.timelineAttachment = this;\n  }\n  computeWorldVerticesOld(slot, worldVertices) {\n    this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n  }\n  /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n   * not empty, it is used to deform the vertices.\n   *\n   * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n   * Runtimes Guide.\n   * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n   * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n   * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n   *           `stride` / 2.\n   * @param offset The `worldVertices` index to begin writing values.\n   * @param stride The number of `worldVertices` entries between the value pairs written. */\n  computeWorldVertices(slot, start, count, worldVertices, offset, stride) {\n    count = offset + (count >> 1) * stride;\n    const skeleton = slot.bone.skeleton;\n    const deformArray = slot.deform;\n    let vertices = this.vertices;\n    const bones = this.bones;\n    if (!bones) {\n      if (deformArray.length > 0) vertices = deformArray;\n      const mat = slot.bone.matrix;\n      const x = mat.tx;\n      const y = mat.ty;\n      const a = mat.a;\n      const b = mat.c;\n      const c = mat.b;\n      const d = mat.d;\n      for (let v2 = start, w = offset; w < count; v2 += 2, w += stride) {\n        const vx = vertices[v2];\n        const vy = vertices[v2 + 1];\n        worldVertices[w] = vx * a + vy * b + x;\n        worldVertices[w + 1] = vx * c + vy * d + y;\n      }\n      return;\n    }\n    let v = 0;\n    let skip = 0;\n    for (let i = 0; i < start; i += 2) {\n      const n = bones[v];\n      v += n + 1;\n      skip += n;\n    }\n    const skeletonBones = skeleton.bones;\n    if (deformArray.length == 0) {\n      for (let w = offset, b = skip * 3; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b];\n          const vy = vertices[b + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    } else {\n      const deform = deformArray;\n      for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n        let wx = 0;\n        let wy = 0;\n        let n = bones[v++];\n        n += v;\n        for (; v < n; v++, b += 3, f += 2) {\n          const mat = skeletonBones[bones[v]].matrix;\n          const vx = vertices[b] + deform[f];\n          const vy = vertices[b + 1] + deform[f + 1];\n          const weight = vertices[b + 2];\n          wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n          wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n        }\n        worldVertices[w] = wx;\n        worldVertices[w + 1] = wy;\n      }\n    }\n  }\n  /** Does not copy id (generated) or name (set on construction). **/\n  copyTo(attachment) {\n    if (this.bones) {\n      attachment.bones = new Array(this.bones.length);\n      Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n    } else attachment.bones = null;\n    if (this.vertices) {\n      attachment.vertices = Utils.newFloatArray(this.vertices.length);\n      Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n    }\n    attachment.worldVerticesLength = this.worldVerticesLength;\n    attachment.timelineAttachment = this.timelineAttachment;\n  }\n};\nlet VertexAttachment = _VertexAttachment;\nVertexAttachment.nextID = 0;\nexport { Attachment, VertexAttachment };","map":{"version":3,"names":["Attachment","constructor","name","Error","_VertexAttachment","id","nextID","bones","vertices","worldVerticesLength","timelineAttachment","computeWorldVerticesOld","slot","worldVertices","computeWorldVertices","start","count","offset","stride","skeleton","bone","deformArray","deform","length","mat","matrix","x","tx","y","ty","a","b","c","d","v2","w","vx","vy","v","skip","i","n","skeletonBones","wx","wy","weight","f","copyTo","attachment","Array","Utils","arrayCopy","newFloatArray","VertexAttachment"],"sources":["../../../src/core/attachments/Attachment.ts"],"sourcesContent":["import { AttachmentType, Utils } from '@pixi-spine/base';\nimport type { IAttachment, NumberArrayLike } from '@pixi-spine/base';\n\nimport type { Slot } from '../Slot';\n\n/**\n * The base class for all attachments.\n * @public\n */\nexport abstract class Attachment implements IAttachment {\n    name: string;\n    type: AttachmentType;\n\n    constructor(name: string) {\n        if (!name) throw new Error('name cannot be null.');\n        this.name = name;\n    }\n\n    abstract copy(): Attachment;\n}\n\n/**\n * Base class for an attachment with vertices that are transformed by one or more bones and can be deformed by a slot's\n * {@link Slot#deform}.\n * @public\n */\nexport abstract class VertexAttachment extends Attachment {\n    private static nextID = 0;\n\n    /** The unique ID for this attachment. */\n    id = VertexAttachment.nextID++;\n\n    /** The bones which affect the {@link #getVertices()}. The array entries are, for each vertex, the number of bones affecting\n     * the vertex followed by that many bone indices, which is the index of the bone in {@link Skeleton#bones}. Will be null\n     * if this attachment has no weights. */\n    bones: Array<number> | null = null;\n\n    /** The vertex positions in the bone's coordinate system. For a non-weighted attachment, the values are `x,y`\n     * entries for each vertex. For a weighted attachment, the values are `x,y,weight` entries for each bone affecting\n     * each vertex. */\n    vertices: NumberArrayLike = [];\n\n    /** The maximum number of world vertex values that can be output by\n     * {@link #computeWorldVertices()} using the `count` parameter. */\n    worldVerticesLength = 0;\n\n    /** Timelines for the timeline attachment are also applied to this attachment.\n     * May be null if no attachment-specific timelines should be applied. */\n    timelineAttachment: Attachment = this;\n\n    constructor(name: string) {\n        super(name);\n    }\n\n    computeWorldVerticesOld(slot: Slot, worldVertices: ArrayLike<number>) {\n        this.computeWorldVertices(slot, 0, this.worldVerticesLength, worldVertices, 0, 2);\n    }\n    /** Transforms the attachment's local {@link #vertices} to world coordinates. If the slot's {@link Slot#deform} is\n     * not empty, it is used to deform the vertices.\n     *\n     * See [World transforms](http://esotericsoftware.com/spine-runtime-skeletons#World-transforms) in the Spine\n     * Runtimes Guide.\n     * @param start The index of the first {@link #vertices} value to transform. Each vertex has 2 values, x and y.\n     * @param count The number of world vertex values to output. Must be <= {@link #worldVerticesLength} - `start`.\n     * @param worldVertices The output world vertices. Must have a length >= `offset` + `count` *\n     *           `stride` / 2.\n     * @param offset The `worldVertices` index to begin writing values.\n     * @param stride The number of `worldVertices` entries between the value pairs written. */\n    computeWorldVertices(slot: Slot, start: number, count: number, worldVertices: NumberArrayLike, offset: number, stride: number) {\n        count = offset + (count >> 1) * stride;\n        const skeleton = slot.bone.skeleton;\n        const deformArray = slot.deform;\n        let vertices = this.vertices;\n        const bones = this.bones;\n\n        if (!bones) {\n            if (deformArray.length > 0) vertices = deformArray;\n            const mat = slot.bone.matrix;\n            const x = mat.tx;\n            const y = mat.ty;\n            const a = mat.a;\n            const b = mat.c;\n            const c = mat.b;\n            const d = mat.d;\n\n            for (let v = start, w = offset; w < count; v += 2, w += stride) {\n                const vx = vertices[v];\n                const vy = vertices[v + 1];\n\n                worldVertices[w] = vx * a + vy * b + x;\n                worldVertices[w + 1] = vx * c + vy * d + y;\n            }\n\n            return;\n        }\n        let v = 0;\n        let skip = 0;\n\n        for (let i = 0; i < start; i += 2) {\n            const n = bones[v];\n\n            v += n + 1;\n            skip += n;\n        }\n        const skeletonBones = skeleton.bones;\n\n        if (deformArray.length == 0) {\n            for (let w = offset, b = skip * 3; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b];\n                    const vy = vertices[b + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        } else {\n            const deform = deformArray;\n\n            for (let w = offset, b = skip * 3, f = skip << 1; w < count; w += stride) {\n                let wx = 0;\n                let wy = 0;\n                let n = bones[v++];\n\n                n += v;\n                for (; v < n; v++, b += 3, f += 2) {\n                    const mat = skeletonBones[bones[v]].matrix;\n                    const vx = vertices[b] + deform[f];\n                    const vy = vertices[b + 1] + deform[f + 1];\n                    const weight = vertices[b + 2];\n\n                    wx += (vx * mat.a + vy * mat.c + mat.tx) * weight;\n                    wy += (vx * mat.b + vy * mat.d + mat.ty) * weight;\n                }\n                worldVertices[w] = wx;\n                worldVertices[w + 1] = wy;\n            }\n        }\n    }\n\n    /** Does not copy id (generated) or name (set on construction). **/\n    copyTo(attachment: VertexAttachment) {\n        if (this.bones) {\n            attachment.bones = new Array<number>(this.bones.length);\n            Utils.arrayCopy(this.bones, 0, attachment.bones, 0, this.bones.length);\n        } else attachment.bones = null;\n\n        if (this.vertices) {\n            attachment.vertices = Utils.newFloatArray(this.vertices.length);\n            Utils.arrayCopy(this.vertices, 0, attachment.vertices, 0, this.vertices.length);\n        }\n\n        attachment.worldVerticesLength = this.worldVerticesLength;\n        attachment.timelineAttachment = this.timelineAttachment;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}