{"ast":null,"code":"import \"core-js/modules/es.array.push.js\";\nimport { AttachmentType } from './AttachmentType.mjs';\nimport { Pool, Utils } from './Utils.mjs';\nclass SkeletonBoundsBase {\n  constructor() {\n    /** The left edge of the axis aligned bounding box. */\n    this.minX = 0;\n    /** The bottom edge of the axis aligned bounding box. */\n    this.minY = 0;\n    /** The right edge of the axis aligned bounding box. */\n    this.maxX = 0;\n    /** The top edge of the axis aligned bounding box. */\n    this.maxY = 0;\n    /** The visible bounding boxes. */\n    this.boundingBoxes = new Array();\n    /** The world vertices for the bounding box polygons. */\n    this.polygons = new Array();\n    this.polygonPool = new Pool(() => Utils.newFloatArray(16));\n  }\n  /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n   * box's polygon.\n   * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n   *           SkeletonBounds AABB methods will always return true. */\n  update(skeleton, updateAabb) {\n    if (!skeleton) throw new Error(\"skeleton cannot be null.\");\n    const boundingBoxes = this.boundingBoxes;\n    const polygons = this.polygons;\n    const polygonPool = this.polygonPool;\n    const slots = skeleton.slots;\n    const slotCount = slots.length;\n    boundingBoxes.length = 0;\n    polygonPool.freeAll(polygons);\n    polygons.length = 0;\n    for (let i = 0; i < slotCount; i++) {\n      const slot = slots[i];\n      if (!slot.bone.active) continue;\n      const attachment = slot.getAttachment();\n      if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\n        const boundingBox = attachment;\n        boundingBoxes.push(boundingBox);\n        let polygon = polygonPool.obtain();\n        if (polygon.length != boundingBox.worldVerticesLength) {\n          polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n        }\n        polygons.push(polygon);\n        boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n      }\n    }\n    if (updateAabb) {\n      this.aabbCompute();\n    } else {\n      this.minX = Number.POSITIVE_INFINITY;\n      this.minY = Number.POSITIVE_INFINITY;\n      this.maxX = Number.NEGATIVE_INFINITY;\n      this.maxY = Number.NEGATIVE_INFINITY;\n    }\n  }\n  aabbCompute() {\n    let minX = Number.POSITIVE_INFINITY;\n    let minY = Number.POSITIVE_INFINITY;\n    let maxX = Number.NEGATIVE_INFINITY;\n    let maxY = Number.NEGATIVE_INFINITY;\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      const polygon = polygons[i];\n      const vertices = polygon;\n      for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n        const x = vertices[ii];\n        const y = vertices[ii + 1];\n        minX = Math.min(minX, x);\n        minY = Math.min(minY, y);\n        maxX = Math.max(maxX, x);\n        maxY = Math.max(maxY, y);\n      }\n    }\n    this.minX = minX;\n    this.minY = minY;\n    this.maxX = maxX;\n    this.maxY = maxY;\n  }\n  /** Returns true if the axis aligned bounding box contains the point. */\n  aabbContainsPoint(x, y) {\n    return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n  }\n  /** Returns true if the axis aligned bounding box intersects the line segment. */\n  aabbIntersectsSegment(x1, y1, x2, y2) {\n    const minX = this.minX;\n    const minY = this.minY;\n    const maxX = this.maxX;\n    const maxY = this.maxY;\n    if (x1 <= minX && x2 <= minX || y1 <= minY && y2 <= minY || x1 >= maxX && x2 >= maxX || y1 >= maxY && y2 >= maxY) {\n      return false;\n    }\n    const m = (y2 - y1) / (x2 - x1);\n    let y = m * (minX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    y = m * (maxX - x1) + y1;\n    if (y > minY && y < maxY) return true;\n    let x = (minY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    x = (maxY - y1) / m + x1;\n    if (x > minX && x < maxX) return true;\n    return false;\n  }\n  /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n  aabbIntersectsSkeleton(bounds) {\n    return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n  }\n  /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n   * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\n   * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\n  containsPoint(x, y) {\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n    }\n    return null;\n  }\n  /** Returns true if the polygon contains the point. */\n  containsPointPolygon(polygon, x, y) {\n    const vertices = polygon;\n    const nn = polygon.length;\n    let prevIndex = nn - 2;\n    let inside = false;\n    for (let ii = 0; ii < nn; ii += 2) {\n      const vertexY = vertices[ii + 1];\n      const prevY = vertices[prevIndex + 1];\n      if (vertexY < y && prevY >= y || prevY < y && vertexY >= y) {\n        const vertexX = vertices[ii];\n        if (vertexX + (y - vertexY) / (prevY - vertexY) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n      }\n      prevIndex = ii;\n    }\n    return inside;\n  }\n  /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n   * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n   * true. */\n  intersectsSegment(x1, y1, x2, y2) {\n    const polygons = this.polygons;\n    for (let i = 0, n = polygons.length; i < n; i++) {\n      if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n    }\n    return null;\n  }\n  /** Returns true if the polygon contains any part of the line segment. */\n  intersectsSegmentPolygon(polygon, x1, y1, x2, y2) {\n    const vertices = polygon;\n    const nn = polygon.length;\n    const width12 = x1 - x2;\n    const height12 = y1 - y2;\n    const det1 = x1 * y2 - y1 * x2;\n    let x3 = vertices[nn - 2];\n    let y3 = vertices[nn - 1];\n    for (let ii = 0; ii < nn; ii += 2) {\n      const x4 = vertices[ii];\n      const y4 = vertices[ii + 1];\n      const det2 = x3 * y4 - y3 * x4;\n      const width34 = x3 - x4;\n      const height34 = y3 - y4;\n      const det3 = width12 * height34 - height12 * width34;\n      const x = (det1 * width34 - width12 * det2) / det3;\n      if ((x >= x3 && x <= x4 || x >= x4 && x <= x3) && (x >= x1 && x <= x2 || x >= x2 && x <= x1)) {\n        const y = (det1 * height34 - height12 * det2) / det3;\n        if ((y >= y3 && y <= y4 || y >= y4 && y <= y3) && (y >= y1 && y <= y2 || y >= y2 && y <= y1)) return true;\n      }\n      x3 = x4;\n      y3 = y4;\n    }\n    return false;\n  }\n  /** Returns the polygon for the specified bounding box, or null. */\n  getPolygon(boundingBox) {\n    if (!boundingBox) throw new Error(\"boundingBox cannot be null.\");\n    const index = this.boundingBoxes.indexOf(boundingBox);\n    return index == -1 ? null : this.polygons[index];\n  }\n  /** The width of the axis aligned bounding box. */\n  getWidth() {\n    return this.maxX - this.minX;\n  }\n  /** The height of the axis aligned bounding box. */\n  getHeight() {\n    return this.maxY - this.minY;\n  }\n}\nexport { SkeletonBoundsBase };","map":{"version":3,"names":["SkeletonBoundsBase","constructor","minX","minY","maxX","maxY","boundingBoxes","Array","polygons","polygonPool","Pool","Utils","newFloatArray","update","skeleton","updateAabb","Error","slots","slotCount","length","freeAll","i","slot","bone","active","attachment","getAttachment","type","AttachmentType","BoundingBox","boundingBox","push","polygon","obtain","worldVerticesLength","computeWorldVertices","aabbCompute","Number","POSITIVE_INFINITY","NEGATIVE_INFINITY","n","vertices","ii","nn","x","y","Math","min","max","aabbContainsPoint","aabbIntersectsSegment","x1","y1","x2","y2","m","aabbIntersectsSkeleton","bounds","containsPoint","containsPointPolygon","prevIndex","inside","vertexY","prevY","vertexX","intersectsSegment","intersectsSegmentPolygon","width12","height12","det1","x3","y3","x4","y4","det2","width34","height34","det3","getPolygon","index","indexOf","getWidth","getHeight"],"sources":["../../src/core/SkeletonBoundsBase.ts"],"sourcesContent":["import { AttachmentType } from './AttachmentType';\nimport type { ISkeleton, IVertexAttachment } from './ISkeleton';\nimport { NumberArrayLike, Pool, Utils } from './Utils';\n\n/** Collects each visible BoundingBoxAttachment and computes the world vertices for its polygon. The polygon vertices are\n * provided along with convenience methods for doing hit detection.\n * @public\n * */\nexport class SkeletonBoundsBase<BoundingBoxAttachment extends IVertexAttachment> {\n    /** The left edge of the axis aligned bounding box. */\n    minX = 0;\n\n    /** The bottom edge of the axis aligned bounding box. */\n    minY = 0;\n\n    /** The right edge of the axis aligned bounding box. */\n    maxX = 0;\n\n    /** The top edge of the axis aligned bounding box. */\n    maxY = 0;\n\n    /** The visible bounding boxes. */\n    boundingBoxes = new Array<BoundingBoxAttachment>();\n\n    /** The world vertices for the bounding box polygons. */\n    polygons = new Array<NumberArrayLike>();\n\n    private polygonPool = new Pool<NumberArrayLike>(() => Utils.newFloatArray(16));\n\n    /** Clears any previous polygons, finds all visible bounding box attachments, and computes the world vertices for each bounding\n     * box's polygon.\n     * @param updateAabb If true, the axis aligned bounding box containing all the polygons is computed. If false, the\n     *           SkeletonBounds AABB methods will always return true. */\n    update(skeleton: ISkeleton, updateAabb: boolean) {\n        if (!skeleton) throw new Error('skeleton cannot be null.');\n        const boundingBoxes = this.boundingBoxes;\n        const polygons = this.polygons;\n        const polygonPool = this.polygonPool;\n        const slots = skeleton.slots;\n        const slotCount = slots.length;\n\n        boundingBoxes.length = 0;\n        polygonPool.freeAll(polygons);\n        polygons.length = 0;\n\n        for (let i = 0; i < slotCount; i++) {\n            const slot = slots[i];\n\n            if (!slot.bone.active) continue;\n            const attachment = slot.getAttachment();\n\n            if (attachment != null && attachment.type === AttachmentType.BoundingBox) {\n                const boundingBox = attachment as BoundingBoxAttachment;\n\n                boundingBoxes.push(boundingBox);\n\n                let polygon = polygonPool.obtain() as NumberArrayLike;\n\n                if (polygon.length != boundingBox.worldVerticesLength) {\n                    polygon = Utils.newFloatArray(boundingBox.worldVerticesLength);\n                }\n                polygons.push(polygon);\n                boundingBox.computeWorldVertices(slot, 0, boundingBox.worldVerticesLength, polygon, 0, 2);\n            }\n        }\n\n        if (updateAabb) {\n            this.aabbCompute();\n        } else {\n            this.minX = Number.POSITIVE_INFINITY;\n            this.minY = Number.POSITIVE_INFINITY;\n            this.maxX = Number.NEGATIVE_INFINITY;\n            this.maxY = Number.NEGATIVE_INFINITY;\n        }\n    }\n\n    aabbCompute() {\n        let minX = Number.POSITIVE_INFINITY;\n        let minY = Number.POSITIVE_INFINITY;\n        let maxX = Number.NEGATIVE_INFINITY;\n        let maxY = Number.NEGATIVE_INFINITY;\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            const polygon = polygons[i];\n            const vertices = polygon;\n\n            for (let ii = 0, nn = polygon.length; ii < nn; ii += 2) {\n                const x = vertices[ii];\n                const y = vertices[ii + 1];\n\n                minX = Math.min(minX, x);\n                minY = Math.min(minY, y);\n                maxX = Math.max(maxX, x);\n                maxY = Math.max(maxY, y);\n            }\n        }\n        this.minX = minX;\n        this.minY = minY;\n        this.maxX = maxX;\n        this.maxY = maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box contains the point. */\n    aabbContainsPoint(x: number, y: number) {\n        return x >= this.minX && x <= this.maxX && y >= this.minY && y <= this.maxY;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the line segment. */\n    aabbIntersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n        const minX = this.minX;\n        const minY = this.minY;\n        const maxX = this.maxX;\n        const maxY = this.maxY;\n\n        if ((x1 <= minX && x2 <= minX) || (y1 <= minY && y2 <= minY) || (x1 >= maxX && x2 >= maxX) || (y1 >= maxY && y2 >= maxY)) {\n            return false;\n        }\n        const m = (y2 - y1) / (x2 - x1);\n        let y = m * (minX - x1) + y1;\n\n        if (y > minY && y < maxY) return true;\n        y = m * (maxX - x1) + y1;\n        if (y > minY && y < maxY) return true;\n        let x = (minY - y1) / m + x1;\n\n        if (x > minX && x < maxX) return true;\n        x = (maxY - y1) / m + x1;\n        if (x > minX && x < maxX) return true;\n\n        return false;\n    }\n\n    /** Returns true if the axis aligned bounding box intersects the axis aligned bounding box of the specified bounds. */\n    aabbIntersectsSkeleton(bounds: SkeletonBoundsBase<BoundingBoxAttachment>) {\n        return this.minX < bounds.maxX && this.maxX > bounds.minX && this.minY < bounds.maxY && this.maxY > bounds.minY;\n    }\n\n    /** Returns the first bounding box attachment that contains the point, or null. When doing many checks, it is usually more\n     * efficient to only call this method if {@link #aabbContainsPoint(float, float)} returns true.\n     * Cannot be done here because BoundingBoxAttachment is not a thing yet*/\n    containsPoint(x: number, y: number): BoundingBoxAttachment | null {\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            if (this.containsPointPolygon(polygons[i], x, y)) return this.boundingBoxes[i];\n        }\n\n        return null;\n    }\n\n    /** Returns true if the polygon contains the point. */\n    containsPointPolygon(polygon: NumberArrayLike, x: number, y: number) {\n        const vertices = polygon;\n        const nn = polygon.length;\n\n        let prevIndex = nn - 2;\n        let inside = false;\n\n        for (let ii = 0; ii < nn; ii += 2) {\n            const vertexY = vertices[ii + 1];\n            const prevY = vertices[prevIndex + 1];\n\n            if ((vertexY < y && prevY >= y) || (prevY < y && vertexY >= y)) {\n                const vertexX = vertices[ii];\n\n                if (vertexX + ((y - vertexY) / (prevY - vertexY)) * (vertices[prevIndex] - vertexX) < x) inside = !inside;\n            }\n            prevIndex = ii;\n        }\n\n        return inside;\n    }\n\n    /** Returns the first bounding box attachment that contains any part of the line segment, or null. When doing many checks, it\n     * is usually more efficient to only call this method if {@link #aabbIntersectsSegment()} returns\n     * true. */\n    intersectsSegment(x1: number, y1: number, x2: number, y2: number) {\n        const polygons = this.polygons;\n\n        for (let i = 0, n = polygons.length; i < n; i++) {\n            if (this.intersectsSegmentPolygon(polygons[i], x1, y1, x2, y2)) return this.boundingBoxes[i];\n        }\n\n        return null;\n    }\n\n    /** Returns true if the polygon contains any part of the line segment. */\n    intersectsSegmentPolygon(polygon: NumberArrayLike, x1: number, y1: number, x2: number, y2: number) {\n        const vertices = polygon;\n        const nn = polygon.length;\n\n        const width12 = x1 - x2;\n        const height12 = y1 - y2;\n        const det1 = x1 * y2 - y1 * x2;\n        let x3 = vertices[nn - 2];\n        let y3 = vertices[nn - 1];\n\n        for (let ii = 0; ii < nn; ii += 2) {\n            const x4 = vertices[ii];\n            const y4 = vertices[ii + 1];\n            const det2 = x3 * y4 - y3 * x4;\n            const width34 = x3 - x4;\n            const height34 = y3 - y4;\n            const det3 = width12 * height34 - height12 * width34;\n            const x = (det1 * width34 - width12 * det2) / det3;\n\n            if (((x >= x3 && x <= x4) || (x >= x4 && x <= x3)) && ((x >= x1 && x <= x2) || (x >= x2 && x <= x1))) {\n                const y = (det1 * height34 - height12 * det2) / det3;\n\n                if (((y >= y3 && y <= y4) || (y >= y4 && y <= y3)) && ((y >= y1 && y <= y2) || (y >= y2 && y <= y1))) return true;\n            }\n            x3 = x4;\n            y3 = y4;\n        }\n\n        return false;\n    }\n\n    /** Returns the polygon for the specified bounding box, or null. */\n    getPolygon(boundingBox: BoundingBoxAttachment) {\n        if (!boundingBox) throw new Error('boundingBox cannot be null.');\n        const index = this.boundingBoxes.indexOf(boundingBox);\n\n        return index == -1 ? null : this.polygons[index];\n    }\n\n    /** The width of the axis aligned bounding box. */\n    getWidth() {\n        return this.maxX - this.minX;\n    }\n\n    /** The height of the axis aligned bounding box. */\n    getHeight() {\n        return this.maxY - this.minY;\n    }\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}